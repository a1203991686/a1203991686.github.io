<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android网络请求3--解析OkHttp源码]]></title>
    <url>%2Fposts%2F151ac78a.html</url>
    <content type="text"><![CDATA[1. OkHttp简介okhttp是一个第三方类库，用于android中请求网络。 这是一个开源项目,是安卓端最火热的轻量级框架,由移动支付Square公司贡献。用于替代因移除了HttpClient而导致没用的Volley。 目前更多人选择了Retrofit。 2. 源码解析 本文对OkHttp的探讨全部基于目前的最新版OkHttp:4.0.1，而这个版本作者已经使用kotlin对源码进行了重写，所以有些小伙伴可能阅读稍微有点问题，但是别担心，本文中所涉及的源码阅读起来基本上和Java一样，所以请不会kotlin的小伙伴还是耐心看下去，不太懂的语法就百度下，同时我也会对某些语法作注释 2.1 OkHttp请求流程2.1.1 从请求处理开始分析我们无论在使用OkHttp进行什么请求的时候都会创建OkHttpClient对象并调用他的newCall()方法，那我们就从这个方法看起： 123override fun newCall(request: Request): Call &#123;return RealCall.newRealCall(this, request, forWebSocket = false)&#125; 可以看到返回了一个RealCall对象，所以也就意味着我们使用OkHttpClient对象调用的execute()操作实际上是RealCall的execute()操作，那我们就来看RealCall的execute()方法： 123456789101112131415161718192021override fun execute(): Response &#123; // 添加同步锁 synchronized(this) &#123; // check()是kotlin特有的一个方法，他本质上就是一个if， // 但是当他的判断语句是false的话， // 他就会抛出一个IllegalStateException异常，异常的内容就是后面的语句 check(!executed) &#123; "Already Executed" &#125; executed = true // executed是一个布尔值，他的作用就是判断是不是执行过了， // 如果执行过了还执行了这个方法的话就抛异常 &#125; // transmitter用于连接OKHTTP的应用程序和网络层，不用多管 transmitter.timeoutEnter() transmitter.callStart() try &#123; client.dispatcher.executed(this) return getResponseWithInterceptorChain() &#125; finally &#123; client.dispatcher.finished(this) &#125;&#125; 这块又调用了client.dispatcher，然后找回去找到OkHttpClient的dispatcher对象，发现他就是Dispatcher类的一个对象，接着我们继续看Dispatcher类。 2.1.2 Dispatcher任务调度进入Dispatcher类，我们可以看到如下成员变量定义: 注：kotlin中一个成员变量的@get和@set分别对应了Java中get和set方法，所以这块我没有完完全全复制粘贴到这，我只取了定义部分 123456789101112// 最大并发请求数var maxRequests = 64// 每个主机的最大请求数var maxRequestsPerHost = 5// 消费者线程val executorService: ExecutorService// 将要运行的异步请求队列private val readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()// 正在运行的异步请求队队列private val runningAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()// 正在运行的同步请求队列private val runningSyncCalls = ArrayDeque&lt;RealCall&gt;() 接下来我们看看Dispatcher的构造方法 123456// 主构造方法，没写具体实现class Dispatcher constructor() &#123;&#125; constructor(executorService: ExecutorService) : this() &#123; this.executorServiceOrNull = executorService&#125; 我们可以看到他将传进来的executorService传给了executorServiceOrNull，那我们来看看executorServiceOrNull的定义： 123456789101112// executorServiceOrNull这个应该是因为kotlin的空安全检查特性而定义的，本质上就是executorServiceprivate var executorServiceOrNull: ExecutorService? = null@get:Synchronized@get:JvmName("executorService") val executorService: ExecutorService get() &#123; if (executorServiceOrNull == null) &#123; executorServiceOrNull = ThreadPoolExecutor(0, Int.MAX_VALUE, 60, TimeUnit.SECONDS, SynchronousQueue(), threadFactory("OkHttp Dispatcher", false)) &#125; return executorServiceOrNull!! &#125; 我们可以看到executorService的set方法，就是创建了一个线程池。再结合他有两个构造器就知道：如果没有给Dispatcher传入一个线程池他就会自己创建一个线程池。这个线程池适合执行大量且耗时较少的任务。 构造器我们看完了，我们就来看他的enqueue()方法： 12345678910111213internal fun enqueue(call: AsyncCall) &#123; synchronized(this) &#123; readyAsyncCalls.add(call) // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to // the same host. if (!call.get().forWebSocket) &#123; val existingCall = findExistingCallWithHost(call.host()) if (existingCall != null)call.reuseCallsPerHostFrom(existingCall) &#125; &#125; promoteAndExecute()&#125; 来一个请求就把他添加到就绪请求队列中去，然后就来判断forWebSocket这个属性。看到这个属性我还迷了下，有点搞不懂她是干嘛的，然后经过我的一番搜索后，发现原来OkHttp还可以进行WebSocket通信，而这个属性就是为WebSocket通信准备的。于是我就到RealCall里面找在哪儿定义了这个属性了，然后我就发现了在RealCall的newRealCall()方法这块，这个方法传入的参数中有一个Boolean值名字就叫forWebSocket。 123456789101112companion object &#123; fun newRealCall( client: OkHttpClient, originalRequest: Request, forWebSocket: Boolean ): RealCall &#123; // Safely publish the Call instance to the EventListener. return RealCall(client, originalRequest, forWebSocket).apply &#123; transmitter = Transmitter(client, this) &#125; &#125;&#125; 不知道大家有没有印象，咱们在上面说过，执行OkHttpClient.newCall()方法实际上是返回了一个RealCall对象，于是在那找到了这个的答案，forWebSocket=false所以说这个if咱们不用管，直接看promoteAndExecute()方法： 12345678910111213141516171819202122232425262728293031private fun promoteAndExecute(): Boolean &#123; // 不知道大家还记不记得咱们之前说的kotlin里面的check()语法， // 这个和check也一样，只不过抛出的是AssertionError异常 assert(!Thread.holdsLock(this)) // mutableListOf是kotlin里面的可变list集合 val executableCalls = mutableListOf&lt;AsyncCall&gt;() val isRunning: Boolean synchronized(this) &#123; val i = readyAsyncCalls.iterator() while (i.hasNext()) &#123; val asyncCall = i.next() if (runningAsyncCalls.size &gt;= this.maxRequests) break // 最大容量 if (asyncCall.callsPerHost().get() &gt;= this.maxRequestsPerHost) continue // 主机最大容量 i.remove() asyncCall.callsPerHost().incrementAndGet() executableCalls.add(asyncCall) runningAsyncCalls.add(asyncCall) &#125; isRunning = runningCallsCount() &gt; 0 &#125; for (i in 0 until executableCalls.size) &#123; val asyncCall = executableCalls[i] asyncCall.executeOn(executorService) &#125; return isRunning&#125; 首先将已就绪队列遍历一遍，判断正在运行的数量是不是大于定义的最大请求数，如果大于的话直接退出循环；如果不大于则在判断这个请求的主机请求数是不是大于定义的每个主机最大请求数，如果大于就跳过这个请求换下一个请求；不大于就把它调入正在运行的请求队列里面，直到遍历完成。然后判断还有没有正在运行的请求，如果有就isRunning置true。接着再取出executableCalls里的每一个元素，然后执行executteOn()方法。我们继续来看AsyncCall的executeOn()方法： 1234567891011121314151617fun executeOn(executorService: ExecutorService) &#123; assert(!Thread.holdsLock(client.dispatcher)) var success = false try &#123; executorService.execute(this) success = true &#125; catch (e: RejectedExecutionException) &#123; val ioException = InterruptedIOException("executor rejected") ioException.initCause(e) transmitter.noMoreExchanges(ioException) responseCallback.onFailure(this@RealCall, ioException) &#125; finally &#123; if (!success) &#123; client.dispatcher.finished(this) // This call is no longer running! &#125; &#125;&#125; 这段代码就是在执行线程池中的线程，如果成功执行就将success置true，如果不成功，则抛异常并返回给responseCallback的onFailure()方法。并且如果没有成功执行也就是success为false，那么在finally中就会执行client.dispatcher.finished()方法: 1234internal fun finished(call: AsyncCall) &#123; call.callsPerHost().decrementAndGet() finished(runningAsyncCalls, call) &#125; 这个方法先将传入的AsyncCall的callsPerHost给减1，然后再调用了finished()方法，我们再来看这个finished()方法： 12345678910111213private fun &lt;T&gt; finished(calls: Deque&lt;T&gt;, call: T) &#123; val idleCallback: Runnable? synchronized(this) &#123; if (!calls.remove(call)) throw AssertionError("Call wasn't in-flight!") idleCallback = this.idleCallback &#125; val isRunning = promoteAndExecute() if (!isRunning &amp;&amp; idleCallback != null) &#123; idleCallback.run() &#125;&#125; 他讲此次请求从runningAsyncCalls中移除，然后执行了promoteAndExecute()方法，咱们在上面说过这个方法，他的返回值就是判断当前这个运行队列中还有没有请求，如果还有就返回true，没有就false。接着一个if，判断isRunning和idleCallback的，那么如果当前这个请求还没有执行的话，就调用run()方法执行当前请求。这样每个请求都执行完毕了。那我们再来看看他的run()方法： 1234567891011121314151617181920override fun run() &#123; threadName("OkHttp $&#123;redactedUrl()&#125;") &#123; var signalledCallback = false transmitter.timeoutEnter() try &#123; val response = getResponseWithInterceptorChain() signalledCallback = true responseCallback.onResponse(this@RealCall, response) &#125; catch (e: IOException) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, "Callback failure for $&#123;toLoggableString()&#125;", e) &#125; else &#123; responseCallback.onFailure(this@RealCall, e) &#125; &#125; finally &#123; client.dispatcher.finished(this) &#125; &#125;&#125; 这块调用了一个getResponseWithInterceptorChain()方法，并返回了response，并将它返回给了responseCallback.onResponse()方法。如果失败了就将结果返回给responseCallback.onFailure()方法。最后调用client.dispatcher.finished()方法。 2.1.3 Interceptor拦截器2.1.3.1 getResponseWithInterceptorChain()方法首先我们看看getResponseWithInterceptorChain()方法： 12345678910111213141516171819202122232425262728293031323334@Throws(IOException::class)fun getResponseWithInterceptorChain(): Response &#123; // Build a full stack of interceptors. val interceptors = mutableListOf&lt;Interceptor&gt;() interceptors += client.interceptors interceptors += RetryAndFollowUpInterceptor(client) interceptors += BridgeInterceptor(client.cookieJar) interceptors += CacheInterceptor(client.cache) interceptors += ConnectInterceptor if (!forWebSocket) &#123; interceptors += client.networkInterceptors &#125; interceptors += CallServerInterceptor(forWebSocket) val chain = RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this, client.connectTimeoutMillis, client.readTimeoutMillis, client.writeTimeoutMillis) var calledNoMoreExchanges = false try &#123; val response = chain.proceed(originalRequest) if (transmitter.isCanceled) &#123; response.closeQuietly() throw IOException("Canceled") &#125; return response &#125; catch (e: IOException) &#123; calledNoMoreExchanges = true throw transmitter.noMoreExchanges(e) as Throwable &#125; finally &#123; if (!calledNoMoreExchanges) &#123; transmitter.noMoreExchanges(null) &#125; &#125;&#125; 首先就创建了一大堆的连接器并添加到interceptors集合中。然后创建了一个RealInterceptorChain对象，并调用了他的proceed()方法，接着主要目的就是讲proceed()返回的response给返回去。那我们就来看看RealInterceptorChain的proceed()方法： 1234567891011121314151617181920212223242526272829303132333435363738override fun proceed(request: Request): Response &#123; return proceed(request, transmitter, exchange)&#125; @Throws(IOException::class)fun proceed(request: Request, transmitter: Transmitter, exchange: Exchange?): Response &#123; if (index &gt;= interceptors.size) throw AssertionError() calls++ // If we already have a stream, confirm that the incoming request will use it. check(this.exchange == null || this.exchange.connection()!!.supportsUrl(request.url)) &#123; "network interceptor $&#123;interceptors[index - 1]&#125; must retain the same host and port" &#125; // If we already have a stream, confirm that this is the only call to chain.proceed(). check(this.exchange == null || calls &lt;= 1) &#123; "network interceptor $&#123;interceptors[index - 1]&#125; must call proceed() exactly once" &#125; // Call the next interceptor in the chain. val next = RealInterceptorChain(interceptors, transmitter, exchange, index + 1, request, call, connectTimeout, readTimeout, writeTimeout) val interceptor = interceptors[index] @Suppress("USELESS_ELVIS") val response = interceptor.intercept(next) ?: throw NullPointerException( "interceptor $interceptor returned null") // Confirm that the next interceptor made its required call to chain.proceed(). check(exchange == null || index + 1 &gt;= interceptors.size || next.calls == 1) &#123; "network interceptor $interceptor must call proceed() exactly once" &#125; check(response.body != null) &#123; "interceptor $interceptor returned a response with no body" &#125; return response &#125; 首先就是一个index，index是RealInterceptorChain构造器中传入的参数，她是第四个参数，所以我们看getResponseWithInterceptorChain()方法中创建RealInterceptorChain对象时构造器的第四个传入的值为0。然后判断index的值是不是大于interceptors的大小，如果大于就抛异常，否则就继续一顿检查！！！然后再创建RealInterceptorChain对象，此时创建的对象传入的index为此时的index+1，然后再调用interceptor的intercept()方法，并返回response。 interceptor的intercept()作用是当存在多个拦截器时都会在上面代码注释1处阻塞，并等待下一个拦截器的调用返回。 2.1.3.2 Interceptor源码那现在我们再来讲几个重要的拦截器吧。OkHttp中Interceptor的实现类有： ConnectInterceptor：连接拦截器。 CallServerInterceptor：请求服务器拦截器 CacheInterceptor：缓存拦截器 BridgeInterceptor：桥梁拦截器。 其中较为重要的就是ConnectInterceptor和CallServerInterceptor，那我们来看看这两个。 2.1.3.2.1 ConnectInterceptor这个类主要用来实现网络请求连接。我们来看下他的intercept方法： 123456789101112@Throws(IOException::class)override fun intercept(chain: Interceptor.Chain): Response &#123; val realChain = chain as RealInterceptorChain val request = realChain.request() val transmitter = realChain.transmitter() // We need the network to satisfy this request. Possibly for validating a conditional GET. val doExtensiveHealthChecks = request.method != "GET" val exchange = transmitter.newExchange(chain, doExtensiveHealthChecks) return realChain.proceed(request, transmitter, exchange)&#125; 这个方法先将传入的chain对象造型成了RealInterceptorChain的对象，这个类我们在上面提到过，然后调用他的response()和transmitter()方法，分别得到当前chain的response和transmitter。然后执行了request的method()方法，判断request的类型是不是GET，如果是doExtensiveHealthChecks就为false，否则为true，接着把doExtensiveHealthChecks传入transmitter的newExchange()方法中去，这个方法我们等会再说，然后再调用了proceed()方法，这个方法我们在上面说过。 2.1.3.2.2 CallServerInterceptor这个类是网络请求的本质。它的intercept方法源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103@Throws(IOException::class) override fun intercept(chain: Interceptor.Chain): Response &#123; val realChain = chain as RealInterceptorChain val exchange = realChain.exchange() val request = realChain.request() val requestBody = request.body val sentRequestMillis = System.currentTimeMillis() // 写入请求头 exchange.writeRequestHeaders(request) var responseHeadersStarted = false var responseBuilder: Response.Builder? = null // 写入请求体信息 if (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody != null) &#123; // 如果请求上有“expect:100 continue”头 // 请等待“http/1.1 100 continue”响应，然后再传输请求主体. // 如果我们没有得到，返回我们得到的（例如4xx响应），而不传输请求体。 if ("100-continue".equals(request.header("Expect"), ignoreCase = true)) &#123; exchange.flushRequest() responseHeadersStarted = true exchange.responseHeadersStart() responseBuilder = exchange.readResponseHeaders(true) &#125; if (responseBuilder == null) &#123; if (requestBody.isDuplex()) &#123; // 准备一个双工主体，以便应用程序稍后可以发送请求主体。 exchange.flushRequest() val bufferedRequestBody = exchange.createRequestBody(request, true).buffer() requestBody.writeTo(bufferedRequestBody) &#125; else &#123; // 如果满足“expect:100 continue”预期，则编写请求正文。 val bufferedRequestBody = exchange.createRequestBody(request, false).buffer() requestBody.writeTo(bufferedRequestBody) bufferedRequestBody.close() &#125; &#125; else &#123; exchange.noRequestBody() if (!exchange.connection()!!.isMultiplexed) &#123; // 如果不满足“expect:100 continue”的要求，请防止重用HTTP/1连接。 // 否则，我们仍然有义务传输请求主体以使连接保持一致状态。 exchange.noNewExchangesOnConnection() &#125; &#125; &#125; else &#123; exchange.noRequestBody() &#125; // 结束请求 if (requestBody == null || !requestBody.isDuplex()) &#123; exchange.finishRequest() &#125; if (!responseHeadersStarted) &#123; exchange.responseHeadersStart() &#125; if (responseBuilder == null) &#123; responseBuilder = exchange.readResponseHeaders(false)!! &#125; // 读取响应头信息 var response = responseBuilder .request(request) .handshake(exchange.connection()!!.handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build() var code = response.code if (code == 100) &#123; // 服务器发送了一个100继续，即使我们没有请求。 // 再次尝试读取实际响应 response = exchange.readResponseHeaders(false)!! .request(request) .handshake(exchange.connection()!!.handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build() code = response.code &#125; exchange.responseHeadersEnd(response) // openResponseBody 获取响应体信息 response = if (forWebSocket &amp;&amp; code == 101) &#123; // 连接正在升级，但我们需要确保拦截器看到非空的响应主体。 response.newBuilder() .body(EMPTY_RESPONSE) .build() &#125; else &#123; response.newBuilder() .body(exchange.openResponseBody(response)) .build() &#125; if ("close".equals(response.request.header("Connection"), ignoreCase = true) || "close".equals(response.header("Connection"), ignoreCase = true)) &#123; exchange.noNewExchangesOnConnection() &#125; if ((code == 204 || code == 205) &amp;&amp; response.body?.contentLength() ?: -1L &gt; 0L) &#123; throw ProtocolException( "HTTP $code had non-zero Content-Length: $&#123;response.body?.contentLength()&#125;") &#125; //返回一个响应 return response&#125; 具体过程可以看代码中的注释，它主要是向服务器发送请求数据和接受服务器返回的数据。 2.1.4 TransmiterTransmitter类是OkHttp的应用层和网络层的一个桥梁类。 我们先来看看该类的初始化： 12345678910111213class Transmitter( private val client: OkHttpClient, private val call: Call) &#123; private val connectionPool: RealConnectionPool = client.connectionPool.delegate private val eventListener: EventListener = client.eventListenerFactory.create(call) private val timeout = object : AsyncTimeout() &#123; override fun timedOut() &#123; cancel() &#125; &#125;.apply &#123; timeout(client.callTimeoutMillis.toLong(), MILLISECONDS) &#125; Transmitter主要的一些成员变量就这些，首先构造器中传入了两个参数，一个OkHttpClient，一个Call。然后又创建了一个连接池connectionPool，还有一个监听器，我们可以通过扩展这个类来监听程序的HTTP的调用数量、大小和持续时间。 2.1.5 RealConnection我们先看看他的一些属性： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class RealConnection( val connectionPool: RealConnectionPool, private val route: Route) : Http2Connection.Listener(), Connection &#123; // 以下字段由connect（）初始化，从不重新分配。 // 底层socket private var rawSocket: Socket? = null /** * 应用层套接字。如果此连接不使用SSL，则可以是[sslsocket]分层在[rawsocket]上，也可以是[rawsocket]本身。 */ // 应用层socket private var socket: Socket? = null // 握手 private var handshake: Handshake? = null // 协议 private var protocol: Protocol? = null // http2的连接 private var http2Connection: Http2Connection? = null // 与服务器交互的输入输出流 private var source: BufferedSource? = null private var sink: BufferedSink? = null // 跟踪连接状态下的字段由连接池保护。 /** * 如果为true，则不能在此连接上创建新的交换。一旦是true的，这总是true的。 * 由[ConnectionPool]监视。 */ var noNewExchanges = false /** * 建立可能由于所选路由而导致的流时出现问题的次数。由[ConnectionPool]保护。 */ internal var routeFailureCount = 0 internal var successCount = 0 private var refusedStreamCount = 0 /** * 此连接可以承载的最大并发流数。 * 如果“allocations.size（）&lt;allocationlimit”，则可以在此连接上创建新流。 */ private var allocationLimit = 1 接下来我们看看他的connect()方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788fun connect( connectTimeout: Int, readTimeout: Int, writeTimeout: Int, pingIntervalMillis: Int, connectionRetryEnabled: Boolean, call: Call, eventListener: EventListener) &#123; check(protocol == null) &#123; "already connected" &#125; // 线路的选择 var routeException: RouteException? = null val connectionSpecs = route.address.connectionSpecs val connectionSpecSelector = ConnectionSpecSelector(connectionSpecs) if (route.address.sslSocketFactory == null) &#123; if (ConnectionSpec.CLEARTEXT !in connectionSpecs) &#123; throw RouteException(UnknownServiceException( "CLEARTEXT communication not enabled for client")) &#125; val host = route.address.url.host if (!Platform.get().isCleartextTrafficPermitted(host)) &#123; throw RouteException(UnknownServiceException( "CLEARTEXT communication to $host not permitted by network security policy")) &#125; &#125; else &#123; if (Protocol.H2_PRIOR_KNOWLEDGE in route.address.protocols) &#123; throw RouteException(UnknownServiceException( "H2_PRIOR_KNOWLEDGE cannot be used with HTTPS")) &#125; &#125; // 连接开始 while (true) &#123; try &#123; // 如果要求隧道模式，建立通道连接，通常不是这种 if (route.requiresTunnel()) &#123; connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener) if (rawSocket == null) &#123; // 我们无法连接隧道，但适当关闭了我们的资源。 break &#125; &#125; else &#123; // 一般都走这条逻辑了，实际上很简单就是socket的连接 connectSocket(connectTimeout, readTimeout, call, eventListener) &#125; // https的建立 establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener) eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol) break &#125; catch (e: IOException) &#123; socket?.closeQuietly() rawSocket?.closeQuietly() socket = null rawSocket = null source = null sink = null handshake = null protocol = null http2Connection = null eventListener.connectFailed(call, route.socketAddress, route.proxy, null, e) if (routeException == null) &#123; routeException = RouteException(e) &#125; else &#123; routeException.addConnectException(e) &#125; if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) &#123; throw routeException &#125; &#125; &#125; if (route.requiresTunnel() &amp;&amp; rawSocket == null) &#123; throw RouteException(ProtocolException( "Too many tunnel connections attempted: $MAX_TUNNEL_ATTEMPTS")) &#125; val http2Connection = this.http2Connection if (http2Connection != null) &#123; synchronized(connectionPool) &#123; allocationLimit = http2Connection.maxConcurrentStreams() &#125; &#125;&#125; 首先检查是否已经建立连接，如果已经建立就抛异常，没有的话就继续。接着就得到了ConnectionSpecs，然后根据他建立了一个connectionSpecSelector集合。接着判断是不是安全连接，也就是ssl连接，如果不是的话就判断了一些属性，先确定是不是明文然后再确定主机能不能接受明文操作。接着就开始连接，判断是不是要进行隧道通信，如果是就调用connectTunnel()建立隧道通信，如果不是就调用connectSocket()建立普通的通信。然后通过establishProtocol()建立协议。如果是HTTP/2就设置相关属性。 然后我们就来看看他具体如何实现的，先看看connectSocket()方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243@Throws(IOException::class)private fun connectSocket( connectTimeout: Int, readTimeout: Int, call: Call, eventListener: EventListener) &#123; val proxy = route.proxy val address = route.address // 根据代理类型选择socket类型是代理还是直连 val rawSocket = when (proxy.type()) &#123; Proxy.Type.DIRECT, Proxy.Type.HTTP -&gt; address.socketFactory.createSocket()!! else -&gt; Socket(proxy) &#125; this.rawSocket = rawSocket eventListener.connectStart(call, route.socketAddress, proxy) rawSocket.soTimeout = readTimeout try &#123; // 连接socket，之所以这样写是因为支持不同的平台 // 里面实际上是 socket.connect(address, connectTimeout); Platform.get().connectSocket(rawSocket, route.socketAddress, connectTimeout) &#125; catch (e: ConnectException) &#123; throw ConnectException("Failed to connect to $&#123;route.socketAddress&#125;").apply &#123; initCause(e) &#125; &#125; // 下面的Try/Catch块是一种避免Android 7.0崩溃的伪黑客方法 // More details: // https://github.com/square/okhttp/issues/3245 // https://android-review.googlesource.com/#/c/271775/ try &#123; // 得到输入／输出流 source = rawSocket.source().buffer() sink = rawSocket.sink().buffer() &#125; catch (npe: NullPointerException) &#123; if (npe.message == NPE_THROW_WITH_NULL) &#123; throw IOException(npe) &#125; &#125;&#125; 首先先判断连接类型，如果是直连或者HTTP连接就直连，否则的话走Socket代理，然后通过eventListener.connectStart()方法创建连接，再设定超时-&gt;完成连接-&gt;创建用于I/O的source和sink。 我们接着再来看connectTunnel()方法： 123456789101112131415161718192021222324@Throws(IOException::class)private fun connectTunnel( connectTimeout: Int, readTimeout: Int, writeTimeout: Int, call: Call, eventListener: EventListener) &#123; var tunnelRequest: Request = createTunnelRequest() val url = tunnelRequest.url for (i in 0 until MAX_TUNNEL_ATTEMPTS) &#123; connectSocket(connectTimeout, readTimeout, call, eventListener) tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url) ?: break // 已成功创建隧道。 // 代理决定在身份验证质询后关闭连接。 // 我们需要创建一个新的连接，但这次需要使用身份验证凭据。 rawSocket?.closeQuietly() rawSocket = null sink = null source = null eventListener.connectEnd(call, route.socketAddress, route.proxy, null) &#125;&#125; 大体就是先创建隧道请求，然后建立socket连接，再发送请求建立隧道。 3. 请求流程图那我们最后来总结下 3.1 同步请求是如何操作的？ 3.2 异步请求是如何操作的？]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
        <tag>源码</tag>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android网络请求2--解析Volley源码]]></title>
    <url>%2Fposts%2Fdf8fd75e.html</url>
    <content type="text"><![CDATA[本文大篇幅参考此篇文章，大家可以结合两篇文章看一下 1. Volley简介在很早以前，如果Android开发者想使用网络请求的话，必须自己通过HttpClient或者HttpURLConnection编写代码来访问。但是他两的用法还是很复杂的，如果不适当的封装的话，就会有很多多余代码甚至效率降低。所以当时出现了很多第三方网络通信框架，但是都是第三方的，而谷歌官方一直没有作为。最终在2013年，谷歌终于意识到了问题，于是他们推出了一个官方的全新的网络框架——Volley。Volley它又能非常简单的进行HTTP通信，又能轻松加载网络上的图片。他的设计目的就是应对数据量不大但是频发的网络操作，但是对于下载等需要大数据量的网络操作，他就不太适合。 2. 源码解析2.1 从RequestQueue入手如果你使用Volley的话，就会发现Volley不管进行什么操作，首先第一步就是先创建RequestQueue对象。所以我们就可以认定他为Volley的入口。创建RequestQueue的方法是RequestQueue mQueue = Volley.newRequestQueue(getApplicationContext());,我们就看看newRequestQueue干了什么： 1234567891011121314151617181920212223242526272829public static RequestQueue newRequestQueue(Context context, BaseHttpStack stack) &#123; BasicNetwork network; if (stack == null) &#123; if (Build.VERSION.SDK_INT &gt;= 9) &#123; network = new BasicNetwork(new HurlStack()); &#125; else &#123; // 在Android 2.3之前，HttpURLConnection是不可靠的。 // 请参阅：http://android-developers.blogspot.com/2011/09/androids-http-clients.html // 在将来的某个时候，我们将把minsdkversion移到Android 2.2之上， // 并可以删除这个回退（连同所有ApacheHTTP代码）。 String userAgent = "volley/0"; try &#123; String packageName = context.getPackageName(); PackageInfo info = context.getPackageManager().getPackageInfo(packageName, /* flags= */ 0); userAgent = packageName + "/" + info.versionCode; &#125; catch (NameNotFoundException e) &#123; &#125; network = new BasicNetwork( new HttpClientStack(AndroidHttpClient.newInstance(userAgent))); &#125; &#125; else &#123; network = new BasicNetwork(stack); &#125; return newRequestQueue(context, network);&#125; 调用方法后，先查看Android版本是否大于等于2.3，如果大于则调用基于HttpURLConnection的HurlStack，否则调用基于HttpClient的HttpClientStack。接下来创建BasicNetwork并调用newRequestQueue(context, network)方，我们再来看看这个newRequestQueue()方法： 1234567891011121314151617181920private static RequestQueue newRequestQueue(Context context, Network network) &#123; final Context appContext = context.getApplicationContext(); // 对缓存目录使用惰性供应商，以便可以在主线程上调用newRequestQueue（）， // 而不会导致严格的模式冲突。 DiskBasedCache.FileSupplier cacheSupplier = new DiskBasedCache.FileSupplier() &#123; private File cacheDir = null; @Override public File get() &#123; if (cacheDir == null) &#123; cacheDir = new File(appContext.getCacheDir(), DEFAULT_CACHE_DIR); &#125; return cacheDir; &#125; &#125;; RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheSupplier), network); queue.start(); return queue;&#125; 可以看到，这个方法主要为Volley创建了一个硬盘缓存DiskBasedCache，然后通过这个磁盘缓存和Network创建了一个RequestQueue对象，并调用了start()方法，接下来我们看下start()方法: 123456789101112131415public void start() &#123; stop(); // 确保当前运行的所有调度程序都已停止。 // 创建缓存调度器并开始它。 mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery); mCacheDispatcher.start(); // 创建达到池大小的网络调度程序（和相应的线程）。 for (int i = 0; i &lt; mDispatchers.length; i++) &#123; NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery); mDispatchers[i] = networkDispatcher; networkDispatcher.start(); &#125;&#125; CacheDispatcher是一个缓存调度线程，并调用了start()方法。在循环中调用NetworkDispatcher的start()方法。NetworkDispatcher是网络调度线程，默认情况下mDispatchers.length为4，默认开启了4个调度线程，外加1个缓存调度线程，总共5个线程。接下来Volley会创建各种Request，并调用RequestQueue的add()方法： 123456789101112131415161718192021public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) &#123; // 将请求标记为属于此队列，并将其添加到当前请求集。 request.setRequestQueue(this); synchronized (mCurrentRequests) &#123; //mCurrentRequests是一个HashSet mCurrentRequests.add(request); &#125; // 按添加的顺序处理请求。 request.setSequence(getSequenceNumber()); request.addMarker("add-to-queue"); sendRequestEvent(request, RequestEvent.REQUEST_QUEUED); // 如果请求是不可执行的，跳过缓存队列，然后直接进入网络。 if (!request.shouldCache()) &#123; mNetworkQueue.add(request); return request; &#125; mCacheQueue.add(request); return request;&#125; 这块地方的代码就很简单了，就是根据request的shouldCache()方法来返回request的mShouldCache属性来判断是否可以缓存，默认是可以的。如果能缓存，将此请求加入mCacheQueue队列，不再重复请求；不可以的话就将请求加入网络请求队列mNetworkQueue。 2.2 CacheDispatcher缓存调度线程RequestQueue的add()方法并没有请求网络或者对缓存进行操作。当将请求添加到网络请求队 列或者缓存队列时，在后台的网络调度线程和缓存调度线程轮询各自的请求队列，若发现有请求任务则开 始执行。下面先看看缓存调度线程。 首先先来看看CacheDispatcher的add()方法： 123456789101112131415161718192021222324252627@Overridepublic void run() &#123; if (DEBUG) VolleyLog.v("start new dispatcher"); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); // Process.THREAD_PRIORITY_BACKGROUND默认值为10 // 进行阻塞调用以初始化缓存。 mCache.initialize(); while (true) &#123; try &#123; processRequest(); &#125; catch (InterruptedException e) &#123; // 可能被打断了，因为是时候要退出了。 if (mQuit) &#123; Thread.currentThread().interrupt(); return; &#125; VolleyLog.e( "Ignoring spurious interrupt of CacheDispatcher thread; " + "use quit() to terminate it"); // 忽略cachedispatcher线程的假中断； // 使用quit（）终止它 &#125; &#125;&#125; 这块可以看出主要就是初始化了缓存队列，然后开了个死循环，一直调用processRequest()，我们来看看这个方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182private void processRequest() throws InterruptedException &#123; // 从CacheQueue中取出一个可用的request final Request&lt;?&gt; request = mCacheQueue.take(); processRequest(request);&#125;@VisibleForTestingvoid processRequest(final Request&lt;?&gt; request) throws InterruptedException &#123; request.addMarker("cache-queue-take"); request.sendEvent(RequestQueue.RequestEvent.REQUEST_CACHE_LOOKUP_STARTED); try &#123; //request如果被取消了，就直接返回 if (request.isCanceled()) &#123; request.finish("cache-discard-canceled"); return; &#125; Cache.Entry entry = mCache.get(request.getCacheKey()); // 没有缓存就把request添加到NetworkQueue中 if (entry == null) &#123; request.addMarker("cache-miss"); // 没有缓存，并且等待队列中也没有此request，那么就直接加入到NetworkQueue中 if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123; mNetworkQueue.put(request); &#125; return; &#125; // 如果缓存过期了，也是一样把request添加到NetworkQueue中 if (entry.isExpired()) &#123; request.addMarker("cache-hit-expired"); request.setCacheEntry(entry); if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123; mNetworkQueue.put(request); &#125; return; &#125; // 有缓存并且没有过期 request.addMarker("cache-hit"); // 根据缓存的内容解析 Response&lt;?&gt; response = request.parseNetworkResponse( new NetworkResponse(entry.data, entry.responseHeaders)); request.addMarker("cache-hit-parsed"); // 是否需要更新 if (!entry.refreshNeeded()) &#123; // 不需要更新，直接将结果调度到主线程 mDelivery.postResponse(request, response); &#125; else &#123; request.addMarker("cache-hit-refresh-needed"); request.setCacheEntry(entry); response.intermediate = true; // 判断是否有相同缓存键的任务在执行 if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123; // 需要更新结果，先将结果调度到主线程，然后执行new runnable()&#123;&#125; // runnable中就是将request添加到NetworkQueue中，更新一下内容 mDelivery.postResponse( request, response, new Runnable() &#123; @Override public void run() &#123; try &#123; mNetworkQueue.put(request); &#125; catch (InterruptedException e) &#123; // Restore the interrupted status Thread.currentThread().interrupt(); &#125; &#125; &#125;); &#125; else &#123; // request已经加入到mWaitingRequests中 // 直接把结果调度到主线程 mDelivery.postResponse(request, response); &#125; &#125; &#125; finally &#123; request.sendEvent(RequestQueue.RequestEvent.REQUEST_CACHE_LOOKUP_FINISHED); &#125;&#125; 我们在processRequest中可以看到有一个方法经常出现，那就是mWaitingRequestManager.maybeAddToWaitingRequests(request)，它的作用是判断当前这个request是否有存在相同缓存键的请求已经处于运行状态，如果有，那么就将这个request加入到一个等待队列中，等到相同缓存键的请求完成。 总结一下CacheDispatcher主要步骤： 从CacheQueue中循环取出request； 如果缓存丢失，加入到NetworkQueue中； 如果缓存过期，加入到NetworkQueue中； 将缓存中的数据解析成Response对象； 如果不需要更新，直接将结果回调到主线程，回调操作等介绍完NetworkDispatcher之后一起深入剖析； 如果需要更新，先将结果回调到主线程，然后再将request加入到NetworkQueue中。 下面来看看网络调度线程。 2.3 NetWorkDispatcher网络调度线程NetworkDispatcher的run方法代码如下所示: 123456789101112131415161718@Overridepublic void run() &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); while (true) &#123; try &#123; processRequest(); &#125; catch (InterruptedException e) &#123; // 我们可能被打断了，因为是时候退出了。 if (mQuit) &#123; Thread.currentThread().interrupt(); return; &#125; VolleyLog.e( "Ignoring spurious interrupt of NetworkDispatcher thread; " + "use quit() to terminate it"); &#125; &#125;&#125; 由此可以看出，NetWordDispatch和CacheDispatch非常类似。他的run()方法和CacheDispatch的方法基本一样，这就不多做介绍，下面来看看他的processRequest()方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private void processRequest() throws InterruptedException &#123; // 从NetworkQueue中取出request Request&lt;?&gt; request = mQueue.take(); processRequest(request);&#125;@VisibleForTestingvoid processRequest(Request&lt;?&gt; request) &#123; long startTimeMs = SystemClock.elapsedRealtime(); request.sendEvent(RequestQueue.RequestEvent.REQUEST_NETWORK_DISPATCH_STARTED); try &#123; request.addMarker("network-queue-take"); // 如果request被取消了，那么就不执行此request if (request.isCanceled()) &#123; request.finish("network-discard-cancelled"); request.notifyListenerResponseNotUsable(); return; &#125; addTrafficStatsTag(request); // 还记得这个mNetwork么，它就是Volley.newRequestQueue()方法里的BasicNetwork对象，一会我们来看看mNetwork.performRequest()方法是如何得到NetworkResponse的 NetworkResponse networkResponse = mNetwork.performRequest(request); request.addMarker("network-http-complete"); // notModified是服务端返回304，hasHadResponseDelivered()是request已经回调过了 if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123; request.finish("not-modified"); request.notifyListenerResponseNotUsable(); return; &#125; // 将NetworkResponse解析成Response对象，在子线程中执行 Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse); request.addMarker("network-parse-complete"); // 将request写入缓存 if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123; mCache.put(request.getCacheKey(), response.cacheEntry); request.addMarker("network-cache-written"); &#125; request.markDelivered(); // 回调结果至主线程 mDelivery.postResponse(request, response); request.notifyListenerResponseReceived(response); &#125; // 以下都是处理异常错误，然后也需要回调至主线程 catch (VolleyError volleyError) &#123; volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs); parseAndDeliverNetworkError(request, volleyError); request.notifyListenerResponseNotUsable(); &#125; catch (Exception e) &#123; VolleyLog.e(e, "Unhandled exception %s", e.toString()); VolleyError volleyError = new VolleyError(e); volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs); mDelivery.postError(request, volleyError); request.notifyListenerResponseNotUsable(); &#125; finally &#123; request.sendEvent(RequestQueue.RequestEvent.REQUEST_NETWORK_DISPATCH_FINISHED); &#125;&#125; 通过NetworkDispatcher.processRequest()方法可以发现，主要分为以下几步： 通过BasicNetwork.performRequest(request)得到NetworkResponse对象； 通过request.parseNetworkResponse(networkResponse)解析得到Response对象； 通过mDelivery将成功结果或者失败结果回调到主线程。 现在我们依次来分析这三步： 请求网络，得到NetworkResponse 我们看看BasicNetwork的performRequest()方法： 123456789101112131415161718192021222324252627@Overridepublic NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123; long requestStart = SystemClock.elapsedRealtime(); while (true) &#123; HttpResponse httpResponse = null; byte[] responseContents = null; List&lt;Header&gt; responseHeaders = Collections.emptyList(); try &#123; // Gather headers. Map&lt;String, String&gt; additionalRequestHeaders = getCacheHeaders(request.getCacheEntry()); httpResponse = mBaseHttpStack.executeRequest(request, additionalRequestHeaders); int statusCode = httpResponse.getStatusCode(); responseHeaders = httpResponse.getHeaders(); // Handle cache validation. if (statusCode == HttpURLConnection.HTTP_NOT_MODIFIED) &#123; Entry entry = request.getCacheEntry(); if (entry == null) &#123; return new NetworkResponse( HttpURLConnection.HTTP_NOT_MODIFIED, /* data= */ null, /* notModified= */ true, SystemClock.elapsedRealtime() - requestStart, responseHeaders); &#125; …………省略 通过上面源码可以看出，BasicNetwork就是封装了一下NetworkResponse，并没有涉及到网络请求，我们继续深入到BaseHttpStack.executeRequest(request, additionalRequestHeaders)源码中。 123public abstract HttpResponse executeRequest( Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders) throws IOException, AuthFailureError; 这时发现这个BaseHttpStack就是一个抽象类，而这个executeRequest()也就是一个抽象方法。我当时就卡在这了，调用了一个抽象类的抽象方法，这咋操作嘛。然后我就好好再看了一遍，找到BasicNetwork的构造函数中对mBaseHttpStck定义的地方，发现这个是构造函数传进来的，然后就想到了在调用Volley.newRequestQueue()时，是根据Android版本传入了不同的Stack，那我们就来看看HurlStack.executeRequest()方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overridepublic HttpResponse executeRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders) throws IOException, AuthFailureError &#123; String url = request.getUrl(); HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.putAll(additionalHeaders); // request.getheaders（）优先于给定的附加（缓存）头. map.putAll(request.getHeaders()); if (mUrlRewriter != null) &#123; String rewritten = mUrlRewriter.rewriteUrl(url); if (rewritten == null) &#123; throw new IOException("URL blocked by rewriter: " + url); &#125; url = rewritten; &#125; URL parsedUrl = new URL(url); HttpURLConnection connection = openConnection(parsedUrl, request); boolean keepConnectionOpen = false; try &#123; for (String headerName : map.keySet()) &#123; connection.setRequestProperty(headerName, map.get(headerName)); &#125; setConnectionParametersForRequest(connection, request); // 使用来自httpurlConnection的数据初始化httpResponse。 int responseCode = connection.getResponseCode(); if (responseCode == -1) &#123; // 如果无法检索响应代码，getResponseCode（）将返回-1。 // 向呼叫者发出信号，说明连接有问题。 throw new IOException("Could not retrieve response code from HttpUrlConnection."); &#125; if (!hasResponseBody(request.getMethod(), responseCode)) &#123; return new HttpResponse(responseCode, convertHeaders(connection.getHeaderFields())); &#125; // 需要保持连接打开，直到调用方使用流。包装流，以便close（）将断开连接。 keepConnectionOpen = true; return new HttpResponse( responseCode, convertHeaders(connection.getHeaderFields()), connection.getContentLength(), new UrlConnectionInputStream(connection)); &#125; finally &#123; if (!keepConnectionOpen) &#123; connection.disconnect(); &#125; &#125;&#125; 可以看到，主要就是借助了HttpURLConnection对象来请求网络，并根据不同的条件返回不同的HttpResponse对象。 解析NetworkResponse, 得到Response： 解析过程是定义在Request类中，但是他是一个抽象类，不同的Request都有自己的实现，我们现在就以JsonRequest为例看看：然后发现他又是一个抽象类，那我们就看看JsonRequest其中一个实现类JsonObjectRequest的parseNetworkResponse()方法： 123456789101112131415@Overrideprotected Response&lt;JSONObject&gt; parseNetworkResponse(NetworkResponse response) &#123; try &#123; String jsonString = new String( response.data, HttpHeaderParser.parseCharset(response.headers, PROTOCOL_CHARSET)); return Response.success( new JSONObject(jsonString), HttpHeaderParser.parseCacheHeaders(response)); &#125; catch (UnsupportedEncodingException e) &#123; return Response.error(new ParseError(e)); &#125; catch (JSONException je) &#123; return Response.error(new ParseError(je)); &#125;&#125; 这个就不用多说了，根据返回来的response建了一个String然后把这个String放到Response里面去然后再返回去。 回调主线程回调主要是通过Delivery的postResponse()方法实现的，我们来看看这个方法,找过去又找到了一个ResponseDelivery抽象类，然后又得找他的实现类，这时大家应该记得RequestQueue()的时候初始化了一个Delivery： 1234567public RequestQueue(Cache cache, Network network, int threadPoolSize) &#123; this( cache, network, threadPoolSize, new ExecutorDelivery(new Handler(Looper.getMainLooper())));&#125; 他返回了一个ExecutorDelivery，我们来看看这个类，然后就惊喜的发现，我们终于找到我们需要的东西了： 123456789101112131415/** * Creates a new response delivery interface. * * @param handler &#123;@link Handler&#125; to post responses on */public ExecutorDelivery(final Handler handler) &#123; // Make an Executor that just wraps the handler. mResponsePoster = new Executor() &#123; @Override public void execute(Runnable command) &#123; handler.post(command); &#125; &#125;;&#125; 知道了它的初始化，我们再来看看它是如何实现回调的： Volley中回调是通过postResponse()方法的 : 12345678910public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response) &#123; postResponse(request, response, null);&#125;@Overridepublic void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) &#123; request.markDelivered(); request.addMarker("post-response"); mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));&#125; postResponse()最终会调用mResponsePoster对象的execute()方法，传入了一个ResponseDeliveryRunnable对象，它实现了Runnable接口，execute()方法会通过Handler.post(runnable)将ResponseDeliveryRunnable放入消息队列。最后我们来看看这个ResponseDeliveryRunnable的run()方法在主线程中做了什么操作： 12345678910111213141516171819202122232425262728293031@SuppressWarnings("unchecked")@Overridepublic void run() &#123; // If this request has canceled, finish it and don't deliver. if (mRequest.isCanceled()) &#123; mRequest.finish("canceled-at-delivery"); return; &#125; if (mResponse.isSuccess()) &#123; // 执行成功的回调，在具体的Request实现类中，比如StringRequest就会调用listener.onResponse(string)回调 mRequest.deliverResponse(mResponse.result); &#125; else &#123; // 执行失败的回调，在request中，直接回调了listener.onErrorResponse(error) mRequest.deliverError(mResponse.error); &#125; // intermediate默认为false，但是在CacheDispatcher的run()中，如果需要更新缓存，那么就会置为true if (mResponse.intermediate) &#123; mRequest.addMarker("intermediate-response"); &#125; else &#123; mRequest.finish("done"); &#125; // 如果传入了runnable不为空，那就就执行runnable.run()方法 // 回忆下在CacheDispatcher的run()方法中，如果request有缓存，但是需要更新缓存的时候，mDelivery是不是调用的带runnable的方法 if (mRunnable != null) &#123; mRunnable.run(); &#125;&#125; 3 请求流程图最后附上Volley的请求流程图]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
        <tag>Volley</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统2--进程的描述和控制]]></title>
    <url>%2Fposts%2F2e847144.html</url>
    <content type="text"><![CDATA[大家可以看下我使用幕布软件画的思维导图，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员https://mubu.com/inv/477598 [TOC] 2.1 进程的描述2.1.1 进程的定义和特征2.1.1.1 进程的定义为了能够使程序并发执行，并且可以对并发执行的程序加以描述和控制，人们引入了“进程”的概念。为了使参与并发执行的每个程序都能独立地运行，操作系统必须为之配置一个专门的数据结构，称为进程数据块（PCB）。他用来纪录进程的各种属性，描述进程的动态变化过程。主要包含有进程的描述信息（进程标识符，进程名，用户标识符，进程组关系等）、进程控制信息（当前状态，优先级，代码执行入口地址，保存的磁盘地址等等）、所拥有的资源和使用情况（虚拟地址空间的状态，文件打开列表等）和CPU现场信息等内容。PCB是系统感知进程存在的唯一标志。所以一般情况下，我们把进程实体就简称为进程，创建进程，实质上是创建进程实体中的PCB；撤销进程，实质上是撤销进程的PCB。对于进程的定义，比较典型的有： 进程是程序的一次执行 进程是一个程序及其数据在处理机上顺序执行时所发生的活动 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位 2.1.1.2 进程的特征 结构性进程实体是由程序段、数据段及进程控制快三部分组成。 动态性进程的实质是进程实体的执行过程，而且进程“由创建而产生，由调度而执行，由撤销而消亡”。 并发性多个进程实体同存于内存中，且能在一段时间内同时运行。 独立性进程实体是一个能独立运行、独立获得资源和独立接收调度的基本单位。 异步性进程是按异步方式运行的。 2.1.2 进程的基本状态及转换2.1.2.1 进程的三种基本状态进程主要分为三种基本状态： 运行态指进程已经获得了CPU，他正在CPU上执行。 就绪态指进程已经准备就绪，准备好了被CPU执行的状态。如果系统中有很多处于就绪态的进程，通常把他们按一定的策略排成一个队列，这个队列称为就绪队列。 等待态指正在运行的进程由于发生某事件（如I/O请求、申请缓冲区失败等问题）暂时无法继续执行时的状态。此时引起进程调度，OS把处理机分配给就绪中的进程，让受阻的进程处于阻塞状态。 2.1.2.2 三种状态的转换 2.1.2.3 创建状态和终止状态为了满足进程控制块对数据及操作的完整性要求以及增强管理的灵活性，通常在系统中又为进程引入了两种常见的状态：创建状态和终止状态。 2.1.3 进程管理中的数据结构在最开始我已经经提到了进程控制块PCB这个东西，现在我们就进一步来了解他。 2.1.3.1 进程控制块中的作用PCB的作用主要就是使一个在多道程序环境下不能独立运行的程序称为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。 作为独立运行基本单位的标志。 当一个程序配置了PCB之后，就表示他已是一个能在多道程序环境下独立运行的、合法的基本单位，也就具有取得OS服务的权利。当系统创建一个新的进程的时候，就为他创建了一个PCB，进程结束后收回PCB。 能实现间断性运行方式。 在多道程序运行环境下，由于存在时间片或者有等待I/O请求的情况，所以进程一般都是出于走走停停的状态，当一个进程被阻塞的时候，他应该有一种能保存当前运行状态的能力也就是保护现场机制，方便在此被调度执行时恢复阻塞前的状态。所以就需要在PCB里面提供一个数据结构来保存该进程被中断时的一些信息。 提供进程管理所需要的信息。 这个就不用多说吧。 提供进程调度所需要的信息。 只有处于就绪状态的进程才能被调度执行，而在PCB中就提供了进程处于何种状态的信息。 实现与其它进程的同步与通信。 2.1.3.2 进程控制块中的信息根据上面进程控制块作用的描述，对应的进程控制块中就需要包含以下信息。 进程标识符 进程标识符用于唯一地标识一个进程。一个进程通常具有两种标识符： 外部标识符 为了方便用户（进程）对进程的访问，进程需要提供一个用于用户（进程）访问的标识符。 内部标识符 为了方便系统对进程的使用，在OS中又为进程设置了内部标识符。通常是一个进程的序号。 处理机状态 处理机状态信息也称为处理机的上下文，主要是由处理机的各种寄存器中的内容组成的。这些寄存器信息包括通用寄存器、指令寄存器、程序状态字PSW和用户栈指针。 进程调度信息 在OS进行调度的时候，必须了解进程的状态及有关进程调度的信息，这些信息包括：进程状态、进程优先级、进程调度所需其他信息（与所采用的的调度算法有关）和事件（阻塞原因）。 进程控制信息 用于进程控制所必须的信息，包括：程序和数据的地址、进程同步和通信机制、资源清单和链接指针。 2.1.3.3 进程控制块的组织方式一个系统中有很多个PCB，为了对他们进行有效的管理，应该用适当的方式将这些PCB组织起来，常用的组织方式有三种 线性方式直接将所有PCB放在一张线性表中，优点是简单，开销小，但是每次查找起来很麻烦。 链接方式把具有相同状态的PCB分别通过PCB中的链接字链接成一个队列。 索引方式根据所有进程状态的不同建立几张索引表，并把个索引表在内存的首地址纪录在内存的一些专用单元中。 2.2 进程控制2.2.1 进程的层次结构在OS中，允许一个进程创建另一个进程，通常把创建进程的进程称为父进程，被创建的进程称为子进程。然后子进程可以作为父进程继续去创建子进程，进而形成一个进程家族。 2.2.2 进程的创建每当出现了创建新进程的请求后，OS便调用进程创建原语Creat按下述步骤创建新进程： 申请空白PCB，为新进程申请获得唯一的数字标识符，并从PCB集合中索取一个空白PCB。 为新进程分配其运行所需的资源，包括各种物理和逻辑资源。 初始化进程控制块PCB。 如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。 2.2.3 进程的终止 根据被终止进程的标识符，从PCB集合中检索出进程的PCB，从中读出该进程的状态。 若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志位真，用于指示该进程被终止后应重新进行调度。 若该进程还有子孙进程，还应将其所有子孙进程也都予以终止，以防它们称为不可控的进程。 将被终止进程所拥有的的全部资源或者归还给其父进程，或者归还给系统。 将被终止进程（PCB）从所在队列（或链表）中移出，等待其他程序来搜集信息。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统1--操作系统概述]]></title>
    <url>%2Fposts%2F62248b34.html</url>
    <content type="text"><![CDATA[大家可以看下我使用幕布软件画的思维导图，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员https://mubu.com/inv/477598 现如今主流的操作系统1.1.1 PC1.1.1.1 WindowsMicrosoft Windows是微软公司推出的一系列操作系统。其问世时间为1985年，起初为运行于MS-DOS之下的桌面环境，其后续版本逐渐发展成为主要为个人计算机和服务器用户设计的操作系统，并最终获得了世界个人计算机操作系统的垄断地位。此操作系统可以在几种不同类型的平台上运行，如个人计算机、移动设备、服务器和嵌入式系统等等，其中在个人计算机的领域应用内最为普遍。Windows操作系统当前最新的稳定版是于2015年7月29日发布的 Windows 10。Windows Server当前最新的稳定版是2018年10月2日发布的Windows Server 2019。Windows Phone当前最新的稳定版是Windows10 Mobile，但是已停止开发新版本，仅对现有版本进行安全补丁和维护，直到2019年12月。 1.1.1.2 macOSmacOS（2011年及之前称Mac OS X，2012年至2015年称OS X）是苹果公司推出的基于图形用户界面操作系统，为麦金塔（Macintosh）的主操作系统。StatCounter在2018年8月的数据表示，在桌面操作系统中，macOS的使用份额为12.65%，次于Windows的82.51%位居第二。macOS当前最新的稳定版是2018年9月25日发布的macOS 10.14 Mojave，2019年6月4日推出macOS 10.15 Catalina的第一个测试版本。 1.1.1.3 LinuxLinux是一种自由和开放源码的类UNIX 操作系统。该操作系统的内核由林纳斯·托瓦兹在1991年10月5日首次发布，在加上用户空间的应用程序之后，成为 Linux 操作系统。Linux也是自由软件和开放源代码软件发展中最著名的例子。只要遵循 GNU 通用公共许可证（GPL），任何个人和机构都可以自由地使用 Linux 的所有底层源代码，也可以自由地修改和再发布。大多数 Linux 系统还包括像提供 GUI 的 X Window 之类的程序。除了一部分专家之外，大多数人都是直接使用 Linux 发行版，而不是自己选择每一样组件或自行设置。 1.1.1.4 UnixUNIX操作系统（尤尼斯），是一个强大的多用户、多任务操作系统，支持多种处理器架构，按照操作系统的分类，属于分时操作系统，最早由KenThompson、Dennis Ritchie和Douglas McIlroy于1969年在AT&amp;T的贝尔实验室开发。它的商标权由国际开放标准组织所拥有，只有符合单一UNIX规范的UNIX系统才能使用UNIX这个名称，否则只能称为类UNIX（UNIX-like）。 1.1.2 移动端1.1.2.1 AndroidAndroid，常见的非官方中文名称为安卓，是一个基于Linux内核的开放源代码移动操作系统，由Google成立的Open Handset Alliance持续领导与开发，主要设计用于触摸屏移动设备如智能手机和平板电脑与其他便携式设备。Android Inc.于2003年10月由安迪·鲁宾、利奇·米纳尔、尼克·席尔斯、克里斯·怀特在加州帕罗奥图创建。Android最初由安迪·鲁宾等人开发制作，最初开发这个系统的早期方向是创建一个数字相机的先进操作系统，但是后来发现市场需求不够大，加上智能手机市场快速成长，于是Android成为一款面向智能手机的操作系统。于2005年7月11日Android Inc.被美国科技企业Google收购。2017年3月，Android全球网络流量和设备超越Microsoft Windows，正式成为全球第一大操作系统。 1.1.2.2 iOSiOS（原名为iPhone OS）是苹果公司为其移动设备所开发的专有移动操作系统，为其公司的许多移动设备提供操作界面，支持设备包括iPhone、iPad和iPod touch。iPhone OS自iOS 4起便改名为iOS，它是继Android后全球第二大最受欢迎的移动操作系统，市占率已上升至约24.5% ，但仍远低于Google开发的Android系统的72.2%。 1.2 操作系统的简介与作用1.2.1 操作系统的简介操作系统是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。主要作用是对管理好计算机硬件设备，提高他们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单接口，便于用户使用。 1.2.2 操作系统的目的 方便性 如果一个计算机没有OS，那么他会非常难用。用户不管进行啥操作都得通过机器语言编写程序然后运行，而如果有OS的话，用户就可以使用各种各样的语言编写程序，然后通过编译将高级语言编译成机器代码，方便了用户。 有效性 有效性分两层含义——提高系统资源的利用率和提高系统的吞吐量。早期没有OS的计算机中，处理机和I/O设备等经常处于空闲状态，各种资源不能得到合理利用，所以提高系统资源利用率是推动OS发展的主要动力。另一方面，OS可以通过合理组织计算机的工作流程，加速程序的运行，缩短程序的运行周期，从而提高系统的吞吐量。 可扩充性 为了适应现在越来越多的计算机硬件以及体系结构，OS必修有良好的可扩充性。 开放性 OS需要遵循世界标准规范，凡遵循国际标准所开发的硬件和软件都能彼此兼容，方便地实现互联。 1.2.3 操作系统的作用 OS作为用户与计算机硬件系统之间的接口 OS处于用户和硬件之间，方便用户通过OS使用硬件。或者说，用户在OS的帮助下能够方便、快捷、可靠地操纵计算机硬件和运行自己的程序。 OS作为计算机系统资源的管理者 计算机系统资源主要可分为处理机、存储器、I/O设备以及文件。OS主要功能也就是对这四类资源进行有效的管理。处理机管理是用于分配和控制处理机；存储器管理主要负责内存的分配与回收；I/O设备管理是负责I/O设备的分配与操纵；文件管理是用于实现对文件的存取、共享和保护。 OS实现了对计算机资源的抽象 在裸机中，用户如果想要对计算器进行操作，必须对物理接口的实现细节有充分的了解。但在操作系统中，用户并不需要关心具体的物理，而由操作系统来实现具体的操作细节，并向上讲操作设备抽象为一组数据结构以及一组操作命令。此时在用户眼里，看到的是一台比裸机功能更强，使用更方便的机器。 1.2.4 推动操作系统发展的主要动力 不断提高计算机资源利用率 方便用户 器件的不断更新换代 计算机体系结构的不断发展 不断提出新的应用需求 1.3 操作系统的发展1.3.1 单道批处理系统在说单道批处理之前现要引入一个概念——作业。作业包括用户程序、数据、作业说明书。这样每一个处理对象都是作业。 1. 处理过程每个单道批处理系统都有一个系统操作员。用户先将作业交给系统操作员，然后操作系统操作员就将一个个作业组成一批作业，输入到计算机中，在系统中形成一个自动转接的作业流，然后启动操作系统对作业自动、依次的处理，处理完成后再将处理结果返回给系统操作员，操作员在返回给用户。这样就形成了一个单道批处理过程。 2. 缺点系统资源得不到充分利用。这是因为在内存中仅有一道程序，每逢程序在运行中发出I/O请求后，CPU便处于等待状态，必须在I/O完成后才继续运行。 1.3.2 多道批处理系统1. 处理过程在该系统中，用户所提交的作业先放在外存中，并排成一个队列，称为“后备队列“。然后由作业调度程序按一定的算法，从后备队列中选择若干作业调入内存。由于同时在内存中装有若干道程序，这样便可以在运行程序A时，利用其I/O操作暂停执行时的CPU空档期，再调度另一道程序B运行。 2. 优缺点 优点 资源利用率高 系统吞吐量大 缺点 平均周转时间长 无交互能力 1.3.3 分时系统1. 运行方式 作业直接进入内存。因为作业在磁盘上不可运行，所以作业应直接进入内存 采用轮转运行方式。如果一个作业独占CPU连续运行，那么其他作业没法运行。为了避免这种情况，引入了时间片概念。一个时间片是一个很短的时间，系统规定了每个作业每次只能运行一个时间片，然后就暂停该作业的运行，并立即调度下一个作业运行。如果在不长的时间内能使所有的作业都执行一个时间片的时间，便可以使每个用户都能及时地与自己的作业进行交互，从而使用户的请求的到及时响应。 2. 特征 多路性 独立性 及时性 交互性 1.3.4 实时系统实时系统是指系统能及时响应外部事件的请求，在规定时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。实时系统主要应用于： 工业（武器）控制系统 信息查询系统 多媒体系统 嵌入式系统 1.4 操作系统的基本特征1.4.1 并发正是系统中有这一特征，才使得OS能有效地提高系统中的资源利用率，增加系统的吞吐量。 并发与并行并行是指两个或多个事件在同一时刻发生，微观上是同一时刻多个线程在CPU上运行。并发是指宏观上两个或多个事件在同一时间发生，微观上缺是某一时刻CPU上只有一个进程。 1.4.2 共享资源共享，即操作系统中的资源可供多个并发执行的进程共同使用，由于资源属性不同，多个进程对资源的共享方式也不同。可分为：互斥共享方式和同时访问方式。 1. 互斥共享方式一段时间内只允许一个进程访问该资源，如磁带机,打印机等。虽然可以供多个进程使用，但是为了打印或记录结果不造成混淆，应规定一段时间内只允许一个进程访问该资源。 2. 同时访问方式某些资源，一段时间内是可以允许多个进程“同时”同时对他们进行访问，这个同时是宏观上的，在微观上可能是分时共享。 1.4.3 虚拟在OS中，把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为”虚拟“。 1.4.4 异步在多道环境下，允许多个程序并发执行。但由于资源有限，进程的执行不是一贯到底。而是走走停停，以不可预知的速度向前推进，这就是进程的异步。 1.5 操作系统的主要功能操作系统的主要功能应分为处理机管理、存储器管理、设备管理和文件管理。此外，还应向用户提供方便的用户接口。 1.5.1 处理机管理功能1. 进程控制在多道程序环境中，为了使作业能并发执行，必须为每道作业创建一个或几个进程，并为之分配必要的资源。当进程运行结束时，应立即撤销该进程，以便能及时回收该进程所占用的各种资源，供其它进程使用。 2. 进程同步为了使多个进程能有条不紊的运行，系统中必须设置相应的进程同步机制。该机制的主要任务是为多个进程的运行进行协调。 3. 进程通信如果一组相互合作的进程去完成一个共同的任务时，在他们之间往往需要交换信息。 4. 调度在传统OS中，调度包括作业调度和进程调度。 作业调度 作业调度的基本任务就是从后备队列中按照一定的算法选择出若干个作业，为他们分配所需资源，在这些作业调入内存后，分别为他们创建进程，是他们都称为可能获得处理机的就绪进程，并将他们插入就绪队列中。 进程调度 进程调度的任务是从进程的就绪队列中按照一定的算法选出一个进程，将处理机分配给他，并为他设置运行线程，使其投入执行。 1.5.2 存储器管理功能存储器管理视为多道程序的运行提供良好的环境，提高存储器利用率，并能从逻辑上扩充内存。为此，存储器管理应具有内存分配和回收、内存保护、地址映射和内存扩充等功能。 1. 内存分配内存分配主要任务是： 为每道程序分配内存空间 提高存储器的利用率，尽量减少不可用的内存空间 允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需要。 OS在实现内存分配时，可采取静态和动态两种方式： 静态分配内存。每个作业的内存空间在作业装入时确定，确定后不再改变。 动态分配内存。每个作业所要求的的基本内存空间虽然也是在装入时确定的，但允许作业在运行过程中继续申请新的附加内存空间，以适应程序和数据的动态增长。 2. 内存保护确保每道用户程序都在自己的内存空间内运行，彼此互不干扰。决不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其他用户程序中去执行。 3. 地址映射每道程序经编译连接后所形成的的可装入程序其地址都是从0开始的，但是不可能将他们从“0”地址开始装入内存，所以物理地址和逻辑地址并不一致，这时候就需要地址映射来让程序能正常运行。 4. 内存扩充借助虚拟存储技术来实现内存扩充，主要解决： 内存和I/O之间速度不匹配的问题 如果内存空间不足的问题 1.5.3 设备管理功能主要任务： 完成用户进程提出的I/O请求，为用户进程分配所需的I/O设备，并完成指定的I/O操作 提高CPU与I/O设备的利用率，提高I/O速度，方便用户使用I/O 为了实现以上功能，应具有缓冲管理、设备分配和设备处理以及虚拟设备等功能。 1. 缓冲管理为了有效的缓和CPU与I/O设备间速度不匹配的问题，提高CPU利用率，于是引入了缓冲管理。 2. 设备分配设备分配的基本任务是根据用户进程的I/O请求、系统现有资源情况以及按照某种设备分配策略，为之分配其所需的设备。 3. 设备处理实现CPU和设备控制器之间的通信，即由CPU向设备控制器发出I/O命令，要求他完成指定的I/O操作；反之，由CPU控制从接收器发来的中断请求，并给予迅速的响应和相应的处理。 1.5.4 文件管理功能主要是对用户文件和系统文件进行管理以方便用户使用，并保证文件的安全性。为此，文件管理应具有对文件存储空间管理、目录管理、文件的读/写管理以及文件的共享与保护等功能。 1. 文件存储空间的管理为每个文件分配必要的外存空间，提高我村利用率，进而提高文件系统的存、取速度。 2. 目录管理为每个文件建立一个目录项，目录项包括文件名、文件属性、文件在磁盘上的物理位置等，并对众多的目录项加以有效的组织，以实现方便的按名字存取。 3. 文件的读/写管理和保护根据用户的请求，从外存中读取数据或将数据写入外存。并且保护文件防止其被非法盗取和破坏。 1.5.5 操作系统与用户间的接口接口主要分为两大类：用户接口和程序接口。用户接口是供用户调用，方便用户直接或间接控制自己的作业。程序接口是为用户程序在执行中访问系统资源而设定的，是用户取得操作系统服务的唯一途径。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android多线程2--Java中的线程池]]></title>
    <url>%2Fposts%2Fb39fd0ab.html</url>
    <content type="text"><![CDATA[简介我们在写项目经常要用到多线程。但是线程的创建和摧毁都是较消耗资源和性能的，如果你每需要一个任务就新建一个线程，那可能会在线程的创建和摧毁上浪费掉很多资源。那如果我们让线程执行任务后不摧毁，接着执行下一个任务，这样是不是就能避免这种情况了。Java1.5中提供了Executor框架用于把任务的提交和执行解耦，任务的执行就交给Runnable或者Callable，而Executor框架用于处理任务。Executor中最核心的成员就是ThreadPoolExecutor，他就是线程池核心实现类。 ThreadPoolExecutor我们现在先来看下这个方法。构造器： 123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,markdownlint long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 我们来看下这些参数： corePoolSize：核心线程数。线程池刚创建的时候，线程数量为0，只有任务提交的时候才会创建线程。如果当前线程数量小于corePoolSize，则创建新线程；如果等于或者大于，则不再创建。 maximumPoolSize：线程池允许创建的最大线程数。当workQueue满了而且线程数小于maximumPoolSize时，线程池仍会创建新的线程。但是如果超过了maximumPoolSize时，则会抛出异常。 keepAliveTime：非核心线程闲置的超过时间。当线程池中线程数量大于workQueue，如果一个线程的空闲时间大于keepAliveTime，则该线程会被回收。如果任务很多，并且每个任务 的执行事件很短，则可以调大keepAliveTime来提高线程的利用率。另外，如果设置 allowCoreThreadTimeOut属性为true时，keepAliveTime也会应用到核心线程上。 timeUnit：keepAliveTime参数的时间单位。可选的单位有天(DAYS)、小时(HOURS)、分钟(MINUTES)、秒(SECONDS)、毫秒(MILLISECONDS)等。 workQueue：任务队列。如果当前线程数大于corePoolSize，则将任务添加到此任务队列中。该任务 队列是BlockingQueue类型的，也就是阻塞队列。 threadFactory：线程工厂。可以用线程工厂给每个创建出来的线程设置名字。一般情况下无须设置该参数。 RejectedExecutionHandler：饱和策略。这是当任务队列和线程池都满了时所采取的应对策略，默认是AbordPolicy，表示无法处理新任务，并抛出RejectedExecutionException异常。此外还有3种策略，它们分别如下: CallerRunsPolicy：用调用者所在的线程来处理任务。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。 DiscardPolicy：不能执行的任务，并将该任务删除。 DiscardOldestPolicy：丢弃队列最近的任务，并执行当前的任务。 线程池的处理流程线程池的任务处理主要分为3个步骤 提交任务后，线程池先判断线程数是否达到了核心线程数corePoolSize。如果未达到核心线程数，则创建核心线程处理任务；否则，就执行下一步操作。 接着线程池判断任务队列是否满了。如果没满，则将任务添加到任务队列中；否则，就执行下一步操作。 接着因为任务队列满了，线程池就判断线程数是否达到了最大线程数。如果未达到，则创建非核心线程处理任务；否则，就执行饱和策略，默认会抛出RejectedExecutionException异常。 如果线程池中的线程数未达到核心线程数，则创建核心线程处理任务。 如果线程数大于或者等于核心线程数，则将任务加入任务队列，线程池中的空闲线程会不断地从 任务队列中取出任务进行处理。 如果任务队列满了，并且线程数没有达到最大线程数，则创建非核心线程去处理任务。 如果线程数超过了最大线程数，则执行饱和策略。 线程池的种类CachedThreadPool：可缓存线程池 线程数无限制 有空闲线程则复用空闲线程，若无空闲线程则新建线程 一定程序减少频繁创建/销毁线程，减少系统开销 创建源码： 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; CachedThreadPool的corePoolSize为0，maximumPoolSize设置为Integer.MAX_VALUE，这意味着CachedThreadPool没有核心线程，非核心线程是无界的。keepAliveTime设置为60L，则空闲线程等待新任务 的最长时间为60s。在此用了阻塞队列SynchronousQueue，它是一个不存储元素的阻塞队列，每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都等待另一个线程的插入操作。 FixedThreadPool：定长线程池 可控制线程最大并发数（同时执行的线程数） 超出的线程会在队列中等待 创建源码： 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; FixedThreadPool的corePoolSize和maximumPoolSize都设置为创建FixedThreadPool指定的参数nThreads，也就意味着FixedThreadPool只有核心线程，并且数量是固定的，没有非核心线程。keepAliveTime设置为0L意味着多余的线程会被立即终止。因为不会产生多余的线程，所以keepAliveTime是无效的参数。另外，任务队列采用了无界的阻塞队列LinkedBlockingQueue。 ScheduledThreadPool：定长线程池支持定时及周期性任务执行。 创建源码： 1234public static ScheduledExecutorService newScheduledThreadPool( int corePoolSize, ThreadFactory threadFactory) &#123; return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);&#125; 我们可以看到在创建源码中他跳转到了ScheduledThreadPoolExecutor的构造方法，我们继续看进去： 123456public ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue(), threadFactory);&#125; 从上面的代码可以看出，ScheduledThreadPoolExecutor的构造方法最终调用的是ThreadPoolExecutor的构造方法。corePoolSize是传进来的固定数值，maximumPoolSize的值是Integer.MAX_VALUE。因为采用的DelayedWorkQueue是无界的，所以maximumPoolSize这个参数是无效的。 SingleThreadExecutor：单线程化的线程池 有且仅有一个工作线程执行任务 所有任务按照指定顺序执行，即遵循队列的入队出队规则 创建源码： 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; corePoolSize和maximumPoolSize都为1，意味着SingleThreadExecutor只有一个核心线程，其他的参数都和FixedThreadPool一样，这里就不赘述了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next配置备份]]></title>
    <url>%2Fposts%2F5b6e53a4.html</url>
    <content type="text"><![CDATA[Hexo配置备份 评论系统 来必力 - https://www.livere.com/ valine(在用) - https://valine.js.org/ 阅读量显示 leancloud - https://leancloud.cn/ valine(在用) - https://valine.js.org/]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android多线程1--Java中的阻塞队列]]></title>
    <url>%2Fposts%2F63ab42b7.html</url>
    <content type="text"><![CDATA[阻塞队列前言在谈论阻塞队列之前我们先看下操作系统多线程部分一个经典的例子——生产者和消费者问题： 现在有两个进程，一个是生产者一个是消费者，还有一个线程缓冲区。生产者主要作用就是向缓冲区中添加数据，消费者就是从缓冲区中取出数据。这个问题的核心就是如何确保生产者不会在缓冲区满了的时候还往其中添加元素，消费者不会在缓冲区空了的时候还要求取出数据。 关于这个问题的解决办法我们以后再说，我们现在主要讨论线程缓冲区——阻塞队列。 阻塞队列简介阻塞队列就是队列，只是在一般的队列上添加了两个条件： 当队列满了的时候不允许再添加数据 当队列空了的时候不允许从中取数据 在Java中，阻塞队列是通过BlockingQueue来实现的，BlockingQueue是Java.util.concurrent包下一个重要的数据结构。 BlockingQueue的操作方法 方法 抛异常 返回特定值 阻塞 超时 插入 add(E e) offer(E e) put(E e) offer(E e, long timeout, TimeUnit unit) 移除 remove() poll() take() poll(time, unit) 检查 element() peek() 不可用 不可用 解释： 抛异常：如果操作无法执行，则抛出一个异常 特定值：如果操作无法执行，则返回一个特定的值 阻塞： 如果操作无法执行，则方法调用被阻塞，直到可以执行 超时：如果操作无法执行，则方法调用被阻塞，直到可以执行或者超过限定的时间。返回一个特定值以告知该操作是否成功(典型的是true / false)。 Java中的各种阻塞队列Java基于BlockingQueue给开发者提供了7个阻塞队列： ArrayBlockingQueue：基于数组的有界阻塞队列。有界就意味着他有一个最大限度，所存储的线程的数量不能超过这个限定值。你也可以在对其初始化的时候给定这个限定值。但是由于它是基于数组所以他和数组一样，在初始化的时候限定了这个大小以后就不能改变。 LinkedBlockingQueue：基于链表的阻塞队列。它内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用Integer.MAX_VALUE作为上限。LinkedBlockingQueue内部以FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。由于默认是无上限的，所以在使用他的时候，如果生产者的速度大于消费者的速度，系统内存可能会被耗尽。所以使用他一定要设置初值。 PriorityBlockingQueue：支持优先级的无界队列。默认情况按照自然顺序生序排列，你可以重写compateTo()方法来制定元素按规定排序。 DelayQueue：支持延时获取元素的无界阻塞队列。队列中的元素必须实现Delayed接口。 SynchromousQueue：是一个特殊的队列。他不能存储任何元素，他的每一次插入操作必须等待另一个线程相应的删除操作，反之亦然。 LinkedTransferQueue：基于链表的无界阻塞TransferQueue队列。相对于其他队列，他多了transfer(E e)、tryTransfer(E e)和tryTransfer(E e, long timeout, TimeUnit unit)方法。 LinkedBlockingDeque：是一个链表结构的双向阻塞队列。可在两端入队出对。所以当多线程入队时，减少了一半的竞争。 阻塞队列实现原理下面我们以ArrayBlockingQueue源码为例，来看下阻塞队列实现原理： 定义首先就是一堆变量的定义： 123456789101112131415161718192021222324252627/** The queued items */final Object[] items;/** items index for next take, poll, peek or remove */int takeIndex;/** items index for next put, offer, or add */int putIndex;/** Number of elements in the queue */int count;/* * Concurrency control uses the classic two-condition algorithm * found in any textbook. *//** Main lock guarding all access */final ReentrantLock lock;/** Condition for waiting takes */privatefinal Condition notEmpty;/** Condition for waiting puts */privatefinal Condition notFull; items是存储队列元素的数组，takeIndex和putIndex分别是取数据和存数据的索引，count是队列中元素个数，lock为看一个可重入锁，notEmpty和notFull均为等待条件，由lock创建。 构造器接下来看下它的构造器 12345678public ArrayBlockingQueue(int capacity) &#123;&#125;public ArrayBlockingQueue(int capacity, boolean fair) &#123; &#125;public ArrayBlockingQueue(int capacity, boolean fair, Collection&lt;? extends E&gt; c) &#123;&#125; 构造器有三个重载的版本，第一个构造器只有一个参数用来指定容量，第二个构造器多了一个参数来指定访问策略，第三个构造器又多了一个参数可以指定用另外一个集合进行初始化。 数据的添加接下来我们看看BlockingQueue的三个插入的方法：put()、add()和offer()： put() 方法：队列满，会阻塞调用存储元素的线程 1234567891011121314151617public void put(E e) throws InterruptedException &#123; // 先检查e是不是空，如果空则抛异常 Objects.requireNonNull(e); // 获取一个重入锁lock final ReentrantLock lock = this.lock; // 加锁，保证调用put方法的时候只有1个线程 lock.lockInterruptibly(); try &#123; // 如果线程中的元素数量是否等于当前数组的长度，如果相等则调用await方法等待，如果不相等则enqueue方法插入元素 while (count == items.length) notFull.await(); enqueue(e); &#125; finally &#123; // 解锁 lock.unlock(); &#125;&#125; add()方法：实际上调用了offer()方法 123456public boolean add(E e) &#123; if (offer(e)) return true; else throw new IllegalStateException("Queue full");&#125; offer()方法：成功返回true，失败返回false 1234567891011121314151617181920public boolean offer(E e) &#123; // 检查e是否为空 Objects.requireNonNull(e); // 获取重入锁lock final ReentrantLock lock = this.lock; // 加锁 lock.lock(); try &#123; // 如果如果线程中的元素数量是否等于当前数组的长度，如果相等则调返回false，如果不相等则enqueue方法插入元素并返回true if (count == items.length) return false; else &#123; enqueue(e); return true; &#125; &#125; finally &#123; // 解锁 lock.unlock(); &#125;&#125; 以上三个方法都调用了enqueue()方法。下面我们就来看看这个方法： 123456789101112131415/** * Inserts element at current put position, advances, and signals. * Call only when holding lock. */private void enqueue(E e) &#123; // assert lock.isHeldByCurrentThread(); // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; final Object[] items = this.items; items[putIndex] = e; if (++putIndex == items.length) putIndex = 0; count++; notEmpty.signal();&#125; 先获取元素数组items，然后添加putIndex上，如果++putIndex等于items的长度，则证明当前这个items所有元素都添加进了，就让putIndex等于0.然后调用notEmpty.signal()方法唤醒正在获取元素的线程，让他们从队列中取数据。 数据的取出ArrayBlockingQueue的取数据方法总共也有三个方法：poll()、take()和remove() poll()方法：获取元素，存在返回元素e,不存在返回null 12345678910111213public E poll() &#123; // 获取重入锁lock final ReentrantLock lock = this.lock; // 加锁 lock.lock(); try &#123; // 如果元素数量等于0就返回null，否则调用dequeue()方法 return (count == 0) ? null : dequeue(); &#125; finally &#123; // 解锁 lock.unlock(); &#125;&#125; take()方法：取元素。如果队列为空,则会阻塞调用获取元素的线程 123456789101112131415public E take() throws InterruptedException &#123; // 获取重入锁lock final ReentrantLock lock = this.lock; // 加锁 lock.lockInterruptibly(); try &#123; // 如果线程中的元素数量是否等于0，如果相等则调用await方法等待，如果不相等则dequeue方法删除元素 while (count == 0) notEmpty.await(); return dequeue(); &#125; finally &#123; // 解锁 lock.unlock(); &#125;&#125; remove()方法：取元素，它是取特定的那个元素 1234567891011121314151617181920212223242526public boolean remove(Object o) &#123; // 判断o是否为空 if (o == null) return false; // 获取重入锁lock final ReentrantLock lock = this.lock; // 加锁 lock.lock(); try &#123; // 如果元素数量大于0，则获取items，然后便利元素，判断o是其中的哪个，然后删除那个 if (count &gt; 0) &#123; final Object[] items = this.items; for (int i = takeIndex, end = putIndex, to = (i &lt; end) ? end : items.length; ; i = 0, to = end) &#123; for (; i &lt; to; i++) if (o.equals(items[i])) &#123; removeAt(i); return true; &#125; if (to == end) break; &#125; &#125; return false; &#125; finally &#123; // 解锁 lock.unlock(); &#125;&#125; poll()和take()两个方法都调用了dequeue()方法，我们就看下dequeue()是如何来实现的： 12345678910111213141516171819/** * Extracts element at current take position, advances, and signals. * Call only when holding lock. */private E dequeue() &#123; // assert lock.isHeldByCurrentThread(); // assert lock.getHoldCount() == 1; // assert items[takeIndex] != null; final Object[] items = this.items; @SuppressWarnings("unchecked") E e = (E) items[takeIndex]; items[takeIndex] = null; if (++takeIndex == items.length) takeIndex = 0; count--; if (itrs != null) itrs.elementDequeued(); notFull.signal(); return e;&#125; 和上面的enqueue()方法类似，再次就不再赘述。 阻塞队列的应用前面我说过，阻塞队列主要用在生产者和消费者模式中，那下面我们就来写一个简单的小demo 这段代码来自刘望舒所著《Android进阶之光》 如果不用阻塞队列： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.PriorityQueue;public class Test &#123; private int queueSize = 10; private PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(queueSize); public static void main(String[] args) &#123; Test test = new Test(); Producer producer = test.new Producer(); Consumer consumer = test.new Consumer(); producer.start(); consumer.start(); &#125; class Consumer extends Thread &#123; @Override public void run() &#123; while (true) &#123; synchronized (queue) &#123; while (queue.size() == 0) &#123; try &#123; System.out.println("队列空，等待数据"); queue.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); queue.notify(); &#125; &#125; // 每次移走队首元素 queue.poll(); queue.notify(); &#125; &#125; &#125; &#125; private class Producer extends Thread &#123; @Override public void run() &#123; while (true) &#123; synchronized (queue) &#123; try &#123; System.out.println("队列满，等待有空余空间"); queue.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); queue.notify(); &#125; &#125; // 每次插入一个元素 queue.offer(1); queue.notify(); &#125; &#125; &#125;&#125; 使用阻塞队列ArrayBlockingQueue： 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.concurrent.ArrayBlockingQueue;public class BlockingQueueTest &#123; private int queueSize = 10; private ArrayBlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;&gt;(queueSize); public static void main(String[] args) &#123; BlockingQueueTest test = new BlockingQueueTest(); BlockingQueueTest.Producer producer = test.new Producer(); BlockingQueueTest.Consumer consumer = test.new Consumer(); producer.start(); consumer.start(); &#125; class Consumer extends Thread &#123; @Override public void run() &#123; while (true) &#123; try &#123; queue.take(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; private class Producer extends Thread &#123; @Override public void run() &#123; while (true) &#123; try &#123; queue.put(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin入门1:Kotlin和Java区别基础篇]]></title>
    <url>%2Fposts%2F343b01ae.html</url>
    <content type="text"><![CDATA[Koltin入门Kotlin简介 科特林岛(Котлин)是一座俄罗斯的岛屿,位于圣彼得堡以西约30公里处,形状狭长,东西长度约14公里,南北宽度约2公里,面积有16平方公里,扼守俄国进入芬兰湾的水道。科特林岛上建有喀琅施塔得市,为圣彼得堡下辖的城市。 而我们虽说的kotlin，就是一门根据它命名的一种现代程序设计语言。Kotlin 是一个用于现代多平台应用的静态编程语言，由 JetBrains 开发。Kotlin可以编译成Java字节码，也可以编译JavaScript，方便在没有JVM的设备上运行。Kotlin已正式成为Android官方支持开发语言。 变量kotlin和Java的最基本的区别就是kotlin中万物皆对象，Java中还存在着int、float等基本类型，但是在kotlin中，它把这些都定义成了对象，类似于Java中的封装类 变量的声明上面说了，kotlin万物皆对象，所以所有的变量也都是对象。在kotlin定义对象和Java有点小区别。kotlin定义对象的格式为 声明类型 变量名： 变量类型 其中： 声明类型分为val和var。val是不可变类型，类似于const，定义时必须赋值，赋值后不能被修改。var是可变类型。 变量名就是你定义的这个变量的名称。 变量类型就是你这个变量对应的类的名字。 类型推断省去变量类型kotlin里面类似c++的auto类型，对于基本类型，你可以不写变量类型，kotlin会自动帮你判断。 1234567891011var a = 5println(a is Int)var b = “123println(b is String)var c = 1.3println(c is Float)var d = trueprintln(d is Boolean) is关键字is顾名思义，就是判断这个变量是不是这个类型的实例。例子见上。 数字类型 类型 宽度(bit) Byte 8 Short 16 Int 32 Long 64 Float 32 Double 64 这些类型都继承自Number和Comparable类。 字面常量值 十进制：123 十六进制：0x0f 二进制：0b0010 Long类型：123L double类型：123.4 Float类型：123.4f或者123.4F 我们也可以使用下划线_来方便我们阅读 121_000_000 // 10000000xFF_EC // 0xFFEC 显示转换kotlin中不可隐式转换比如Java 中 12int a = 2;long b = a; 但是在kotlin中 123var a : Int? = 2var b : Long? = a; // errorvar b : Long? = a.toLong() Char类型kotlin中的Char表示字符。但是和Java不同，他不能直接当ASCII码值。 12345fun check(c : Char) &#123; if (c == 1) &#123; // error &#125;&#125; Boolean类型kotlin中的布尔类型用Boolean来表示，他有两个值true和false。用法和Java一样。 String类型和Java一样，kotlin中的字符串也是String。但是kotlin中String是不可变的。所以kotlin中String必须是val类型。同时，String是final不可继承的。 Array类型kotlin中数组必须使用Array表示。基本写法 val array: Array&lt;类型&gt; = arrayOf(..) 例如 12345678910111213141516171819202122232425262728293031/**整型Int的数组*/val arrayOfInt: IntArray = intArrayOf(1,3,5,7,9)/**字符Char类型的数组*/val arrayOfChar: CharArray = charArrayOf('H','e','l','l','o','W','o','r','l','d')/**字符串String数组*/val arrayOfString: Array&lt;String&gt; = arrayOf("Hello","World")fun main(args: Array&lt;String&gt;) &#123; //查看有多少个元素 println(arrayOfInt.size) //遍历数组 for (char in arrayOfChar)&#123; println(char) &#125; //根据所引获取数据,数组是从0开始的，现在获取第二个东京大学 println(arrayOfUniversity[1]) //重新给数组赋值，早稻田大学 arrayOfUniversity[1] = University("早稻田大学") println(arrayOfUniversity[1]) //将char连接成一个字符串,默认是自动由逗号","分割的，输出H, e, l, l, o, W, o, r, l, d println(arrayOfChar.joinToString()) //如果想要连成HelloWorld println(arrayOfChar.joinToString ("")) //数组的切片,输出3，5,结尾需要arrayOfInt-1，不然会报索引越界异常 println(arrayOfInt.slice(1..2)) println(arrayOfInt.size)&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin Anko入门]]></title>
    <url>%2Fposts%2F62bb1dd7.html</url>
    <content type="text"><![CDATA[Kotlin Anko入门简介Anko的官网就是他的GitHub地址 https://github.com/Kotlin/anko 官方对Anko的解释是 Anko是一个 Kotlin 库，它使Android应用程序开发更快更容易。它使您的代码清晰易读，让您忘记Android SDK for Java的粗糙边缘。 为什么这样说呢？比方说如果你写Android，你在xml中定义了一个Button，他的ID是button_login。 如果是Java： 12setContentView(R.layout.activity_words_detail);Button button = findViewById(R.Id.button_login); 而如果你使用kotlin的话，你可以就按如下代码写 123import kotlinx.android.synthetic.main.activity_kotlin_main.*...button_login.setText("Kotlin Android Extensions 我不太喜欢"); 这样确实比Java方便多了，不需要对每一个组件都定义再findViewById，可以就直接输入组件的id然后就能使用了。但是我们还是觉得不够啊，为什么我们不能就直接在代码中写入各个组件呢，于是，Anko来了。 导入AnkoAnko由几部分组成： Anko Commons：一个轻量级的库，包含用于Layouts，Intent，Log等的帮助程序; Anko Layouts：一种快速且类型安全的方式来编写动态Android布局; Anko SQLite：Android SQLite的查询DSL和解析器集合; Anko Coroutines：基于kotlinx.coroutines库的实用程序。 你可以在app的build.gradle中添加 12345678dependencies &#123; // Anko Layouts implementation "org.jetbrains.anko:anko-sdk25:$anko_version" // sdk15, sdk19, sdk21, sdk23 are also available implementation "org.jetbrains.anko:anko-appcompat-v7:$anko_version" // Coroutine listeners for Anko Layouts implementation "org.jetbrains.anko:anko-sdk25-coroutines:$anko_version" implementation "org.jetbrains.anko:anko-appcompat-v7-coroutines:$anko_version"&#125; 这个依赖可以直接导入所有的可用特性（包括Commons, Layouts, SQLite)。 使用Anko layout创建简单布局使用Anko创建布局很简单： 12345678910111213141516171819class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) verticalLayout &#123; padding = dip(30) editText &#123; hint = "Name" textSize = 24f &#125; editText &#123; hint = "Password" textSize = 24f &#125; button("登录") &#123; textSize = 26f &#125; &#125; &#125;&#125; 你只需要在Activity中写入DSL代码就能使用它。 AnkoComponent尽管我们现在可以直接在Activity中写入DSL代码，但是我们还是觉得把代码和布局文件放在一起不太好，希望把Activity和DSl代码放到两个不同的类里面，所以AnkoComponent就出来了。代码如下 12345678910111213141516171819202122232425class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) MainActivityUI().setContentView(this) &#125;&#125;class MainActivityUI : AnkoComponent&lt;MainActivity&gt; &#123; override fun createView(ui: AnkoContext&lt;MainActivity&gt;) = with(ui) &#123; verticalLayout &#123; padding = dip(30) editText &#123; hint = "Name" textSize = 24f &#125; editText &#123; hint = "Password" textSize = 24f &#125; button("登录") &#123; textSize = 26f &#125; &#125; &#125;&#125; Theme在Anko如果你想设置Theme需要使用themeable 1234verticalLayout &#123; padding = dip(30) themedButton("登陆", theme = R.style.Base_TextAppearance_AppCompat_Button)&#125; LayoutParams在Anko中也可以使用LayoutParams。 比方说我现在要显示一个button，下面显示一个图片。 如果使用XML: 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" android:gravity=center android:textSize="20sp" /&gt; &lt;ImageView android:layout_width="match_parent" android:layout_height="match_parent" android:background="@color/colorAccent" /&gt;&lt;/LinearLayout&gt; 但是使用Anko: 12345678910verticalLayout &#123; textView ("Hello World!") &#123; textSize = sp(12).toFloat() &#125;.lparams(height = wrapContent, width = wrapContent) &#123; horizontalGravity = Gravity.CENTER_HORIZONTAL &#125; imageView &#123; backgroundColor = Color.BLUE &#125;.lparams(height = matchParent, width = matchParent)&#125; 注意： horizontalMargin 同时设置 left 和 right margins verticalMargin 同时设置 top 和 bottom margin 同时设置4个方向的 margins Listeners在Anko中设置Listeners非常简单，我下面以Button的OnClick举例： 12345button("登录") &#123; id = buttonLogin textSize = 26f onClick &#123; toast("OnClickLoginButton") &#125;&#125; 使用Fragment加载先创建一个Activity，把Fragment加进去 123456789class AnkoFragmentActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) linearLayout &#123; id = R.id.fragment_id supportFragmentManager.beginTransaction().replace(id, AnkoFragment.newInstance()).commit() &#125; &#125;&#125; 然后在Fragment的onCreateView()中加入DSL代码，然后返回View即可 12345678910111213141516class AnkoFragment : Fragment() &#123; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; // return inflater.inflate(R.layout.fragment_anko, container, false) return UI &#123; verticalLayout &#123; editText() button("OK") &#125; &#125;.view &#125; companion object &#123; fun newInstance(): AnkoFragment &#123; return AnkoFragment() &#125; &#125;&#125; 不足AnkoLayout确实挺好的，因为他把UI代码集成到了代码文件中，不用再像以前一样写一个点击事件还得先findViewBuId，然后再setOnClickListeners。代码能非常简洁。 但是AnkoLayout还是不够完美，感觉写起来还是没有XML那个顺手（可能是我写惯了XML，刚开始用Anko还不够熟练），而且Anko还有很多控件都不支持。最重要的是，他没有实时预览！！！ Android Studio里面有一个叫Anko Support的插件，可以实现anko的预览，但是他必须是先将项目构建了再预览的，不算是实时预览]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android类之SharedPreferences]]></title>
    <url>%2Fposts%2F8a47fe84.html</url>
    <content type="text"><![CDATA[Android类之SharedPreferences简介SharedPreferences是一个轻量的存储类，用于把一些只需要少量简单类型数据保存到本地，例如搜索历史、用户设置等。 他只适合处理简单的数据，处理太过于庞大的数据会减慢程序运行。 使用步骤1. 存储数据 使用Activity类的getSharedPreferences()方法获得SharedPreferences对象，其中存储key-value的文件名由getSharedPreferences()方法的第一个参数指定。 使用SharedPreferences接口的edit()获得SharedPreferences.Editor对象。 通过SharedPreferences.Editor接口的putXxx()方法保存key-value对，其中Xxx表示不同的数据类型。例如：字符串类型的value需要用putString方法。 通过SharedPreferences.Editor接口的commit()方法保存key-value对，commit方法相当于数据库事务中的提交操作。 12345SharedPreferences sharedPreferences = getSharedPreferences("test", Context.MODE_PRIVATE);Editor editor = sharedPreferences.edit();//获取编辑器editor.putString("name", "小明");editor.putInt("age", 24);editor.commit();//提交修改 2. 读取数据 使用Activity类的getSharedPreferences()方法获得SharedPreferences对象。 通过SharedPreferences对象的getXxx()方法得到数据。 1234SharedPreferences sharedPreferences= getSharedPreferences("test", Activity.MODE_PRIVATE);// 使用getString方法获得value，注意第2个参数是value的默认值 String name =sharedPreferences.getString("name", "");int age =sharedPreferences.getInt("age", 0); SharedPreferences的四种模式 1234Context.MODE_PRIVATE：为默认操作模式,代表该文件是私有数据,只能被应用本身访问,在该模式下,写入的内容会覆盖原文件的内容Context.MODE_APPEND：模式会检查文件是否存在,存在就往文件追加内容,否则就创建新文件.Context.MODE_WORLD_READABLE：表示当前文件可以被其他应用读取.Context.MODE_WORLD_WRITEABLE：表示当前文件可以被其他应用写入.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidView之PopupWindow]]></title>
    <url>%2Fposts%2F1900f7eb.html</url>
    <content type="text"><![CDATA[AndroidView之PopupWindow因为项目中有很多地方都需要使用PopupWindow，所以特别查了一下，做了一个简单的总结，过两天就加到项目中去。 PopupWindowPopupWindow，顾名思义，就是一个用来显示弹窗的组件。 创建步骤 创建PopupWindow实例 设置一些基本参数 显示PopupWindow构造方法 1PopupWindow window = new PopupWindow(View contentView, int width, int height, boolean focusable); 这个方法有四个参数，第一个参数是用于PopupWindow中的View，第二个参数是PopupWindow的宽度，第三个参数是PopupWindow的高度，第四个参数指定PopupWindow能否获得焦点。 示例代码 12View contentView = LayoutInflater.from(MainActivity.this).inflate(R.layout.popuplayout, null);PopupWindwo window = PopupWindow (contentView, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, true); 基本方法 window.setBackgroundDrawable(Drawable background); 设置PopupWindow的背景 window.setOutsideTouchable(boolean touchable); 设置PopupWindow是否能响应外部点击事件 window.setTouchable(boolean touchable); 设置PopupWindow是否能响应点击事件只有同时设置PopupWindow的背景和可以响应外部点击事件，它才能“真正”响应外部点击事件。 显示PopupWindow window.showAtLocation(View parent, int gravity, int x, int y); 第一个参数是PopupWindow的父View，第二个参数是PopupWindow相对父View的位置，第三和第四个参数分别是PopupWindow相对父View的x、y偏移 window.showAsDropDown(View anchor, int xoff, int yoff, int gravity); 第一个参数是PopupWindow的锚点，第二和第三个参数分别是PopupWindow相对锚点的x、y偏移 为PopupWindow添加动画 进入时动画：(context_menu_enter.xml) 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:duration="@android:integer/config_shortAnimTime" android:fromXDelta="0" android:fromYDelta="100%p" android:interpolator="@android:anim/accelerate_decelerate_interpolator" android:toXDelta="0" android:toYDelta="0"/&gt; &lt;/set&gt; 退出时动画：(context_menu_exit.xml) 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;translate android:duration="@android:integer/config_shortAnimTime" android:fromXDelta="0" android:fromYDelta="0" android:interpolator="@android:anim/accelerate_decelerate_interpolator" android:toXDelta="0" android:toYDelta="100%p" /&gt; &lt;/set&gt; 生成style 1234&lt;style name=&quot;contextMenuAnim&quot; parent=&quot;@android:style/Animation.Activity&quot;&gt; &lt;item name=&quot;android:windowEnterAnimation&quot;&gt;@anim/context_menu_enter&lt;/item&gt; &lt;item name=&quot;android:windowExitAnimation&quot;&gt;@anim/context_menu_exit&lt;/item&gt;&lt;/style&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
</search>
