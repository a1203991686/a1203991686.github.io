<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统3--进程的同步</title>
      <link href="/posts/362e394f.html"/>
      <url>/posts/362e394f.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>大家可以看下我使用幕布软件画的<a href="https://mubu.com/doc/3Pf0zwzrgw" target="_blank" rel="noopener">思维导图</a>，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员<a href="https://mubu.com/inv/477598" target="_blank" rel="noopener">https://mubu.com/inv/477598</a></p></blockquote><a id="more"></a><h1 id="3-1-进程同步"><a href="#3-1-进程同步" class="headerlink" title="3.1 进程同步"></a>3.1 进程同步</h1><h2 id="3-1-1-同步概念"><a href="#3-1-1-同步概念" class="headerlink" title="3.1.1 同步概念"></a>3.1.1 同步概念</h2><h3 id="3-1-1-1-进程同步的概念"><a href="#3-1-1-1-进程同步的概念" class="headerlink" title="3.1.1.1 进程同步的概念"></a>3.1.1.1 进程同步的概念</h3><p>进程同步机制的主要任务就是对多个相关进程在执行次序上进行协调，使并发执行的进程之间能按照一定的规则共享系统资源，并能很好的配合工作，从而使程序的执行具有可再现性。</p><h3 id="3-1-1-2-制约关系"><a href="#3-1-1-2-制约关系" class="headerlink" title="3.1.1.2 制约关系"></a>3.1.1.2 制约关系</h3><p>对于处于同一个系统中的多个进程，由于他们共享着系统的资源，或者为了完成同一个任务而相互合作，所以他们之间可能存在下面两种制约关系：</p><ol><li>间接相互制约关系<br> 系统中的进程难免会调用像打印机、CPU等这样的临界资源。如果想这些资源正常调用，必须保证多个进程之间互斥地访问这些资源，进而就在这些进程间形成了间接相互制约关系。<br> 为了保证这些进程能有序的进行，对于系统中的这类资源，必须由系统实施统一分配，即用户在使用之前必须先提出申请，绝不允许用户直接使用。</li><li>直接相互制约关系<br> 在系统中也会存在一些进程，他们为了完成同一个目标而相互配合合作工作，这种就是直接互相制约关系。<br> 进程间的直接制约关系就是源于他们之间的相互合作。</li></ol><h3 id="3-1-1-3-临界资源"><a href="#3-1-1-3-临界资源" class="headerlink" title="3.1.1.3 临界资源"></a>3.1.1.3 临界资源</h3><p>虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。此外，如果变量、数据等都可以被若干进程共享，也属于临界资源。</p><h3 id="3-1-1-4-临界区"><a href="#3-1-1-4-临界区" class="headerlink" title="3.1.1.4 临界区"></a>3.1.1.4 临界区</h3><p>人们把在每个进程中访问临界资源的那段代码称为临界区。若能保证诸进程互斥地进入自己的临界区，便可实现诸进程对临界资源的互斥访问。<br>为此，每个进程在进入临界区之前，应先对要访问的临界区进程检查：如果临界区正在被访问，则进程不能进入临界区；如果临界区没有被访问，那进程就可进入临界区，并将临界区正在被访问的标志置为正被访问。<br>所以，我们可以将访问临界资源的线程的循环代码分为如下部分：</p><ul><li>访问临界区之前用于上述判断的代码区称为<strong>进入区</strong></li><li>在访问完临界区之后用于将临界区正被访问的标志恢复为未被访问的标志的代码区称为<strong>退出区</strong></li><li>除了进入去、临界区、退出区代码之外的其它代码称为<strong>剩余区</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    进入区</span><br><span class="line">    临界区</span><br><span class="line">    退出区</span><br><span class="line">    剩余区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-1-5-同步机制应遵循的规则"><a href="#3-1-1-5-同步机制应遵循的规则" class="headerlink" title="3.1.1.5 同步机制应遵循的规则"></a>3.1.1.5 同步机制应遵循的规则</h3><ol><li>空闲让进：当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效的利用临界资源</li><li>忙则等待：当已有进程进入临界区，表明临界资源正在被访问，因而其它视图进入临界区的进程必须等待，以保证对临界资源的互斥访问</li><li>有限等待：对要求访问临界资源的进程，应保证在有限的时间内能进入自己的临界区，以免陷入“死等”状态</li><li>让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态</li></ol><h2 id="3-1-2-同步机制"><a href="#3-1-2-同步机制" class="headerlink" title="3.1.2 同步机制"></a>3.1.2 同步机制</h2><h3 id="3-2-2-1-信号量机制"><a href="#3-2-2-1-信号量机制" class="headerlink" title="3.2.2.1 信号量机制"></a>3.2.2.1 信号量机制</h3><h4 id="1-什么是信号量"><a href="#1-什么是信号量" class="headerlink" title="1. 什么是信号量"></a>1. 什么是信号量</h4><p>信号量的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程，值则与相应的资源的使用情况有关：</p><ul><li>当他的值大于0时，表示当前可用资源的数量</li><li>当他的值小于0时，其绝对值表示等待使用该资源的进程个数</li></ul><h4 id="2-什么是信号量机制"><a href="#2-什么是信号量机制" class="headerlink" title="2. 什么是信号量机制"></a>2. 什么是信号量机制</h4><p>信号量机制即利用pv操作对信号量进行处理。而且信号量只能由pv操作进程处理。<br>当S&gt;0时，S表示可用资源的数量。执行一次P操作意味着分配一个单位资源，因此S值减1；当S&lt;0时，表示已经没有可用资源，请求者必须等待别的进程释放该类资源，他才能运行下去。而执行一个V操作以为着释放一个单位资源，因此S的值加1；当S&gt;0，表示有某些资源正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去。</p><h3 id="3-2-2-2-PV操作"><a href="#3-2-2-2-PV操作" class="headerlink" title="3.2.2.2 PV操作"></a>3.2.2.2 PV操作</h3><h4 id="1-P操作"><a href="#1-P操作" class="headerlink" title="1. P操作"></a>1. P操作</h4><p>申请一个单位资源，进程进入临界区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wait (S) &#123;</span><br><span class="line">    <span class="keyword">while</span> (s &lt;= <span class="number">0</span>) ;<span class="comment">// 如果没有资源则循环等待</span></span><br><span class="line">    S--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将信号量S的值减1，即S=S-1；</li><li>如果S&lt;=0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。</li></ol><h4 id="2-V操作"><a href="#2-V操作" class="headerlink" title="2. V操作"></a>2. V操作</h4><p>释放一个单位资源，进程从临界区出来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signal (S) &#123;</span><br><span class="line">    S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将信号量S的值加1，即S=S+1；</li><li>如果S&gt;0，则该进程继续执行；否则释放队列中第一个等待信号量的进程。</li></ol><h4 id="3-PV操作的意义"><a href="#3-PV操作的意义" class="headerlink" title="3. PV操作的意义"></a>3. PV操作的意义</h4><p>用PV操作来实现进程的同步和互斥</p><h3 id="3-2-3-管程机制"><a href="#3-2-3-管程机制" class="headerlink" title="3.2.3 管程机制"></a>3.2.3 管程机制</h3><p>尽管信号量机制很方又高效，但是每个要访问临界资源的进程都必须必备同步操作，这就使得大量的同步操作分散在各个进程中。这不仅给系统的管理带来麻烦，还会因同步操作不当而产生死锁。为了解决上述问题，变产生了一种新的同步工具——管程。</p><h4 id="1-管程的定义"><a href="#1-管程的定义" class="headerlink" title="1. 管程的定义"></a>1. 管程的定义</h4><p>系统中各种硬件资源和软件资源均可用数据结构抽象地描述其资源特征，即用少量信息和对该资源所执行的操作来表征该资源。所以就出现了管程。<br>管程可以看成一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。<br>在管程入口处的等待队列称为入口等待队列，由于进程会执行唤醒操作，因此可能有多个等待使用管程的队列，这样的队列称为紧急队列，它的优先级高于等待队列。</p><h4 id="2-管程的特征"><a href="#2-管程的特征" class="headerlink" title="2. 管程的特征"></a>2. 管程的特征</h4><ol><li>模块化<br> 管程是一个基本的软件模块，可以单独编译</li><li>抽象数据类型<br> 管程中封装了数据及对于数据的操作</li><li>信息隐藏<br> 管程外的进程或其他软件模块只能通过管程对外的接口来访问管程提供的操作，管程内部的实现细节对外界是透明的</li><li>使用的互斥性<br> 任何一个时刻，管程只能由一个进程使用。进入管程时的互斥由编译器负责完成</li></ol><h4 id="3-条件变量"><a href="#3-条件变量" class="headerlink" title="3. 条件变量"></a>3. 条件变量</h4><p>一个进程被阻塞或挂起的条件（原因）有多个，因此在管程中设置了多个条件变量，对这些条件变量的访问只能在管程中进行。<br>管程中每个条件变量都需予以说明，形式为：<code>condition x</code>。对其的操作只有<code>wait</code>和<code>signal</code>，其含义是：</p><ol><li><code>x.wait</code>：正在调用管程的进程因x条件需要被阻塞或挂起，则调用<code>x.wait</code>将自己插入到x条件的等待队列上，并释放管程，知道x条件发生变化。此时其它进程可以使用该管程。</li><li><code>x.signal</code>： 正在调用管程的进程发现x条件发生了变化，则调用<code>x.signal</code>，重新启动一个因x条件而阻塞或挂起的进程，如果存在多个这样的进程，则选择其中的一个，如果没有，继续执行原进程，不产生任何结果。（与信号量的signal不同，没有s=s+1的操作）</li></ol><h1 id="3-2-进程同步的经典问题"><a href="#3-2-进程同步的经典问题" class="headerlink" title="3.2 进程同步的经典问题"></a>3.2 进程同步的经典问题</h1><h2 id="3-2-1-生产者-消费者问题"><a href="#3-2-1-生产者-消费者问题" class="headerlink" title="3.2.1 生产者-消费者问题"></a>3.2.1 生产者-消费者问题</h2><h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>有一群生产者进程在生产产品，并将这些产品提供给消费者进程去消费。为使生产者进程与消费者进程能并发执行，在两者之间设置了一个大小为n的缓冲区，生产者进程将其所产生的产品放入缓冲区中；消费者可从缓冲区中取走产品去消费。他们之间必须保持同步，也就是既不允许消费者进程到一个空缓冲区去取产品，也不允许生产者进程向一个已装满产品且尚未被取走的缓冲区中投放产品。<br><img src="https://blog-1255876459.cos.ap-chengdu.myqcloud.com/2019/07/31/ProducerConsumerProblem.jpg" alt="ProducerConsumerProble"></p><h3 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h3><p>需要注意的几点：</p><ul><li>在缓冲区为空时，消费者不能再进行消费</li><li>在缓冲区已满时，生产者不能再进行生产</li><li>当一个线程进行生产或消费时，其余线程不能再进行生产或消费</li></ul><h3 id="3-伪代码"><a href="#3-伪代码" class="headerlink" title="3. 伪代码"></a>3. 伪代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var items = <span class="number">0</span>, space = <span class="number">10</span>, mutex = <span class="number">1</span>;</span><br><span class="line">var in = <span class="number">0</span>, out = <span class="number">0</span>;</span><br><span class="line">item buf[<span class="number">10</span>] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">producer &#123;</span><br><span class="line">    <span class="keyword">while</span>( <span class="literal">true</span> ) &#123;</span><br><span class="line">        wait( space );  <span class="comment">// 等待缓冲区有空闲位置， 在使用PV操作时，条件变量需要在互斥锁之前</span></span><br><span class="line">        wait( mutex );  <span class="comment">// 保证在product时不会有其他线程访问缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// product</span></span><br><span class="line">        buf.push( item, in );  <span class="comment">// 将新资源放到buf[in]位置 </span></span><br><span class="line">        in = ( in + <span class="number">1</span> ) % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        signal( mutex );  <span class="comment">// 唤醒的顺序可以不同</span></span><br><span class="line">        signal( items );  <span class="comment">// 通知consumer缓冲区有资源可以取走</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer &#123;</span><br><span class="line">    <span class="keyword">while</span>( <span class="literal">true</span> ) &#123;</span><br><span class="line">        wait( items );  <span class="comment">// 等待缓冲区有资源可以使用</span></span><br><span class="line">        wait( mutex );  <span class="comment">// 保证在consume时不会有其他线程访问缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// consume</span></span><br><span class="line">        buf.pop( out );  <span class="comment">// 将buf[out]位置的的资源取走</span></span><br><span class="line">        out = ( out + <span class="number">1</span> ) % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        signal( mutex );  <span class="comment">// 唤醒的顺序可以不同</span></span><br><span class="line">        signal( space );  <span class="comment">// 通知缓冲区有空闲位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能将线程里两个<code>wait</code>的顺序调换否则会出现死锁。例如(调换后)，将<code>consumer</code>的两个<code>wait</code>调换，在<code>producer</code>发出<code>signal</code>信号后，如果<code>producer</code>线程此时再次获得运行机会，执行完了<code>wait(space)</code>，此时，另一个<code>consumer</code>线程获得运行机会，执行了<code>wait(mutex)</code>，如果此时缓冲区为空，那么<code>consumer</code>将会阻塞在<code>wait(items)</code>，而<code>producer</code>也会因为无法获得锁的所有权所以阻塞在<code>wait(mutex)</code>，这样两个线程都在阻塞，也就造成了死锁。</p><h2 id="3-2-2-哲学家进餐问题"><a href="#3-2-2-哲学家进餐问题" class="headerlink" title="3.2.2 哲学家进餐问题"></a>3.2.2 哲学家进餐问题</h2><h3 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>有五位哲学家共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五支筷子。他们的生活的方式是交替的进行思考和进餐：平时，一个哲学家进行思考，饥饿时便视图取其左右离他最近的筷子，只有在他拿到两只筷子时才能进餐，进餐完毕，放下筷子继续思考。</p><h3 id="2-问题分析-1"><a href="#2-问题分析-1" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h3><ul><li>只有拿到两只筷子时，哲学家才能吃饭。</li><li>如果筷子已被别人拿走，则必须等别人吃完之后才能拿到筷子。</li><li>任一哲学家在自己未拿到两只筷子吃完饭前，不会放下手中已经拿到的筷子</li></ul><h3 id="3-伪代码-1"><a href="#3-伪代码-1" class="headerlink" title="3. 伪代码"></a>3. 伪代码</h3><p>至多只允许四个哲学家同时进餐，以保证至少有一个哲学家能够进餐，最终总会释放出他所使用过的两支筷子，从而可使更多的哲学家进餐。定义信号量count，只允许4个哲学家同时进餐，这样就能保证至少有一个哲学家可以就餐。<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore count=<span class="number">4</span>; <span class="comment">// 设置一个count，最多有四个哲学家可以进来</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">think();</span><br><span class="line">wait(count); <span class="comment">//请求进入房间进餐 当count为0时 不能允许哲学家再进来了</span></span><br><span class="line">wait(chopstick[i]); <span class="comment">//请求左手边的筷子</span></span><br><span class="line">wait(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">//请求右手边的筷子</span></span><br><span class="line">eat();</span><br><span class="line">signal(chopstick[i]); <span class="comment">//释放左手边的筷子</span></span><br><span class="line">signal(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">//释放右手边的筷子</span></span><br><span class="line">signal(count); <span class="comment">//离开饭桌释放信号量</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-2-3-读者-写者问题"><a href="#3-2-3-读者-写者问题" class="headerlink" title="3.2.3 读者-写者问题"></a>3.2.3 读者-写者问题</h2><h3 id="1-问题描述-2"><a href="#1-问题描述-2" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>一个数据文件或记录可被多个进程共享，我们把只要求读该文件的进程称为“Reader进程”，其它进程则称为“Writer进程”。允许多个进程同时读一个共享对象，因为读操作不会使数据文件混乱。但不允许一个Writer进程和其它Reader进程或Writer进程同时访问共享对象，这样很有可能造成共享数据混乱。</p><h3 id="2-问题分析-2"><a href="#2-问题分析-2" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h3><ul><li>允许多个Reader进程同时操作一个共享对象</li><li>不允许Writer进程和其它进程同时操作一个共享对象</li></ul><h3 id="3-伪代码-2"><a href="#3-伪代码-2" class="headerlink" title="3. 伪代码"></a>3. 伪代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">semaphore rmutex = <span class="number">1</span>,wmutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> readcount = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">wait(rmutex);</span><br><span class="line"><span class="keyword">if</span>(readcount==<span class="number">0</span>) wait(wmutex);</span><br><span class="line">readcount++;</span><br><span class="line">signal(rmutex);</span><br><span class="line">···</span><br><span class="line">perform read operation;</span><br><span class="line">···</span><br><span class="line">wait（rmutex）；</span><br><span class="line"><span class="keyword">if</span>(readcount==<span class="number">0</span>) signal(wmutex);</span><br><span class="line">readcount--;</span><br><span class="line">signal(rmutex);</span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">wait(wmutex);</span><br><span class="line">perfrom write operation;</span><br><span class="line">signal(wmutex); </span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android网络请求3--解析OkHttp源码</title>
      <link href="/posts/151ac78a.html"/>
      <url>/posts/151ac78a.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-OkHttp简介"><a href="#1-OkHttp简介" class="headerlink" title="1. OkHttp简介"></a>1. OkHttp简介</h1><p><code>okhttp</code>是一个第三方类库，用于android中请求网络。</p><p>这是一个开源项目,是安卓端最火热的轻量级框架,由移动支付Square公司贡献。用于替代因移除了<code>HttpClient</code>而导致没用的<code>Volley</code>。</p><p>目前更多人选择了<code>Retrofit</code>。</p><a id="more"></a><h1 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h1><blockquote><p>本文对OkHttp的探讨全部基于目前的最新版OkHttp:4.0.1，而这个版本作者已经使用kotlin对源码进行了重写，所以有些小伙伴可能阅读稍微有点问题，但是别担心，本文中所涉及的源码阅读起来基本上和Java一样，所以请不会kotlin的小伙伴还是耐心看下去，不太懂的语法就百度下，同时我也会对某些语法作注释</p></blockquote><h2 id="2-1-OkHttp请求流程"><a href="#2-1-OkHttp请求流程" class="headerlink" title="2.1 OkHttp请求流程"></a>2.1 OkHttp请求流程</h2><h3 id="2-1-1-从请求处理开始分析"><a href="#2-1-1-从请求处理开始分析" class="headerlink" title="2.1.1 从请求处理开始分析"></a>2.1.1 从请求处理开始分析</h3><p>我们无论在使用<code>OkHttp</code>进行什么请求的时候都会创建<code>OkHttpClient</code>对象并调用他的<code>newCall()</code>方法，那我们就从这个方法看起：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newCall</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Call &#123;</span><br><span class="line"><span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, forWebSocket = <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到返回了一个<code>RealCall</code>对象，所以也就意味着我们使用<code>OkHttpClient</code>对象调用的<code>execute()</code>操作实际上是<code>RealCall</code>的<code>execute()</code>操作，那我们就来看<code>RealCall</code>的<code>execute()</code>方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 添加同步锁</span></span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// check()是kotlin特有的一个方法，他本质上就是一个if，</span></span><br><span class="line">        <span class="comment">// 但是当他的判断语句是false的话，</span></span><br><span class="line">        <span class="comment">// 他就会抛出一个IllegalStateException异常，异常的内容就是后面的语句</span></span><br><span class="line">        check(!executed) &#123; <span class="string">"Already Executed"</span> &#125;</span><br><span class="line">        executed = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// executed是一个布尔值，他的作用就是判断是不是执行过了，</span></span><br><span class="line">        <span class="comment">// 如果执行过了还执行了这个方法的话就抛异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// transmitter用于连接OKHTTP的应用程序和网络层，不用多管</span></span><br><span class="line">    transmitter.timeoutEnter()</span><br><span class="line">    transmitter.callStart()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块又调用了<code>client.dispatcher</code>，然后找回去找到<code>OkHttpClient</code>的<code>dispatcher</code>对象，发现他就是<code>Dispatcher</code>类的一个对象，接着我们继续看<code>Dispatcher</code>类。</p><h3 id="2-1-2-Dispatcher任务调度"><a href="#2-1-2-Dispatcher任务调度" class="headerlink" title="2.1.2 Dispatcher任务调度"></a>2.1.2 Dispatcher任务调度</h3><p>进入<code>Dispatcher</code>类，我们可以看到如下成员变量定义:</p><blockquote><p>注：kotlin中一个成员变量的@get和@set分别对应了Java中get和set方法，所以这块我没有完完全全复制粘贴到这，我只取了定义部分</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大并发请求数</span></span><br><span class="line"><span class="keyword">var</span> maxRequests = <span class="number">64</span></span><br><span class="line"><span class="comment">// 每个主机的最大请求数</span></span><br><span class="line"><span class="keyword">var</span> maxRequestsPerHost = <span class="number">5</span></span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="keyword">val</span> executorService: ExecutorService</span><br><span class="line"><span class="comment">// 将要运行的异步请求队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"><span class="comment">// 正在运行的异步请求队队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> runningAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"><span class="comment">// 正在运行的同步请求队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> runningSyncCalls = ArrayDeque&lt;RealCall&gt;()</span><br></pre></td></tr></table></figure><p>接下来我们看看<code>Dispatcher</code>的构造方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主构造方法，没写具体实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> <span class="keyword">constructor</span></span>() &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(executorService: ExecutorService) : <span class="keyword">this</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.executorServiceOrNull = executorService</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到他将传进来的<code>executorService</code>传给了<code>executorServiceOrNull</code>，那我们来看看<code>executorServiceOrNull</code>的定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// executorServiceOrNull这个应该是因为kotlin的空安全检查特性而定义的，本质上就是executorService</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> executorServiceOrNull: ExecutorService? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@get:Synchronized</span></span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">"executorService"</span>) <span class="keyword">val</span> executorService: ExecutorService</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (executorServiceOrNull == <span class="literal">null</span>) &#123;</span><br><span class="line">            executorServiceOrNull = ThreadPoolExecutor(<span class="number">0</span>, <span class="built_in">Int</span>.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                SynchronousQueue(), threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="literal">false</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> executorServiceOrNull!!</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以看到<code>executorService</code>的<code>set</code>方法，就是创建了一个线程池。再结合他有两个构造器就知道：如果没有给<code>Dispatcher</code>传入一个线程池他就会自己创建一个线程池。这个线程池适合执行大量且耗时较少的任务。</p><p>构造器我们看完了，我们就来看他的<code>enqueue()</code>方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        readyAsyncCalls.add(call)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span></span><br><span class="line">        <span class="comment">// the same host.</span></span><br><span class="line">        <span class="keyword">if</span> (!call.<span class="keyword">get</span>().forWebSocket) &#123;</span><br><span class="line">            <span class="keyword">val</span> existingCall = findExistingCallWithHost(call.host())</span><br><span class="line">            <span class="keyword">if</span> (existingCall != <span class="literal">null</span>)call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    promoteAndExecute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来一个请求就把他添加到就绪请求队列中去，然后就来判断<code>forWebSocket</code>这个属性。看到这个属性我还迷了下，有点搞不懂她是干嘛的，然后经过我的一番搜索后，发现原来<code>OkHttp</code>还可以进行<code>WebSocket</code>通信，而这个属性就是为<code>WebSocket</code>通信准备的。于是我就到<code>RealCall</code>里面找在哪儿定义了这个属性了，然后我就发现了在<code>RealCall</code>的<code>newRealCall()</code>方法这块，这个方法传入的参数中有一个<code>Boolean</code>值名字就叫<code>forWebSocket</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">newRealCall</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        client: <span class="type">OkHttpClient</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        originalRequest: <span class="type">Request</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        forWebSocket: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: RealCall &#123;</span><br><span class="line">        <span class="comment">// Safely publish the Call instance to the EventListener.</span></span><br><span class="line">        <span class="keyword">return</span> RealCall(client, originalRequest, forWebSocket).apply &#123;</span><br><span class="line">            transmitter = Transmitter(client, <span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道大家有没有印象，咱们在上面说过，执行<code>OkHttpClient.newCall()</code>方法实际上是返回了一个<code>RealCall</code>对象，于是在那找到了这个的答案，<code>forWebSocket=false</code><br>所以说这个<code>if</code>咱们不用管，直接看<code>promoteAndExecute()</code>方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 不知道大家还记不记得咱们之前说的kotlin里面的check()语法，</span></span><br><span class="line">    <span class="comment">// 这个和check也一样，只不过抛出的是AssertionError异常</span></span><br><span class="line">    assert(!Thread.holdsLock(<span class="keyword">this</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mutableListOf是kotlin里面的可变list集合</span></span><br><span class="line">    <span class="keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">    <span class="keyword">val</span> isRunning: <span class="built_in">Boolean</span></span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> i = readyAsyncCalls.iterator()</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">val</span> asyncCall = i.next()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (runningAsyncCalls.size &gt;= <span class="keyword">this</span>.maxRequests) <span class="keyword">break</span> <span class="comment">// 最大容量</span></span><br><span class="line">                <span class="keyword">if</span> (asyncCall.callsPerHost().<span class="keyword">get</span>() &gt;= <span class="keyword">this</span>.maxRequestsPerHost) <span class="keyword">continue</span> <span class="comment">// 主机最大容量</span></span><br><span class="line"></span><br><span class="line">                i.remove()</span><br><span class="line">                asyncCall.callsPerHost().incrementAndGet()</span><br><span class="line">                executableCalls.add(asyncCall)</span><br><span class="line">                runningAsyncCalls.add(asyncCall)</span><br><span class="line">            &#125;</span><br><span class="line">        isRunning = runningCallsCount() &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">        <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">        asyncCall.executeOn(executorService)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isRunning</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将已就绪队列遍历一遍，判断正在运行的数量是不是大于定义的最大请求数，如果大于的话直接退出循环；如果不大于则在判断这个请求的主机请求数是不是大于定义的每个主机最大请求数，如果大于就跳过这个请求换下一个请求；不大于就把它调入正在运行的请求队列里面，直到遍历完成。然后判断还有没有正在运行的请求，如果有就<code>isRunning</code>置<code>true</code>。接着再取出<code>executableCalls</code>里的每一个元素，然后执行<code>executteOn()</code>方法。我们继续来看<code>AsyncCall</code>的<code>executeOn()</code>方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">executeOn</span><span class="params">(executorService: <span class="type">ExecutorService</span>)</span></span> &#123;</span><br><span class="line">    assert(!Thread.holdsLock(client.dispatcher))</span><br><span class="line">    <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">this</span>)</span><br><span class="line">        success = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: RejectedExecutionException) &#123;</span><br><span class="line">        <span class="keyword">val</span> ioException = InterruptedIOException(<span class="string">"executor rejected"</span>)</span><br><span class="line">        ioException.initCause(e)</span><br><span class="line">        transmitter.noMoreExchanges(ioException)</span><br><span class="line">        responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, ioException)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            client.dispatcher.finished(<span class="keyword">this</span>) <span class="comment">// This call is no longer running!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码就是在执行线程池中的线程，如果成功执行就将<code>success</code>置<code>true</code>，如果不成功，则抛异常并返回给<code>responseCallback</code>的<code>onFailure()</code>方法。并且如果没有成功执行也就是<code>success</code>为<code>false</code>，那么在<code>finally</code>中就会执行<code>client.dispatcher.finished()</code>方法:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">finished</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">    call.callsPerHost().decrementAndGet()</span><br><span class="line">    finished(runningAsyncCalls, call)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个方法先将传入的<code>AsyncCall</code>的<code>callsPerHost</code>给减1，然后再调用了<code>finished()</code>方法，我们再来看这个<code>finished()</code>方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">finished</span><span class="params">(calls: <span class="type">Deque</span>&lt;<span class="type">T</span>&gt;, call: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> idleCallback: Runnable?</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>)</span><br><span class="line">        idleCallback = <span class="keyword">this</span>.idleCallback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> isRunning = promoteAndExecute()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">        idleCallback.run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他讲此次请求从<code>runningAsyncCalls</code>中移除，然后执行了<code>promoteAndExecute()</code>方法，咱们在上面说过这个方法，他的返回值就是判断当前这个运行队列中还有没有请求，如果还有就返回<code>true</code>，没有就<code>false</code>。接着一个<code>if</code>，判断<code>isRunning</code>和<code>idleCallback</code>的，那么如果当前这个请求还没有执行的话，就调用<code>run()</code>方法执行当前请求。这样每个请求都执行完毕了。<br>那我们再来看看他的<code>run()</code>方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">      threadName(<span class="string">"OkHttp <span class="subst">$&#123;redactedUrl()&#125;</span>"</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> signalledCallback = <span class="literal">false</span></span><br><span class="line">            transmitter.timeoutEnter()</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> response = getResponseWithInterceptorChain()</span><br><span class="line">                signalledCallback = <span class="literal">true</span></span><br><span class="line">                responseCallback.onResponse(<span class="keyword">this</span><span class="symbol">@RealCall</span>, response)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">                <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">                    <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">                    Platform.<span class="keyword">get</span>().log(INFO, <span class="string">"Callback failure for <span class="subst">$&#123;toLoggableString()&#125;</span>"</span>, e)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块调用了一个<code>getResponseWithInterceptorChain()</code>方法，并返回了<code>response</code>，并将它返回给了<code>responseCallback.onResponse()</code>方法。如果失败了就将结果返回给<code>responseCallback.onFailure()</code>方法。最后调用<code>client.dispatcher.finished()</code>方法。</p><h3 id="2-1-3-Interceptor拦截器"><a href="#2-1-3-Interceptor拦截器" class="headerlink" title="2.1.3 Interceptor拦截器"></a>2.1.3 Interceptor拦截器</h3><h4 id="2-1-3-1-getResponseWithInterceptorChain-方法"><a href="#2-1-3-1-getResponseWithInterceptorChain-方法" class="headerlink" title="2.1.3.1 getResponseWithInterceptorChain()方法"></a>2.1.3.1 getResponseWithInterceptorChain()方法</h4><p>首先我们看看<code>getResponseWithInterceptorChain()</code>方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">    interceptors += client.interceptors</span><br><span class="line">    interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">    interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">    interceptors += CacheInterceptor(client.cache)</span><br><span class="line">    interceptors += ConnectInterceptor</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        interceptors += client.networkInterceptors</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> chain = RealInterceptorChain(interceptors, transmitter, <span class="literal">null</span>, <span class="number">0</span>, originalRequest, <span class="keyword">this</span>,</span><br><span class="line">        client.connectTimeoutMillis, client.readTimeoutMillis, client.writeTimeoutMillis)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> calledNoMoreExchanges = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> response = chain.proceed(originalRequest)</span><br><span class="line">        <span class="keyword">if</span> (transmitter.isCanceled) &#123;</span><br><span class="line">            response.closeQuietly()</span><br><span class="line">            <span class="keyword">throw</span> IOException(<span class="string">"Canceled"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        calledNoMoreExchanges = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">throw</span> transmitter.noMoreExchanges(e) <span class="keyword">as</span> Throwable</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">            transmitter.noMoreExchanges(<span class="literal">null</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先就创建了一大堆的连接器并添加到<code>interceptors</code>集合中。然后创建了一个<code>RealInterceptorChain</code>对象，并调用了他的<code>proceed()</code>方法，接着主要目的就是讲<code>proceed()</code>返回的<code>response</code>给返回去。<br>那我们就来看看<code>RealInterceptorChain</code>的<code>proceed()</code>方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">return</span> proceed(request, transmitter, exchange)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="type">Request</span>, transmitter: <span class="type">Transmitter</span>, exchange: <span class="type">Exchange</span>?)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size) <span class="keyword">throw</span> AssertionError()</span><br><span class="line"></span><br><span class="line">    calls++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></span><br><span class="line">    check(<span class="keyword">this</span>.exchange == <span class="literal">null</span> || <span class="keyword">this</span>.exchange.connection()!!.supportsUrl(request.url)) &#123;</span><br><span class="line">        <span class="string">"network interceptor <span class="subst">$&#123;interceptors[index - <span class="number">1</span>]&#125;</span> must retain the same host and port"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></span><br><span class="line">    check(<span class="keyword">this</span>.exchange == <span class="literal">null</span> || calls &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="string">"network interceptor <span class="subst">$&#123;interceptors[index - <span class="number">1</span>]&#125;</span> must call proceed() exactly once"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the next interceptor in the chain.</span></span><br><span class="line">    <span class="keyword">val</span> next = RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">        index + <span class="number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout)</span><br><span class="line">    <span class="keyword">val</span> interceptor = interceptors[index]</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Suppress(<span class="meta-string">"USELESS_ELVIS"</span>)</span></span><br><span class="line">    <span class="keyword">val</span> response = interceptor.intercept(next) ?: <span class="keyword">throw</span> NullPointerException(</span><br><span class="line">        <span class="string">"interceptor <span class="variable">$interceptor</span> returned null"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Confirm that the next interceptor made its required call to chain.proceed().</span></span><br><span class="line">    check(exchange == <span class="literal">null</span> || index + <span class="number">1</span> &gt;= interceptors.size || next.calls == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="string">"network interceptor <span class="variable">$interceptor</span> must call proceed() exactly once"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    check(response.body != <span class="literal">null</span>) &#123; <span class="string">"interceptor <span class="variable">$interceptor</span> returned a response with no body"</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先就是一个<code>index</code>，<code>index</code>是<code>RealInterceptorChain</code>构造器中传入的参数，她是第四个参数，所以我们看<code>getResponseWithInterceptorChain()</code>方法中创建<code>RealInterceptorChain</code>对象时构造器的第四个传入的值为0。然后判断<code>index</code>的值是不是大于<code>interceptors</code>的大小，如果大于就抛异常，否则就继续一顿检查！！！然后再创建<code>RealInterceptorChain</code>对象，此时创建的对象传入的<code>index</code>为此时的<code>index+1</code>，然后再调用<code>interceptor</code>的<code>intercept()</code>方法，并返回<code>response</code>。<code>interceptor</code>的<code>intercept()</code>作用是当存在多个拦截器时都会在上面代码注释1处阻塞，并等待下一个拦截器的调用返回。</p><h4 id="2-1-3-2-Interceptor源码"><a href="#2-1-3-2-Interceptor源码" class="headerlink" title="2.1.3.2 Interceptor源码"></a>2.1.3.2 Interceptor源码</h4><p>那现在我们再来讲几个重要的拦截器吧。<br><code>OkHttp</code>中<code>Interceptor</code>的实现类有：</p><ol><li><code>ConnectInterceptor</code>：连接拦截器。 </li><li><code>CallServerInterceptor</code>：请求服务器拦截器 </li><li><code>CacheInterceptor</code>：缓存拦截器 </li><li><code>BridgeInterceptor</code>：桥梁拦截器。 </li></ol><p>其中较为重要的就是<code>ConnectInterceptor</code>和<code>CallServerInterceptor</code>，那我们来看看这两个。</p><h5 id="2-1-3-2-1-ConnectInterceptor"><a href="#2-1-3-2-1-ConnectInterceptor" class="headerlink" title="2.1.3.2.1 ConnectInterceptor"></a>2.1.3.2.1 ConnectInterceptor</h5><p>这个类主要用来实现网络请求连接。我们来看下他的<code>intercept</code>方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">val</span> request = realChain.request()</span><br><span class="line">    <span class="keyword">val</span> transmitter = realChain.transmitter()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">    <span class="keyword">val</span> doExtensiveHealthChecks = request.method != <span class="string">"GET"</span></span><br><span class="line">    <span class="keyword">val</span> exchange = transmitter.newExchange(chain, doExtensiveHealthChecks)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, transmitter, exchange)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法先将传入的<code>chain</code>对象造型成了<code>RealInterceptorChain</code>的对象，这个类我们在上面提到过，然后调用他的<code>response()</code>和<code>transmitter()</code>方法，分别得到当前<code>chain</code>的<code>response</code>和<code>transmitter</code>。然后执行了<code>request</code>的<code>method()</code>方法，判断<code>request</code>的类型是不是<code>GET</code>，如果是<code>doExtensiveHealthChecks</code>就为<code>false</code>，否则为<code>true</code>，接着把<code>doExtensiveHealthChecks</code>传入<code>transmitter的newExchange()</code>方法中去，这个方法我们等会再说，然后再调用了<code>proceed()</code>方法，这个方法我们在上面说过。</p><h5 id="2-1-3-2-2-CallServerInterceptor"><a href="#2-1-3-2-2-CallServerInterceptor" class="headerlink" title="2.1.3.2.2 CallServerInterceptor"></a>2.1.3.2.2 CallServerInterceptor</h5><p>这个类是网络请求的本质。它的<code>intercept</code>方法源码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">val</span> exchange = realChain.exchange()</span><br><span class="line">    <span class="keyword">val</span> request = realChain.request()</span><br><span class="line">    <span class="keyword">val</span> requestBody = request.body</span><br><span class="line">    <span class="keyword">val</span> sentRequestMillis = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入请求头</span></span><br><span class="line">    exchange.writeRequestHeaders(request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> responseHeadersStarted = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> responseBuilder: Response.Builder? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 写入请求体信息</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果请求上有“expect:100 continue”头</span></span><br><span class="line">        <span class="comment">// 请等待“http/1.1 100 continue”响应，然后再传输请求主体.</span></span><br><span class="line">        <span class="comment">// 如果我们没有得到，返回我们得到的（例如4xx响应），而不传输请求体。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"100-continue"</span>.equals(request.header(<span class="string">"Expect"</span>), ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">            exchange.flushRequest()</span><br><span class="line">            responseHeadersStarted = <span class="literal">true</span></span><br><span class="line">            exchange.responseHeadersStart()</span><br><span class="line">            responseBuilder = exchange.readResponseHeaders(<span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (requestBody.isDuplex()) &#123;</span><br><span class="line">                <span class="comment">// 准备一个双工主体，以便应用程序稍后可以发送请求主体。</span></span><br><span class="line">                exchange.flushRequest()</span><br><span class="line">                <span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">true</span>).buffer()</span><br><span class="line">                requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果满足“expect:100 continue”预期，则编写请求正文。</span></span><br><span class="line">                <span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">false</span>).buffer()</span><br><span class="line">                requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">                bufferedRequestBody.close()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            exchange.noRequestBody()</span><br><span class="line">            <span class="keyword">if</span> (!exchange.connection()!!.isMultiplexed) &#123;</span><br><span class="line">                <span class="comment">// 如果不满足“expect:100 continue”的要求，请防止重用HTTP/1连接。</span></span><br><span class="line">                <span class="comment">// 否则，我们仍然有义务传输请求主体以使连接保持一致状态。</span></span><br><span class="line">                exchange.noNewExchangesOnConnection()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        exchange.noRequestBody()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束请求</span></span><br><span class="line">    <span class="keyword">if</span> (requestBody == <span class="literal">null</span> || !requestBody.isDuplex()) &#123;</span><br><span class="line">        exchange.finishRequest()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!responseHeadersStarted) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">        responseBuilder = exchange.readResponseHeaders(<span class="literal">false</span>)!!</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取响应头信息</span></span><br><span class="line">    <span class="keyword">var</span> response = responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection()!!.handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">var</span> code = response.code</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="comment">// 服务器发送了一个100继续，即使我们没有请求。</span></span><br><span class="line">        <span class="comment">// 再次尝试读取实际响应</span></span><br><span class="line">        response = exchange.readResponseHeaders(<span class="literal">false</span>)!!</span><br><span class="line">            .request(request)</span><br><span class="line">            .handshake(exchange.connection()!!.handshake())</span><br><span class="line">            .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build()</span><br><span class="line">        code = response.code</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exchange.responseHeadersEnd(response)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// openResponseBody 获取响应体信息</span></span><br><span class="line">    response = <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">        <span class="comment">// 连接正在升级，但我们需要确保拦截器看到非空的响应主体。</span></span><br><span class="line">        response.newBuilder()</span><br><span class="line">            .body(EMPTY_RESPONSE)</span><br><span class="line">            .build()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response.newBuilder()</span><br><span class="line">                .body(exchange.openResponseBody(response))</span><br><span class="line">                .build()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"close"</span>.equals(response.request.header(<span class="string">"Connection"</span>), ignoreCase = <span class="literal">true</span>) ||</span><br><span class="line">        <span class="string">"close"</span>.equals(response.header(<span class="string">"Connection"</span>), ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">            exchange.noNewExchangesOnConnection()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body?.contentLength() ?: -<span class="number">1L</span> &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ProtocolException(</span><br><span class="line">                <span class="string">"HTTP <span class="variable">$code</span> had non-zero Content-Length: <span class="subst">$&#123;response.body?.contentLength()&#125;</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回一个响应</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体过程可以看代码中的注释，它主要是向服务器发送请求数据和接受服务器返回的数据。</p><h3 id="2-1-4-Transmiter"><a href="#2-1-4-Transmiter" class="headerlink" title="2.1.4 Transmiter"></a>2.1.4 Transmiter</h3><p><code>Transmitter</code>类是<code>OkHttp</code>的应用层和网络层的一个桥梁类。</p><p>我们先来看看该类的初始化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transmitter</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> client: OkHttpClient,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> call: Call</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> connectionPool: RealConnectionPool = client.connectionPool.delegate</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> eventListener: EventListener = client.eventListenerFactory.create(call)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> timeout = <span class="keyword">object</span> : AsyncTimeout() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">timedOut</span><span class="params">()</span></span> &#123;</span><br><span class="line">            cancel()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.apply &#123;</span><br><span class="line">        timeout(client.callTimeoutMillis.toLong(), MILLISECONDS)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>Transmitter</code>主要的一些成员变量就这些，首先构造器中传入了两个参数，一个<code>OkHttpClient</code>，一个<code>Call</code>。然后又创建了一个连接池<code>connectionPool</code>，还有一个监听器，我们可以通过扩展这个类来监听程序的<code>HTTP</code>的调用数量、大小和持续时间。</p><h3 id="2-1-5-RealConnection"><a href="#2-1-5-RealConnection" class="headerlink" title="2.1.5 RealConnection"></a>2.1.5 RealConnection</h3><p>我们先看看他的一些属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealConnection</span></span>(</span><br><span class="line">    <span class="keyword">val</span> connectionPool: RealConnectionPool,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> route: Route</span><br><span class="line">) : Http2Connection.Listener(), Connection &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下字段由connect（）初始化，从不重新分配。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 底层socket</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> rawSocket: Socket? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用层套接字。如果此连接不使用SSL，则可以是[sslsocket]分层在[rawsocket]上，也可以是[rawsocket]本身。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 应用层socket</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> socket: Socket? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 握手</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> handshake: Handshake? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//  协议</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> protocol: Protocol? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// http2的连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> http2Connection: Http2Connection? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 与服务器交互的输入输出流</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> source: BufferedSource? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> sink: BufferedSink? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跟踪连接状态下的字段由连接池保护。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果为true，则不能在此连接上创建新的交换。一旦是true的，这总是true的。</span></span><br><span class="line"><span class="comment">     * 由[ConnectionPool]监视。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> noNewExchanges = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立可能由于所选路由而导致的流时出现问题的次数。由[ConnectionPool]保护。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> routeFailureCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> successCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> refusedStreamCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此连接可以承载的最大并发流数。</span></span><br><span class="line"><span class="comment">     * 如果“allocations.size（）&lt;allocationlimit”，则可以在此连接上创建新流。     </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> allocationLimit = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>接下来我们看看他的<code>connect()</code>方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    readTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    writeTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    pingIntervalMillis: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    connectionRetryEnabled: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    call: <span class="type">Call</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    eventListener: <span class="type">EventListener</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    check(protocol == <span class="literal">null</span>) &#123; <span class="string">"already connected"</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线路的选择</span></span><br><span class="line">    <span class="keyword">var</span> routeException: RouteException? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> connectionSpecs = route.address.connectionSpecs</span><br><span class="line">    <span class="keyword">val</span> connectionSpecSelector = ConnectionSpecSelector(connectionSpecs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (route.address.sslSocketFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ConnectionSpec.CLEARTEXT !<span class="keyword">in</span> connectionSpecs) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RouteException(UnknownServiceException(</span><br><span class="line">                <span class="string">"CLEARTEXT communication not enabled for client"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> host = route.address.url.host</span><br><span class="line">        <span class="keyword">if</span> (!Platform.<span class="keyword">get</span>().isCleartextTrafficPermitted(host)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RouteException(UnknownServiceException(</span><br><span class="line">                <span class="string">"CLEARTEXT communication to <span class="variable">$host</span> not permitted by network security policy"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Protocol.H2_PRIOR_KNOWLEDGE <span class="keyword">in</span> route.address.protocols) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RouteException(UnknownServiceException(</span><br><span class="line">                <span class="string">"H2_PRIOR_KNOWLEDGE cannot be used with HTTPS"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接开始</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果要求隧道模式，建立通道连接，通常不是这种</span></span><br><span class="line">            <span class="keyword">if</span> (route.requiresTunnel()) &#123;</span><br><span class="line">                connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener)</span><br><span class="line">                <span class="keyword">if</span> (rawSocket == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 我们无法连接隧道，但适当关闭了我们的资源。</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 一般都走这条逻辑了，实际上很简单就是socket的连接</span></span><br><span class="line">                connectSocket(connectTimeout, readTimeout, call, eventListener)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// https的建立</span></span><br><span class="line">            establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener)</span><br><span class="line">            eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">            socket?.closeQuietly()</span><br><span class="line">            rawSocket?.closeQuietly()</span><br><span class="line">            socket = <span class="literal">null</span></span><br><span class="line">            rawSocket = <span class="literal">null</span></span><br><span class="line">            source = <span class="literal">null</span></span><br><span class="line">            sink = <span class="literal">null</span></span><br><span class="line">            handshake = <span class="literal">null</span></span><br><span class="line">            protocol = <span class="literal">null</span></span><br><span class="line">            http2Connection = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">            eventListener.connectFailed(call, route.socketAddress, route.proxy, <span class="literal">null</span>, e)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (routeException == <span class="literal">null</span>) &#123;</span><br><span class="line">                routeException = RouteException(e)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                routeException.addConnectException(e)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> routeException</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (route.requiresTunnel() &amp;&amp; rawSocket == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> RouteException(ProtocolException(</span><br><span class="line">            <span class="string">"Too many tunnel connections attempted: <span class="variable">$MAX_TUNNEL_ATTEMPTS</span>"</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> http2Connection = <span class="keyword">this</span>.http2Connection</span><br><span class="line">    <span class="keyword">if</span> (http2Connection != <span class="literal">null</span>) &#123;</span><br><span class="line">        synchronized(connectionPool) &#123;</span><br><span class="line">            allocationLimit = http2Connection.maxConcurrentStreams()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先检查是否已经建立连接，如果已经建立就抛异常，没有的话就继续。接着就得到了<code>ConnectionSpecs</code>，然后根据他建立了一个<code>connectionSpecSelector</code>集合。接着判断是不是安全连接，也就是ssl连接，如果不是的话就判断了一些属性，先确定是不是明文然后再确定主机能不能接受明文操作。接着就开始连接，判断是不是要进行隧道通信，如果是就调用<code>connectTunnel()</code>建立隧道通信，如果不是就调用<code>connectSocket()</code>建立普通的通信。然后通过<code>establishProtocol()</code>建立协议。如果是<code>HTTP/2</code>就设置相关属性。</p><p>然后我们就来看看他具体如何实现的，先看看<code>connectSocket()</code>方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">connectSocket</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    readTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    call: <span class="type">Call</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    eventListener: <span class="type">EventListener</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> proxy = route.proxy</span><br><span class="line">    <span class="keyword">val</span> address = route.address</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据代理类型选择socket类型是代理还是直连</span></span><br><span class="line">    <span class="keyword">val</span> rawSocket = <span class="keyword">when</span> (proxy.type()) &#123;</span><br><span class="line">        Proxy.Type.DIRECT, Proxy.Type.HTTP -&gt; address.socketFactory.createSocket()!!</span><br><span class="line">        <span class="keyword">else</span> -&gt; Socket(proxy)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.rawSocket = rawSocket</span><br><span class="line"></span><br><span class="line">    eventListener.connectStart(call, route.socketAddress, proxy)</span><br><span class="line">    rawSocket.soTimeout = readTimeout</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 连接socket，之所以这样写是因为支持不同的平台</span></span><br><span class="line">        <span class="comment">// 里面实际上是  socket.connect(address, connectTimeout);</span></span><br><span class="line">        Platform.<span class="keyword">get</span>().connectSocket(rawSocket, route.socketAddress, connectTimeout)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: ConnectException) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ConnectException(<span class="string">"Failed to connect to <span class="subst">$&#123;route.socketAddress&#125;</span>"</span>).apply &#123;</span><br><span class="line">            initCause(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的Try/Catch块是一种避免Android 7.0崩溃的伪黑客方法</span></span><br><span class="line">    <span class="comment">// More details:</span></span><br><span class="line">    <span class="comment">// https://github.com/square/okhttp/issues/3245</span></span><br><span class="line">    <span class="comment">// https://android-review.googlesource.com/#/c/271775/</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 得到输入／输出流</span></span><br><span class="line">        source = rawSocket.source().buffer()</span><br><span class="line">        sink = rawSocket.sink().buffer()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (npe: NullPointerException) &#123;</span><br><span class="line">        <span class="keyword">if</span> (npe.message == NPE_THROW_WITH_NULL) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IOException(npe)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先先判断连接类型，如果是直连或者<code>HTTP</code>连接就直连，否则的话走<code>Socket</code>代理，然后通过<code>eventListener.connectStart()</code>方法创建连接，再设定超时-&gt;完成连接-&gt;创建用于I/O的<code>source</code>和<code>sink</code>。</p><p>我们接着再来看<code>connectTunnel()</code>方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">connectTunnel</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    readTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    writeTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    call: <span class="type">Call</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    eventListener: <span class="type">EventListener</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tunnelRequest: Request = createTunnelRequest()</span><br><span class="line">    <span class="keyword">val</span> url = tunnelRequest.url</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until MAX_TUNNEL_ATTEMPTS) &#123;</span><br><span class="line">        connectSocket(connectTimeout, readTimeout, call, eventListener)</span><br><span class="line">        tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url)</span><br><span class="line">            ?: <span class="keyword">break</span> <span class="comment">// 已成功创建隧道。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 代理决定在身份验证质询后关闭连接。</span></span><br><span class="line">        <span class="comment">// 我们需要创建一个新的连接，但这次需要使用身份验证凭据。</span></span><br><span class="line">        rawSocket?.closeQuietly()</span><br><span class="line">        rawSocket = <span class="literal">null</span></span><br><span class="line">        sink = <span class="literal">null</span></span><br><span class="line">        source = <span class="literal">null</span></span><br><span class="line">        eventListener.connectEnd(call, route.socketAddress, route.proxy, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大体就是先创建隧道请求，然后建立<code>socket</code>连接，再发送请求建立隧道。</p><h1 id="3-请求流程图"><a href="#3-请求流程图" class="headerlink" title="3. 请求流程图"></a>3. 请求流程图</h1><p>那我们最后来总结下</p><h2 id="3-1-同步请求是如何操作的？"><a href="#3-1-同步请求是如何操作的？" class="headerlink" title="3.1 同步请求是如何操作的？"></a>3.1 同步请求是如何操作的？</h2><p><img src="https://blog-1255876459.cos.ap-chengdu.myqcloud.com/2019/07/26/OkHttpSync.jpg" alt="OkHttpSyn"></p><h2 id="3-2-异步请求是如何操作的？"><a href="#3-2-异步请求是如何操作的？" class="headerlink" title="3.2 异步请求是如何操作的？"></a>3.2 异步请求是如何操作的？</h2><p><img src="https://blog-1255876459.cos.ap-chengdu.myqcloud.com/2019/07/26/OkHttpAsync.jpg" alt="OkHttpAsyn"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> kotlin </tag>
            
            <tag> 源码 </tag>
            
            <tag> OkHttp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android网络请求2--解析Volley源码</title>
      <link href="/posts/df8fd75e.html"/>
      <url>/posts/df8fd75e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文大篇幅参考<a href="https://www.jianshu.com/p/d8500e377f3e" target="_blank" rel="noopener">此篇文章</a>，大家可以结合两篇文章看一下</p></blockquote><h1 id="1-Volley简介"><a href="#1-Volley简介" class="headerlink" title="1. Volley简介"></a>1. Volley简介</h1><p>在很早以前，如果Android开发者想使用网络请求的话，必须自己通过<code>HttpClient</code>或者<code>HttpURLConnection</code>编写代码来访问。但是他两的用法还是很复杂的，如果不适当的封装的话，就会有很多多余代码甚至效率降低。所以当时出现了很多第三方网络通信框架，但是都是第三方的，而谷歌官方一直没有作为。<br>最终在2013年，谷歌终于意识到了问题，于是他们推出了一个官方的全新的网络框架——Volley。Volley它又能非常简单的进行HTTP通信，又能轻松加载网络上的图片。他的设计目的就是应对数据量不大但是频发的网络操作，但是对于下载等需要大数据量的网络操作，他就不太适合。</p><a id="more"></a><h1 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h1><h2 id="2-1-从RequestQueue入手"><a href="#2-1-从RequestQueue入手" class="headerlink" title="2.1 从RequestQueue入手"></a>2.1 从RequestQueue入手</h2><p>如果你使用Volley的话，就会发现Volley不管进行什么操作，首先第一步就是先创建RequestQueue对象。<br>所以我们就可以认定他为Volley的入口。<br>创建RequestQueue的方法是<code>RequestQueue mQueue = Volley.newRequestQueue(getApplicationContext());</code>,我们就看看<code>newRequestQueue</code>干了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, BaseHttpStack stack)</span> </span>&#123;</span><br><span class="line">    BasicNetwork network;</span><br><span class="line">    <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">            network = <span class="keyword">new</span> BasicNetwork(<span class="keyword">new</span> HurlStack());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在Android 2.3之前，HttpURLConnection是不可靠的。</span></span><br><span class="line">            <span class="comment">// 请参阅：http://android-developers.blogspot.com/2011/09/androids-http-clients.html</span></span><br><span class="line">            <span class="comment">// 在将来的某个时候，我们将把minsdkversion移到Android 2.2之上，</span></span><br><span class="line">            <span class="comment">// 并可以删除这个回退（连同所有ApacheHTTP代码）。            </span></span><br><span class="line">            String userAgent = <span class="string">"volley/0"</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String packageName = context.getPackageName();</span><br><span class="line">                PackageInfo info =</span><br><span class="line">             context.getPackageManager().getPackageInfo(packageName, <span class="comment">/* flags= */</span> <span class="number">0</span>);</span><br><span class="line">                    userAgent = packageName + <span class="string">"/"</span> + info.versionCode;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        network =</span><br><span class="line">                <span class="keyword">new</span> BasicNetwork(</span><br><span class="line">                        <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        network = <span class="keyword">new</span> BasicNetwork(stack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newRequestQueue(context, network);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法后，先查看Android版本是否大于等于2.3，如果大于则调用基于<code>HttpURLConnection</code>的<code>HurlStack</code>，否则调用基于<code>HttpClient</code>的<code>HttpClientStack</code>。接下来创建<code>BasicNetwork</code>并调用<code>newRequestQueue(context, network)</code>方，我们再来看看这个<code>newRequestQueue()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, Network network)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Context appContext = context.getApplicationContext();</span><br><span class="line">    <span class="comment">// 对缓存目录使用惰性供应商，以便可以在主线程上调用newRequestQueue（），</span></span><br><span class="line">    <span class="comment">// 而不会导致严格的模式冲突。    </span></span><br><span class="line">    DiskBasedCache.FileSupplier cacheSupplier =</span><br><span class="line">            <span class="keyword">new</span> DiskBasedCache.FileSupplier() &#123;</span><br><span class="line">                <span class="keyword">private</span> File cacheDir = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> File <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (cacheDir == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        cacheDir = <span class="keyword">new</span> File(appContext.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> cacheDir;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">    RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheSupplier), network);</span><br><span class="line">    queue.start();</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个方法主要为Volley创建了一个硬盘缓存<code>DiskBasedCache</code>，然后通过这个磁盘缓存和<code>Network</code>创建了一个<code>RequestQueue</code>对象，并调用了<code>start()</code>方法，接下来我们看下<code>start()</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stop(); </span><br><span class="line">    <span class="comment">// 确保当前运行的所有调度程序都已停止。</span></span><br><span class="line">    <span class="comment">// 创建缓存调度器并开始它。</span></span><br><span class="line">    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">    mCacheDispatcher.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建达到池大小的网络调度程序（和相应的线程）。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">        NetworkDispatcher networkDispatcher =</span><br><span class="line">                    <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery);</span><br><span class="line">        mDispatchers[i] = networkDispatcher;</span><br><span class="line">        networkDispatcher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CacheDispatcher</code>是一个缓存调度线程，并调用了<code>start()</code>方法。在循环中调用<code>NetworkDispatcher</code>的<code>start()</code>方法。<code>NetworkDispatcher</code>是网络调度线程，默认情况下<code>mDispatchers.length</code>为4，默认开启了4个调度线程，外加1个缓存调度线程，总共5个线程。<br>接下来Volley会创建各种<code>Request</code>，并调用<code>RequestQueue</code>的<code>add()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Request&lt;T&gt; <span class="title">add</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将请求标记为属于此队列，并将其添加到当前请求集。</span></span><br><span class="line">    request.setRequestQueue(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</span><br><span class="line">        <span class="comment">//mCurrentRequests是一个HashSet</span></span><br><span class="line">        mCurrentRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按添加的顺序处理请求。</span></span><br><span class="line">    request.setSequence(getSequenceNumber());</span><br><span class="line">    request.addMarker(<span class="string">"add-to-queue"</span>);</span><br><span class="line">    sendRequestEvent(request, RequestEvent.REQUEST_QUEUED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求是不可执行的，跳过缓存队列，然后直接进入网络。</span></span><br><span class="line">    <span class="keyword">if</span> (!request.shouldCache()) &#123;</span><br><span class="line">        mNetworkQueue.add(request);</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line">    mCacheQueue.add(request);</span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块地方的代码就很简单了，就是根据<code>request</code>的<code>shouldCache()</code>方法来返回<code>request</code>的<code>mShouldCache</code>属性来判断是否可以缓存，默认是可以的。如果能缓存，将此请求加入<code>mCacheQueue</code>队列，不再重复请求；不可以的话就将请求加入网络请求队列<code>mNetworkQueue</code>。</p><h2 id="2-2-CacheDispatcher缓存调度线程"><a href="#2-2-CacheDispatcher缓存调度线程" class="headerlink" title="2.2 CacheDispatcher缓存调度线程"></a>2.2 CacheDispatcher缓存调度线程</h2><p><code>RequestQueue</code>的<code>add()</code>方法并没有请求网络或者对缓存进行操作。当将请求添加到网络请求队 列或者缓存队列时，在后台的网络调度线程和缓存调度线程轮询各自的请求队列，若发现有请求任务则开 始执行。下面先看看缓存调度线程。</p><p>首先先来看看<code>CacheDispatcher</code>的<code>add()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) </span><br><span class="line">        VolleyLog.v(<span class="string">"start new dispatcher"</span>);</span><br><span class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">    <span class="comment">// Process.THREAD_PRIORITY_BACKGROUND默认值为10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行阻塞调用以初始化缓存。</span></span><br><span class="line">    mCache.initialize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            processRequest();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 可能被打断了，因为是时候要退出了。</span></span><br><span class="line">            <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            VolleyLog.e(</span><br><span class="line">                    <span class="string">"Ignoring spurious interrupt of CacheDispatcher thread; "</span></span><br><span class="line">                            + <span class="string">"use quit() to terminate it"</span>);</span><br><span class="line">            <span class="comment">// 忽略cachedispatcher线程的假中断；</span></span><br><span class="line">            <span class="comment">// 使用quit（）终止它</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块可以看出主要就是初始化了缓存队列，然后开了个死循环，一直调用<code>processRequest()</code>，我们来看看这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 从CacheQueue中取出一个可用的request</span></span><br><span class="line">    <span class="keyword">final</span> Request&lt;?&gt; request = mCacheQueue.take();</span><br><span class="line">    processRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">final</span> Request&lt;?&gt; request)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    request.addMarker(<span class="string">"cache-queue-take"</span>);</span><br><span class="line">    request.sendEvent(RequestQueue.RequestEvent.REQUEST_CACHE_LOOKUP_STARTED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//request如果被取消了，就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">            request.finish(<span class="string">"cache-discard-canceled"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Cache.Entry entry = mCache.get(request.getCacheKey());</span><br><span class="line">        <span class="comment">// 没有缓存就把request添加到NetworkQueue中</span></span><br><span class="line">        <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            request.addMarker(<span class="string">"cache-miss"</span>);</span><br><span class="line">            <span class="comment">// 没有缓存，并且等待队列中也没有此request，那么就直接加入到NetworkQueue中</span></span><br><span class="line">            <span class="keyword">if</span> (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">                mNetworkQueue.put(request);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果缓存过期了，也是一样把request添加到NetworkQueue中</span></span><br><span class="line">        <span class="keyword">if</span> (entry.isExpired()) &#123;</span><br><span class="line">            request.addMarker(<span class="string">"cache-hit-expired"</span>);</span><br><span class="line">            request.setCacheEntry(entry);</span><br><span class="line">            <span class="keyword">if</span> (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">                mNetworkQueue.put(request);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有缓存并且没有过期</span></span><br><span class="line">        request.addMarker(<span class="string">"cache-hit"</span>);</span><br><span class="line">        <span class="comment">// 根据缓存的内容解析</span></span><br><span class="line">        Response&lt;?&gt; response =</span><br><span class="line">                request.parseNetworkResponse(</span><br><span class="line">                        <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</span><br><span class="line">        request.addMarker(<span class="string">"cache-hit-parsed"</span>);</span><br><span class="line">        <span class="comment">// 是否需要更新</span></span><br><span class="line">        <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</span><br><span class="line">            <span class="comment">// 不需要更新，直接将结果调度到主线程</span></span><br><span class="line">            mDelivery.postResponse(request, response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</span><br><span class="line">            request.setCacheEntry(entry);</span><br><span class="line">            response.intermediate = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 判断是否有相同缓存键的任务在执行</span></span><br><span class="line">            <span class="keyword">if</span> (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">                <span class="comment">// 需要更新结果，先将结果调度到主线程，然后执行new runnable()&#123;&#125;</span></span><br><span class="line">                <span class="comment">// runnable中就是将request添加到NetworkQueue中，更新一下内容</span></span><br><span class="line">                mDelivery.postResponse(</span><br><span class="line">                        request,</span><br><span class="line">                        response,</span><br><span class="line">                        <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    mNetworkQueue.put(request);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                    <span class="comment">// Restore the interrupted status</span></span><br><span class="line">                                    Thread.currentThread().interrupt();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// request已经加入到mWaitingRequests中</span></span><br><span class="line">                <span class="comment">// 直接把结果调度到主线程</span></span><br><span class="line">                mDelivery.postResponse(request, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        request.sendEvent(RequestQueue.RequestEvent.REQUEST_CACHE_LOOKUP_FINISHED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在<code>processRequest</code>中可以看到有一个方法经常出现，那就是<code>mWaitingRequestManager.maybeAddToWaitingRequests(request)</code>，它的作用是判断当前这个<code>request</code>是否有存在相同缓存键的请求已经处于运行状态，如果有，那么就将这个<code>request</code>加入到一个等待队列中，等到相同缓存键的请求完成。</p><p>总结一下<code>CacheDispatcher</code>主要步骤：</p><ul><li>从<code>CacheQueue</code>中循环取出<code>request</code>；</li><li>如果缓存丢失，加入到<code>NetworkQueue</code>中；</li><li>如果缓存过期，加入到<code>NetworkQueue</code>中；</li><li>将缓存中的数据解析成<code>Response</code>对象；</li><li>如果不需要更新，直接将结果回调到主线程，回调操作等介绍完<code>NetworkDispatcher</code>之后一起深入剖析；</li><li>如果需要更新，先将结果回调到主线程，然后再将<code>request</code>加入到<code>NetworkQueue</code>中。</li></ul><p>下面来看看网络调度线程。</p><h2 id="2-3-NetWorkDispatcher网络调度线程"><a href="#2-3-NetWorkDispatcher网络调度线程" class="headerlink" title="2.3 NetWorkDispatcher网络调度线程"></a>2.3 NetWorkDispatcher网络调度线程</h2><p>NetworkDispatcher的run方法代码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            processRequest();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 我们可能被打断了，因为是时候退出了。</span></span><br><span class="line">            <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            VolleyLog.e(</span><br><span class="line">                    <span class="string">"Ignoring spurious interrupt of NetworkDispatcher thread; "</span></span><br><span class="line">                            + <span class="string">"use quit() to terminate it"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可以看出，<code>NetWordDispatch</code>和<code>CacheDispatch</code>非常类似。<br>他的<code>run()</code>方法和<code>CacheDispatch</code>的方法基本一样，这就不多做介绍，下面来看看他的<code>processRequest()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 从NetworkQueue中取出request</span></span><br><span class="line">    Request&lt;?&gt; request = mQueue.take();</span><br><span class="line">    processRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request&lt;?&gt; request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTimeMs = SystemClock.elapsedRealtime();</span><br><span class="line">    request.sendEvent(RequestQueue.RequestEvent.REQUEST_NETWORK_DISPATCH_STARTED);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        request.addMarker(<span class="string">"network-queue-take"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果request被取消了，那么就不执行此request</span></span><br><span class="line">        <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">            request.finish(<span class="string">"network-discard-cancelled"</span>);</span><br><span class="line">            request.notifyListenerResponseNotUsable();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addTrafficStatsTag(request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还记得这个mNetwork么，它就是Volley.newRequestQueue()方法里的BasicNetwork对象，一会我们来看看mNetwork.performRequest()方法是如何得到NetworkResponse的</span></span><br><span class="line">        NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br><span class="line">        request.addMarker(<span class="string">"network-http-complete"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// notModified是服务端返回304，hasHadResponseDelivered()是request已经回调过了</span></span><br><span class="line">        <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</span><br><span class="line">            request.finish(<span class="string">"not-modified"</span>);</span><br><span class="line">            request.notifyListenerResponseNotUsable();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将NetworkResponse解析成Response对象，在子线程中执行</span></span><br><span class="line">        Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</span><br><span class="line">        request.addMarker(<span class="string">"network-parse-complete"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将request写入缓存</span></span><br><span class="line">        <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">            request.addMarker(<span class="string">"network-cache-written"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        request.markDelivered();</span><br><span class="line">        <span class="comment">// 回调结果至主线程</span></span><br><span class="line">        mDelivery.postResponse(request, response);</span><br><span class="line">        request.notifyListenerResponseReceived(response);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 以下都是处理异常错误，然后也需要回调至主线程</span></span><br><span class="line">    <span class="keyword">catch</span> (VolleyError volleyError) &#123;</span><br><span class="line">        volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</span><br><span class="line">        parseAndDeliverNetworkError(request, volleyError);</span><br><span class="line">        request.notifyListenerResponseNotUsable();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        VolleyLog.e(e, <span class="string">"Unhandled exception %s"</span>, e.toString());</span><br><span class="line">        VolleyError volleyError = <span class="keyword">new</span> VolleyError(e);</span><br><span class="line">        volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</span><br><span class="line">        mDelivery.postError(request, volleyError);</span><br><span class="line">        request.notifyListenerResponseNotUsable();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        request.sendEvent(RequestQueue.RequestEvent.REQUEST_NETWORK_DISPATCH_FINISHED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>NetworkDispatcher.processRequest()</code>方法可以发现，主要分为以下几步：</p><ul><li>通过<code>BasicNetwork.performRequest(request)</code>得到<code>NetworkResponse</code>对象；</li><li>通过<code>request.parseNetworkResponse(networkResponse)</code>解析得到<code>Response</code>对象；</li><li>通过<code>mDelivery</code>将成功结果或者失败结果回调到主线程。</li></ul><p>现在我们依次来分析这三步：</p><ul><li>请求网络，得到<code>NetworkResponse</code><br>  我们看看<code>BasicNetwork</code>的<code>performRequest()</code>方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> requestStart = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        HttpResponse httpResponse = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] responseContents = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;Header&gt; responseHeaders = Collections.emptyList();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Gather headers.</span></span><br><span class="line">            Map&lt;String, String&gt; additionalRequestHeaders =</span><br><span class="line">                    getCacheHeaders(request.getCacheEntry());</span><br><span class="line">            httpResponse = mBaseHttpStack.executeRequest(request, additionalRequestHeaders);</span><br><span class="line">            <span class="keyword">int</span> statusCode = httpResponse.getStatusCode();</span><br><span class="line"></span><br><span class="line">            responseHeaders = httpResponse.getHeaders();</span><br><span class="line">            <span class="comment">// Handle cache validation.</span></span><br><span class="line">            <span class="keyword">if</span> (statusCode == HttpURLConnection.HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">                Entry entry = request.getCacheEntry();</span><br><span class="line">                <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(</span><br><span class="line">                            HttpURLConnection.HTTP_NOT_MODIFIED,</span><br><span class="line">                            <span class="comment">/* data= */</span> <span class="keyword">null</span>,</span><br><span class="line">                            <span class="comment">/* notModified= */</span> <span class="keyword">true</span>,</span><br><span class="line">                            SystemClock.elapsedRealtime() - requestStart,</span><br><span class="line">                            responseHeaders);</span><br><span class="line">            &#125;</span><br><span class="line">                    …………省略</span><br></pre></td></tr></table></figure><p>通过上面源码可以看出，<code>BasicNetwork</code>就是封装了一下<code>NetworkResponse</code>，并没有涉及到网络请求，我们继续深入到<code>BaseHttpStack.executeRequest(request, additionalRequestHeaders)</code>源码中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> HttpResponse <span class="title">executeRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, AuthFailureError</span>;</span><br></pre></td></tr></table></figure><p>这时发现这个<code>BaseHttpStack</code>就是一个抽象类，而这个<code>executeRequest()</code>也就是一个抽象方法。我当时就卡在这了，调用了一个抽象类的抽象方法，这咋操作嘛。然后我就好好再看了一遍，找到<code>BasicNetwork</code>的构造函数中对<code>mBaseHttpStck</code>定义的地方，发现这个是构造函数传进来的，然后就想到了在调用<code>Volley.newRequestQueue()</code>时，是根据Android版本传入了不同的<code>Stack</code>，那我们就来看看<code>HurlStack.executeRequest()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpResponse <span class="title">executeRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, AuthFailureError </span>&#123;</span><br><span class="line">    String url = request.getUrl();</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.putAll(additionalHeaders);</span><br><span class="line">    <span class="comment">// request.getheaders（）优先于给定的附加（缓存）头.</span></span><br><span class="line">    map.putAll(request.getHeaders());</span><br><span class="line">    <span class="keyword">if</span> (mUrlRewriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String rewritten = mUrlRewriter.rewriteUrl(url);</span><br><span class="line">        <span class="keyword">if</span> (rewritten == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"URL blocked by rewriter: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        url = rewritten;</span><br><span class="line">    &#125;</span><br><span class="line">    URL parsedUrl = <span class="keyword">new</span> URL(url);</span><br><span class="line">    HttpURLConnection connection = openConnection(parsedUrl, request);</span><br><span class="line">    <span class="keyword">boolean</span> keepConnectionOpen = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String headerName : map.keySet()) &#123;</span><br><span class="line">            connection.setRequestProperty(headerName, map.get(headerName));</span><br><span class="line">        &#125;</span><br><span class="line">        setConnectionParametersForRequest(connection, request);</span><br><span class="line">        <span class="comment">// 使用来自httpurlConnection的数据初始化httpResponse。</span></span><br><span class="line">        <span class="keyword">int</span> responseCode = connection.getResponseCode();</span><br><span class="line">        <span class="keyword">if</span> (responseCode == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果无法检索响应代码，getResponseCode（）将返回-1。</span></span><br><span class="line">            <span class="comment">// 向呼叫者发出信号，说明连接有问题。</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Could not retrieve response code from HttpUrlConnection."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!hasResponseBody(request.getMethod(), responseCode)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HttpResponse(responseCode, convertHeaders(connection.getHeaderFields()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要保持连接打开，直到调用方使用流。包装流，以便close（）将断开连接。</span></span><br><span class="line">        keepConnectionOpen = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpResponse(</span><br><span class="line">                responseCode,</span><br><span class="line">                convertHeaders(connection.getHeaderFields()),</span><br><span class="line">                connection.getContentLength(),</span><br><span class="line">                <span class="keyword">new</span> UrlConnectionInputStream(connection));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!keepConnectionOpen) &#123;</span><br><span class="line">            connection.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，主要就是借助了<code>HttpURLConnection</code>对象来请求网络，并根据不同的条件返回不同的<code>HttpResponse</code>对象。</p><ul><li>解析<code>NetworkResponse</code>, 得到<code>Response</code>：解析过程是定义在<code>Request</code>类中，但是他是一个抽象类，不同的Request都有自己的实现，我们现在就以JsonRequest为例看看：<br>然后发现他又是一个抽象类，那我们就看看<code>JsonRequest</code>其中一个实现类<code>JsonObjectRequest</code>的<code>parseNetworkResponse()</code>方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Response&lt;JSONObject&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String jsonString =</span><br><span class="line">                <span class="keyword">new</span> String(</span><br><span class="line">                        response.data,</span><br><span class="line">                        HttpHeaderParser.parseCharset(response.headers, PROTOCOL_CHARSET));</span><br><span class="line">        <span class="keyword">return</span> Response.success(</span><br><span class="line">                <span class="keyword">new</span> JSONObject(jsonString), HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> Response.error(<span class="keyword">new</span> ParseError(e));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JSONException je) &#123;</span><br><span class="line">        <span class="keyword">return</span> Response.error(<span class="keyword">new</span> ParseError(je));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就不用多说了，根据返回来的<code>response</code>建了一个<code>String</code>然后把这个<code>String</code>放到<code>Response</code>里面去然后再返回去。</p><ul><li>回调主线程<br>回调主要是通过<code>Delivery</code>的<code>postResponse()</code>方法实现的，我们来看看这个方法,找过去又找到了一个<code>ResponseDelivery</code>抽象类，然后又得找他的实现类，这时大家应该记得<code>RequestQueue()</code>的时候初始化了一个<code>Delivery</code>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(</span><br><span class="line">            cache,</span><br><span class="line">            network,</span><br><span class="line">            threadPoolSize,</span><br><span class="line">            <span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他返回了一个<code>ExecutorDelivery</code>，我们来看看这个类，然后就惊喜的发现，我们终于找到我们需要的东西了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new response delivery interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler &#123;<span class="doctag">@link</span> Handler&#125; to post responses on</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make an Executor that just wraps the handler.</span></span><br><span class="line">    mResponsePoster =</span><br><span class="line">            <span class="keyword">new</span> Executor() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">                        handler.post(command);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道了它的初始化，我们再来看看它是如何实现回调的：</p><p><code>Volley</code>中回调是通过<code>postResponse()</code>方法的 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span> </span>&#123;</span><br><span class="line">    postResponse(request, response, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">    request.markDelivered();</span><br><span class="line">    request.addMarker(<span class="string">"post-response"</span>);</span><br><span class="line">    mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>postResponse()</code>最终会调用<code>mResponsePoster</code>对象的<code>execute()</code>方法，传入了一个<code>ResponseDeliveryRunnable</code>对象，它实现了<code>Runnable</code>接口，<code>execute()</code>方法会通过<code>Handler.post(runnable)</code>将<code>ResponseDeliveryRunnable</code>放入消息队列。最后我们来看看这个<code>ResponseDeliveryRunnable</code>的<code>run()</code>方法在主线程中做了什么操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this request has canceled, finish it and don't deliver.</span></span><br><span class="line">    <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</span><br><span class="line">        mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</span><br><span class="line">        <span class="comment">// 执行成功的回调，在具体的Request实现类中，比如StringRequest就会调用listener.onResponse(string)回调</span></span><br><span class="line">        mRequest.deliverResponse(mResponse.result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 执行失败的回调，在request中，直接回调了listener.onErrorResponse(error)</span></span><br><span class="line">        mRequest.deliverError(mResponse.error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// intermediate默认为false，但是在CacheDispatcher的run()中，如果需要更新缓存，那么就会置为true</span></span><br><span class="line">    <span class="keyword">if</span> (mResponse.intermediate) &#123;</span><br><span class="line">        mRequest.addMarker(<span class="string">"intermediate-response"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mRequest.finish(<span class="string">"done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果传入了runnable不为空，那就就执行runnable.run()方法</span></span><br><span class="line">    <span class="comment">// 回忆下在CacheDispatcher的run()方法中，如果request有缓存，但是需要更新缓存的时候，mDelivery是不是调用的带runnable的方法</span></span><br><span class="line">    <span class="keyword">if</span> (mRunnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRunnable.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-请求流程图"><a href="#3-请求流程图" class="headerlink" title="3 请求流程图"></a>3 请求流程图</h1><p>最后附上Volley的请求流程图<br><img src="https://blog-1255876459.cos.ap-chengdu.myqcloud.com/2019/07/23/VolleyRequestProcess.jpg" alt="VolleyRequestProcess"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> kotlin </tag>
            
            <tag> Volley </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统2--进程的描述和控制</title>
      <link href="/posts/2e847144.html"/>
      <url>/posts/2e847144.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>大家可以看下我使用幕布软件画的<a href="https://mubu.com/doc/3Pf0zwzrgw" target="_blank" rel="noopener">思维导图</a>，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员<a href="https://mubu.com/inv/477598" target="_blank" rel="noopener">https://mubu.com/inv/477598</a></p></blockquote><a id="more"></a><p>[TOC]</p><h1 id="2-1-进程的描述"><a href="#2-1-进程的描述" class="headerlink" title="2.1 进程的描述"></a>2.1 进程的描述</h1><h2 id="2-1-1-进程的定义和特征"><a href="#2-1-1-进程的定义和特征" class="headerlink" title="2.1.1 进程的定义和特征"></a>2.1.1 进程的定义和特征</h2><h3 id="2-1-1-1-进程的定义"><a href="#2-1-1-1-进程的定义" class="headerlink" title="2.1.1.1 进程的定义"></a>2.1.1.1 进程的定义</h3><p>为了能够使程序并发执行，并且可以对并发执行的程序加以描述和控制，人们引入了“进程”的概念。<br>为了使参与并发执行的每个程序都能独立地运行，操作系统必须为之配置一个专门的数据结构，称为<strong>进程数据块（PCB）</strong>。他用来纪录进程的各种属性，描述进程的动态变化过程。主要包含有进程的描述信息（进程标识符，进程名，用户标识符，进程组关系等）、进程控制信息（当前状态，优先级，代码执行入口地址，保存的磁盘地址等等）、所拥有的资源和使用情况（虚拟地址空间的状态，文件打开列表等）和CPU现场信息等内容。PCB是系统感知进程存在的唯一标志。<br>所以一般情况下，我们把进程实体就简称为进程，创建进程，实质上是创建进程实体中的PCB；撤销进程，实质上是撤销进程的PCB。<br>对于进程的定义，比较典型的有：</p><ol><li>进程是程序的一次执行</li><li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li><li>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li></ol><h3 id="2-1-1-2-进程的特征"><a href="#2-1-1-2-进程的特征" class="headerlink" title="2.1.1.2 进程的特征"></a>2.1.1.2 进程的特征</h3><ol><li>结构性<br>进程实体是由程序段、数据段及进程控制快三部分组成。</li><li>动态性<br>进程的实质是进程实体的执行过程，而且进程“由创建而产生，由调度而执行，由撤销而消亡”。</li><li>并发性<br>多个进程实体同存于内存中，且能在一段时间内同时运行。</li><li>独立性<br>进程实体是一个能独立运行、独立获得资源和独立接收调度的基本单位。</li><li>异步性<br>进程是按异步方式运行的。</li></ol><h2 id="2-1-2-进程的基本状态及转换"><a href="#2-1-2-进程的基本状态及转换" class="headerlink" title="2.1.2 进程的基本状态及转换"></a>2.1.2 进程的基本状态及转换</h2><h3 id="2-1-2-1-进程的三种基本状态"><a href="#2-1-2-1-进程的三种基本状态" class="headerlink" title="2.1.2.1 进程的三种基本状态"></a>2.1.2.1 进程的三种基本状态</h3><p>进程主要分为三种基本状态：</p><ol><li>运行态<br>指进程已经获得了CPU，他正在CPU上执行。</li><li>就绪态<br>指进程已经准备就绪，准备好了被CPU执行的状态。如果系统中有很多处于就绪态的进程，通常把他们按一定的策略排成一个队列，这个队列称为就绪队列。</li><li>等待态<br>指正在运行的进程由于发生某事件（如I/O请求、申请缓冲区失败等问题）暂时无法继续执行时的状态。此时引起进程调度，OS把处理机分配给就绪中的进程，让受阻的进程处于阻塞状态。</li></ol><h3 id="2-1-2-2-三种状态的转换"><a href="#2-1-2-2-三种状态的转换" class="headerlink" title="2.1.2.2 三种状态的转换"></a>2.1.2.2 三种状态的转换</h3><p><img src="https://blog-1255876459.cos.ap-chengdu.myqcloud.com/2019/07/20/UntitledDiagram.jpg" alt="三种状态的转换"></p><h3 id="2-1-2-3-创建状态和终止状态"><a href="#2-1-2-3-创建状态和终止状态" class="headerlink" title="2.1.2.3 创建状态和终止状态"></a>2.1.2.3 创建状态和终止状态</h3><p>为了满足进程控制块对数据及操作的完整性要求以及增强管理的灵活性，通常在系统中又为进程引入了两种常见的状态：创建状态和终止状态。<br><img src="https://blog-1255876459.cos.ap-chengdu.myqcloud.com/2019/07/20/wuzhongzhuangtaizhuanhuan.png" alt="五种状态转换"></p><h2 id="2-1-3-进程管理中的数据结构"><a href="#2-1-3-进程管理中的数据结构" class="headerlink" title="2.1.3 进程管理中的数据结构"></a>2.1.3 进程管理中的数据结构</h2><p>在最开始我已经经提到了进程控制块PCB这个东西，现在我们就进一步来了解他。</p><h3 id="2-1-3-1-进程控制块中的作用"><a href="#2-1-3-1-进程控制块中的作用" class="headerlink" title="2.1.3.1 进程控制块中的作用"></a>2.1.3.1 进程控制块中的作用</h3><p>PCB的作用主要就是使一个在多道程序环境下不能独立运行的程序称为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。</p><ol><li>作为独立运行基本单位的标志。<br> 当一个程序配置了PCB之后，就表示他已是一个能在多道程序环境下独立运行的、合法的基本单位，也就具有取得OS服务的权利。当系统创建一个新的进程的时候，就为他创建了一个PCB，进程结束后收回PCB。</li><li>能实现间断性运行方式。<br> 在多道程序运行环境下，由于存在时间片或者有等待I/O请求的情况，所以进程一般都是出于走走停停的状态，当一个进程被阻塞的时候，他应该有一种能保存当前运行状态的能力也就是保护现场机制，方便在此被调度执行时恢复阻塞前的状态。所以就需要在PCB里面提供一个数据结构来保存该进程被中断时的一些信息。</li><li>提供进程管理所需要的信息。<br> 这个就不用多说吧。</li><li>提供进程调度所需要的信息。<br> 只有处于就绪状态的进程才能被调度执行，而在PCB中就提供了进程处于何种状态的信息。</li><li>实现与其它进程的同步与通信。</li></ol><h3 id="2-1-3-2-进程控制块中的信息"><a href="#2-1-3-2-进程控制块中的信息" class="headerlink" title="2.1.3.2 进程控制块中的信息"></a>2.1.3.2 进程控制块中的信息</h3><p>根据上面进程控制块作用的描述，对应的进程控制块中就需要包含以下信息。</p><ol><li>进程标识符<br> 进程标识符用于唯一地标识一个进程。一个进程通常具有两种标识符：<ol><li>外部标识符<br> 为了方便用户（进程）对进程的访问，进程需要提供一个用于用户（进程）访问的标识符。</li><li>内部标识符<br> 为了方便系统对进程的使用，在OS中又为进程设置了内部标识符。通常是一个进程的序号。</li></ol></li><li>处理机状态<br> 处理机状态信息也称为处理机的上下文，主要是由处理机的各种寄存器中的内容组成的。这些寄存器信息包括通用寄存器、指令寄存器、程序状态字PSW和用户栈指针。</li><li>进程调度信息<br> 在OS进行调度的时候，必须了解进程的状态及有关进程调度的信息，这些信息包括：进程状态、进程优先级、进程调度所需其他信息（与所采用的的调度算法有关）和事件（阻塞原因）。</li><li>进程控制信息<br> 用于进程控制所必须的信息，包括：程序和数据的地址、进程同步和通信机制、资源清单和链接指针。</li></ol><h3 id="2-1-3-3-进程控制块的组织方式"><a href="#2-1-3-3-进程控制块的组织方式" class="headerlink" title="2.1.3.3 进程控制块的组织方式"></a>2.1.3.3 进程控制块的组织方式</h3><p>一个系统中有很多个PCB，为了对他们进行有效的管理，应该用适当的方式将这些PCB组织起来，常用的组织方式有三种</p><ol><li><p>线性方式<br>直接将所有PCB放在一张线性表中，优点是简单，开销小，但是每次查找起来很麻烦。<br><img src="https://blog-1255876459.cos.ap-chengdu.myqcloud.com/2019/07/21/linedPCB.jpg" alt="linedPCB"></p></li><li><p>链接方式<br>把具有相同状态的PCB分别通过PCB中的链接字链接成一个队列。<br><img src="https://blog-1255876459.cos.ap-chengdu.myqcloud.com/2019/07/21/linkedPCB.png" alt="linkedPCB"></p></li><li><p>索引方式<br>根据所有进程状态的不同建立几张索引表，并把个索引表在内存的首地址纪录在内存的一些专用单元中。<br><img src="https://blog-1255876459.cos.ap-chengdu.myqcloud.com/2019/07/21/indexPCB.png" alt="indexPCB"></p></li></ol><h1 id="2-2-进程控制"><a href="#2-2-进程控制" class="headerlink" title="2.2 进程控制"></a>2.2 进程控制</h1><h2 id="2-2-1-进程的层次结构"><a href="#2-2-1-进程的层次结构" class="headerlink" title="2.2.1 进程的层次结构"></a>2.2.1 进程的层次结构</h2><p>在OS中，允许一个进程创建另一个进程，通常把创建进程的进程称为父进程，被创建的进程称为子进程。然后子进程可以作为父进程继续去创建子进程，进而形成一个进程家族。</p><h2 id="2-2-2-进程的创建"><a href="#2-2-2-进程的创建" class="headerlink" title="2.2.2 进程的创建"></a>2.2.2 进程的创建</h2><p>每当出现了创建新进程的请求后，OS便调用进程创建原语Creat按下述步骤创建新进程：</p><ol><li>申请空白PCB，为新进程申请获得唯一的数字标识符，并从PCB集合中索取一个空白PCB。</li><li>为新进程分配其运行所需的资源，包括各种物理和逻辑资源。</li><li>初始化进程控制块PCB。</li><li>如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。</li></ol><h2 id="2-2-3-进程的终止"><a href="#2-2-3-进程的终止" class="headerlink" title="2.2.3 进程的终止"></a>2.2.3 进程的终止</h2><ol><li>根据被终止进程的标识符，从PCB集合中检索出进程的PCB，从中读出该进程的状态。</li><li>若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志位真，用于指示该进程被终止后应重新进行调度。</li><li>若该进程还有子孙进程，还应将其所有子孙进程也都予以终止，以防它们称为不可控的进程。</li><li>将被终止进程所拥有的的全部资源或者归还给其父进程，或者归还给系统。</li><li>将被终止进程（PCB）从所在队列（或链表）中移出，等待其他程序来搜集信息。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统1--操作系统概述</title>
      <link href="/posts/62248b34.html"/>
      <url>/posts/62248b34.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>大家可以看下我使用幕布软件画的<a href="https://mubu.com/doc/3Pf0zwzrgw" target="_blank" rel="noopener">思维导图</a>，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员<a href="https://mubu.com/inv/477598" target="_blank" rel="noopener">https://mubu.com/inv/477598</a></p></blockquote><a id="more"></a><h1 id="现如今主流的操作系统"><a href="#现如今主流的操作系统" class="headerlink" title="现如今主流的操作系统"></a>现如今主流的操作系统</h1><h2 id="1-1-1-PC"><a href="#1-1-1-PC" class="headerlink" title="1.1.1 PC"></a>1.1.1 PC</h2><h3 id="1-1-1-1-Windows"><a href="#1-1-1-1-Windows" class="headerlink" title="1.1.1.1 Windows"></a>1.1.1.1 Windows</h3><p>Microsoft Windows是微软公司推出的一系列操作系统。其问世时间为1985年，起初为运行于MS-DOS之下的桌面环境，其后续版本逐渐发展成为主要为个人计算机和服务器用户设计的操作系统，并最终获得了世界个人计算机操作系统的垄断地位。此操作系统可以在几种不同类型的平台上运行，如个人计算机、移动设备、服务器和嵌入式系统等等，其中在个人计算机的领域应用内最为普遍。<br>Windows操作系统当前最新的稳定版是于2015年7月29日发布的 Windows 10。Windows Server当前最新的稳定版是2018年10月2日发布的Windows Server 2019。Windows Phone当前最新的稳定版是Windows10 Mobile，但是已停止开发新版本，仅对现有版本进行安全补丁和维护，直到2019年12月。</p><h3 id="1-1-1-2-macOS"><a href="#1-1-1-2-macOS" class="headerlink" title="1.1.1.2 macOS"></a>1.1.1.2 macOS</h3><p>macOS（2011年及之前称Mac OS X，2012年至2015年称OS X）是苹果公司推出的基于图形用户界面操作系统，为麦金塔（Macintosh）的主操作系统。StatCounter在2018年8月的数据表示，在桌面操作系统中，macOS的使用份额为12.65%，次于Windows的82.51%位居第二。<br>macOS当前最新的稳定版是2018年9月25日发布的macOS 10.14 Mojave，2019年6月4日推出macOS 10.15 Catalina的第一个测试版本。</p><h3 id="1-1-1-3-Linux"><a href="#1-1-1-3-Linux" class="headerlink" title="1.1.1.3 Linux"></a>1.1.1.3 Linux</h3><p>Linux是一种自由和开放源码的类UNIX 操作系统。该操作系统的内核由林纳斯·托瓦兹在1991年10月5日首次发布，在加上用户空间的应用程序之后，成为 Linux 操作系统。Linux也是自由软件和开放源代码软件发展中最著名的例子。只要遵循 GNU 通用公共许可证（GPL），任何个人和机构都可以自由地使用 Linux 的所有底层源代码，也可以自由地修改和再发布。大多数 Linux 系统还包括像提供 GUI 的 X Window 之类的程序。除了一部分专家之外，大多数人都是直接使用 Linux 发行版，而不是自己选择每一样组件或自行设置。</p><h3 id="1-1-1-4-Unix"><a href="#1-1-1-4-Unix" class="headerlink" title="1.1.1.4 Unix"></a>1.1.1.4 Unix</h3><p>UNIX操作系统（尤尼斯），是一个强大的多用户、多任务操作系统，支持多种处理器架构，按照操作系统的分类，属于分时操作系统，最早由KenThompson、Dennis Ritchie和Douglas McIlroy于1969年在AT&amp;T的贝尔实验室开发。它的商标权由国际开放标准组织所拥有，只有符合单一UNIX规范的UNIX系统才能使用UNIX这个名称，否则只能称为类UNIX（UNIX-like）。</p><h2 id="1-1-2-移动端"><a href="#1-1-2-移动端" class="headerlink" title="1.1.2 移动端"></a>1.1.2 移动端</h2><h3 id="1-1-2-1-Android"><a href="#1-1-2-1-Android" class="headerlink" title="1.1.2.1 Android"></a>1.1.2.1 Android</h3><p>Android，常见的非官方中文名称为安卓，是一个基于Linux内核的开放源代码移动操作系统，由Google成立的Open Handset Alliance持续领导与开发，主要设计用于触摸屏移动设备如智能手机和平板电脑与其他便携式设备。<br>Android Inc.于2003年10月由安迪·鲁宾、利奇·米纳尔、尼克·席尔斯、克里斯·怀特在加州帕罗奥图创建。Android最初由安迪·鲁宾等人开发制作，最初开发这个系统的早期方向是创建一个数字相机的先进操作系统，但是后来发现市场需求不够大，加上智能手机市场快速成长，于是Android成为一款面向智能手机的操作系统。于2005年7月11日Android Inc.被美国科技企业Google收购。<br>2017年3月，Android全球网络流量和设备超越Microsoft Windows，正式成为全球第一大操作系统。</p><h3 id="1-1-2-2-iOS"><a href="#1-1-2-2-iOS" class="headerlink" title="1.1.2.2 iOS"></a>1.1.2.2 iOS</h3><p>iOS（原名为iPhone OS）是苹果公司为其移动设备所开发的专有移动操作系统，为其公司的许多移动设备提供操作界面，支持设备包括iPhone、iPad和iPod touch。iPhone OS自iOS 4起便改名为iOS，它是继Android后全球第二大最受欢迎的移动操作系统，市占率已上升至约24.5% ，但仍远低于Google开发的Android系统的72.2%。</p><h1 id="1-2-操作系统的简介与作用"><a href="#1-2-操作系统的简介与作用" class="headerlink" title="1.2 操作系统的简介与作用"></a>1.2 操作系统的简介与作用</h1><h2 id="1-2-1-操作系统的简介"><a href="#1-2-1-操作系统的简介" class="headerlink" title="1.2.1 操作系统的简介"></a>1.2.1 操作系统的简介</h2><p>操作系统是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。主要作用是对管理好计算机硬件设备，提高他们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单接口，便于用户使用。</p><h2 id="1-2-2-操作系统的目的"><a href="#1-2-2-操作系统的目的" class="headerlink" title="1.2.2 操作系统的目的"></a>1.2.2 操作系统的目的</h2><ol><li>方便性<br> 如果一个计算机没有OS，那么他会非常难用。用户不管进行啥操作都得通过机器语言编写程序然后运行，而如果有OS的话，用户就可以使用各种各样的语言编写程序，然后通过编译将高级语言编译成机器代码，方便了用户。</li><li>有效性<br> 有效性分两层含义——提高系统资源的利用率和提高系统的吞吐量。早期没有OS的计算机中，处理机和I/O设备等经常处于空闲状态，各种资源不能得到合理利用，所以提高系统资源利用率是推动OS发展的主要动力。另一方面，OS可以通过合理组织计算机的工作流程，加速程序的运行，缩短程序的运行周期，从而提高系统的吞吐量。</li><li>可扩充性<br> 为了适应现在越来越多的计算机硬件以及体系结构，OS必修有良好的可扩充性。</li><li>开放性<br> OS需要遵循世界标准规范，凡遵循国际标准所开发的硬件和软件都能彼此兼容，方便地实现互联。</li></ol><h2 id="1-2-3-操作系统的作用"><a href="#1-2-3-操作系统的作用" class="headerlink" title="1.2.3 操作系统的作用"></a>1.2.3 操作系统的作用</h2><ol><li>OS作为用户与计算机硬件系统之间的接口<br> OS处于用户和硬件之间，方便用户通过OS使用硬件。或者说，用户在OS的帮助下能够方便、快捷、可靠地操纵计算机硬件和运行自己的程序。</li><li>OS作为计算机系统资源的管理者<br> 计算机系统资源主要可分为处理机、存储器、I/O设备以及文件。OS主要功能也就是对这四类资源进行有效的管理。处理机管理是用于分配和控制处理机；存储器管理主要负责内存的分配与回收；I/O设备管理是负责I/O设备的分配与操纵；文件管理是用于实现对文件的存取、共享和保护。</li><li>OS实现了对计算机资源的抽象<br> 在裸机中，用户如果想要对计算器进行操作，必须对物理接口的实现细节有充分的了解。但在操作系统中，用户并不需要关心具体的物理，而由操作系统来实现具体的操作细节，并向上讲操作设备抽象为一组数据结构以及一组操作命令。此时在用户眼里，看到的是一台比裸机功能更强，使用更方便的机器。</li></ol><h2 id="1-2-4-推动操作系统发展的主要动力"><a href="#1-2-4-推动操作系统发展的主要动力" class="headerlink" title="1.2.4 推动操作系统发展的主要动力"></a>1.2.4 推动操作系统发展的主要动力</h2><ol><li>不断提高计算机资源利用率</li><li>方便用户</li><li>器件的不断更新换代</li><li>计算机体系结构的不断发展</li><li>不断提出新的应用需求</li></ol><h1 id="1-3-操作系统的发展"><a href="#1-3-操作系统的发展" class="headerlink" title="1.3 操作系统的发展"></a>1.3 操作系统的发展</h1><h2 id="1-3-1-单道批处理系统"><a href="#1-3-1-单道批处理系统" class="headerlink" title="1.3.1 单道批处理系统"></a>1.3.1 单道批处理系统</h2><p>在说单道批处理之前现要引入一个概念——作业。作业包括用户程序、数据、作业说明书。这样每一个处理对象都是作业。</p><h3 id="1-处理过程"><a href="#1-处理过程" class="headerlink" title="1. 处理过程"></a>1. 处理过程</h3><p>每个单道批处理系统都有一个系统操作员。用户先将作业交给系统操作员，然后操作系统操作员就将一个个作业组成一批作业，输入到计算机中，在系统中形成一个自动转接的作业流，然后启动操作系统对作业自动、依次的处理，处理完成后再将处理结果返回给系统操作员，操作员在返回给用户。这样就形成了一个单道批处理过程。<br><img src="https://blog-1255876459.cos.ap-chengdu.myqcloud.com/2019/07/19/15635340778216.png" alt="单道批处理系统处理过程"></p><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>系统资源得不到充分利用。这是因为在内存中仅有一道程序，每逢程序在运行中发出I/O请求后，CPU便处于等待状态，必须在I/O完成后才继续运行。</p><h2 id="1-3-2-多道批处理系统"><a href="#1-3-2-多道批处理系统" class="headerlink" title="1.3.2 多道批处理系统"></a>1.3.2 多道批处理系统</h2><h3 id="1-处理过程-1"><a href="#1-处理过程-1" class="headerlink" title="1. 处理过程"></a>1. 处理过程</h3><p>在该系统中，用户所提交的作业先放在外存中，并排成一个队列，称为“后备队列“。然后由作业调度程序按一定的算法，从后备队列中选择若干作业调入内存。由于同时在内存中装有若干道程序，这样便可以在运行程序A时，利用其I/O操作暂停执行时的CPU空档期，再调度另一道程序B运行。</p><h3 id="2-优缺点"><a href="#2-优缺点" class="headerlink" title="2. 优缺点"></a>2. 优缺点</h3><ol><li>优点<ol><li>资源利用率高</li><li>系统吞吐量大</li></ol></li><li>缺点<ol><li>平均周转时间长</li><li>无交互能力</li></ol></li></ol><h2 id="1-3-3-分时系统"><a href="#1-3-3-分时系统" class="headerlink" title="1.3.3 分时系统"></a>1.3.3 分时系统</h2><h3 id="1-运行方式"><a href="#1-运行方式" class="headerlink" title="1. 运行方式"></a>1. 运行方式</h3><ol><li>作业直接进入内存。因为作业在磁盘上不可运行，所以作业应直接进入内存</li><li>采用轮转运行方式。如果一个作业独占CPU连续运行，那么其他作业没法运行。为了避免这种情况，引入了时间片概念。一个时间片是一个很短的时间，系统规定了每个作业每次只能运行一个时间片，然后就暂停该作业的运行，并立即调度下一个作业运行。如果在不长的时间内能使所有的作业都执行一个时间片的时间，便可以使每个用户都能及时地与自己的作业进行交互，从而使用户的请求的到及时响应。</li></ol><h3 id="2-特征"><a href="#2-特征" class="headerlink" title="2. 特征"></a>2. 特征</h3><ol><li>多路性</li><li>独立性</li><li>及时性</li><li>交互性</li></ol><h2 id="1-3-4-实时系统"><a href="#1-3-4-实时系统" class="headerlink" title="1.3.4 实时系统"></a>1.3.4 实时系统</h2><p>实时系统是指系统能及时响应外部事件的请求，在规定时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。<br>实时系统主要应用于：</p><ol><li>工业（武器）控制系统</li><li>信息查询系统</li><li>多媒体系统</li><li>嵌入式系统</li></ol><h1 id="1-4-操作系统的基本特征"><a href="#1-4-操作系统的基本特征" class="headerlink" title="1.4 操作系统的基本特征"></a>1.4 操作系统的基本特征</h1><h2 id="1-4-1-并发"><a href="#1-4-1-并发" class="headerlink" title="1.4.1 并发"></a>1.4.1 并发</h2><p>正是系统中有这一特征，才使得OS能有效地提高系统中的资源利用率，增加系统的吞吐量。</p><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>并行是指两个或多个事件在同一时刻发生，微观上是同一时刻多个线程在CPU上运行。<br>并发是指宏观上两个或多个事件在同一时间发生，微观上缺是某一时刻CPU上只有一个进程。</p><h2 id="1-4-2-共享"><a href="#1-4-2-共享" class="headerlink" title="1.4.2 共享"></a>1.4.2 共享</h2><p>资源共享，即操作系统中的资源可供多个并发执行的进程共同使用，由于资源属性不同，多个进程对资源的共享方式也不同。可分为：互斥共享方式和同时访问方式。</p><h3 id="1-互斥共享方式"><a href="#1-互斥共享方式" class="headerlink" title="1. 互斥共享方式"></a>1. 互斥共享方式</h3><p>一段时间内只允许一个进程访问该资源，如磁带机,打印机等。虽然可以供多个进程使用，但是为了打印或记录结果不造成混淆，应规定一段时间内只允许一个进程访问该资源。</p><h3 id="2-同时访问方式"><a href="#2-同时访问方式" class="headerlink" title="2. 同时访问方式"></a>2. 同时访问方式</h3><p>某些资源，一段时间内是可以允许多个进程“同时”同时对他们进行访问，这个同时是宏观上的，在微观上可能是分时共享。</p><h2 id="1-4-3-虚拟"><a href="#1-4-3-虚拟" class="headerlink" title="1.4.3 虚拟"></a>1.4.3 虚拟</h2><p>在OS中，把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为”虚拟“。</p><h2 id="1-4-4-异步"><a href="#1-4-4-异步" class="headerlink" title="1.4.4 异步"></a>1.4.4 异步</h2><p>在多道环境下，允许多个程序并发执行。但由于资源有限，进程的执行不是一贯到底。而是走走停停，以不可预知的速度向前推进，这就是进程的异步。</p><h1 id="1-5-操作系统的主要功能"><a href="#1-5-操作系统的主要功能" class="headerlink" title="1.5 操作系统的主要功能"></a>1.5 操作系统的主要功能</h1><p>操作系统的主要功能应分为处理机管理、存储器管理、设备管理和文件管理。此外，还应向用户提供方便的用户接口。</p><h2 id="1-5-1-处理机管理功能"><a href="#1-5-1-处理机管理功能" class="headerlink" title="1.5.1 处理机管理功能"></a>1.5.1 处理机管理功能</h2><h3 id="1-进程控制"><a href="#1-进程控制" class="headerlink" title="1. 进程控制"></a>1. 进程控制</h3><p>在多道程序环境中，为了使作业能并发执行，必须为每道作业创建一个或几个进程，并为之分配必要的资源。当进程运行结束时，应立即撤销该进程，以便能及时回收该进程所占用的各种资源，供其它进程使用。</p><h3 id="2-进程同步"><a href="#2-进程同步" class="headerlink" title="2. 进程同步"></a>2. 进程同步</h3><p>为了使多个进程能有条不紊的运行，系统中必须设置相应的进程同步机制。该机制的主要任务是为多个进程的运行进行协调。</p><h3 id="3-进程通信"><a href="#3-进程通信" class="headerlink" title="3. 进程通信"></a>3. 进程通信</h3><p>如果一组相互合作的进程去完成一个共同的任务时，在他们之间往往需要交换信息。</p><h3 id="4-调度"><a href="#4-调度" class="headerlink" title="4. 调度"></a>4. 调度</h3><p>在传统OS中，调度包括作业调度和进程调度。</p><ol><li>作业调度<br> 作业调度的基本任务就是从后备队列中按照一定的算法选择出若干个作业，为他们分配所需资源，在这些作业调入内存后，分别为他们创建进程，是他们都称为可能获得处理机的就绪进程，并将他们插入就绪队列中。</li><li>进程调度<br> 进程调度的任务是从进程的就绪队列中按照一定的算法选出一个进程，将处理机分配给他，并为他设置运行线程，使其投入执行。</li></ol><h2 id="1-5-2-存储器管理功能"><a href="#1-5-2-存储器管理功能" class="headerlink" title="1.5.2 存储器管理功能"></a>1.5.2 存储器管理功能</h2><p>存储器管理视为多道程序的运行提供良好的环境，提高存储器利用率，并能从逻辑上扩充内存。为此，存储器管理应具有内存分配和回收、内存保护、地址映射和内存扩充等功能。</p><h3 id="1-内存分配"><a href="#1-内存分配" class="headerlink" title="1. 内存分配"></a>1. 内存分配</h3><p>内存分配主要任务是：</p><ol><li>为每道程序分配内存空间</li><li>提高存储器的利用率，尽量减少不可用的内存空间</li><li>允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需要。</li></ol><p>OS在实现内存分配时，可采取静态和动态两种方式：</p><ol><li>静态分配内存。每个作业的内存空间在作业装入时确定，确定后不再改变。</li><li>动态分配内存。每个作业所要求的的基本内存空间虽然也是在装入时确定的，但允许作业在运行过程中继续申请新的附加内存空间，以适应程序和数据的动态增长。</li></ol><h3 id="2-内存保护"><a href="#2-内存保护" class="headerlink" title="2. 内存保护"></a>2. 内存保护</h3><p>确保每道用户程序都在自己的内存空间内运行，彼此互不干扰。决不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其他用户程序中去执行。</p><h3 id="3-地址映射"><a href="#3-地址映射" class="headerlink" title="3. 地址映射"></a>3. 地址映射</h3><p>每道程序经编译连接后所形成的的可装入程序其地址都是从0开始的，但是不可能将他们从“0”地址开始装入内存，所以物理地址和逻辑地址并不一致，这时候就需要地址映射来让程序能正常运行。</p><h3 id="4-内存扩充"><a href="#4-内存扩充" class="headerlink" title="4. 内存扩充"></a>4. 内存扩充</h3><p>借助虚拟存储技术来实现内存扩充，主要解决：</p><ol><li>内存和I/O之间速度不匹配的问题</li><li>如果内存空间不足的问题</li></ol><h2 id="1-5-3-设备管理功能"><a href="#1-5-3-设备管理功能" class="headerlink" title="1.5.3 设备管理功能"></a>1.5.3 设备管理功能</h2><p>主要任务：</p><ol><li>完成用户进程提出的I/O请求，为用户进程分配所需的I/O设备，并完成指定的I/O操作</li><li>提高CPU与I/O设备的利用率，提高I/O速度，方便用户使用I/O</li></ol><p>为了实现以上功能，应具有缓冲管理、设备分配和设备处理以及虚拟设备等功能。</p><h3 id="1-缓冲管理"><a href="#1-缓冲管理" class="headerlink" title="1. 缓冲管理"></a>1. 缓冲管理</h3><p>为了有效的缓和CPU与I/O设备间速度不匹配的问题，提高CPU利用率，于是引入了缓冲管理。</p><h3 id="2-设备分配"><a href="#2-设备分配" class="headerlink" title="2. 设备分配"></a>2. 设备分配</h3><p>设备分配的基本任务是根据用户进程的I/O请求、系统现有资源情况以及按照某种设备分配策略，为之分配其所需的设备。</p><h3 id="3-设备处理"><a href="#3-设备处理" class="headerlink" title="3. 设备处理"></a>3. 设备处理</h3><p>实现CPU和设备控制器之间的通信，即由CPU向设备控制器发出I/O命令，要求他完成指定的I/O操作；反之，由CPU控制从接收器发来的中断请求，并给予迅速的响应和相应的处理。</p><h2 id="1-5-4-文件管理功能"><a href="#1-5-4-文件管理功能" class="headerlink" title="1.5.4 文件管理功能"></a>1.5.4 文件管理功能</h2><p>主要是对用户文件和系统文件进行管理以方便用户使用，并保证文件的安全性。为此，文件管理应具有对文件存储空间管理、目录管理、文件的读/写管理以及文件的共享与保护等功能。</p><h3 id="1-文件存储空间的管理"><a href="#1-文件存储空间的管理" class="headerlink" title="1. 文件存储空间的管理"></a>1. 文件存储空间的管理</h3><p>为每个文件分配必要的外存空间，提高我村利用率，进而提高文件系统的存、取速度。</p><h3 id="2-目录管理"><a href="#2-目录管理" class="headerlink" title="2. 目录管理"></a>2. 目录管理</h3><p>为每个文件建立一个目录项，目录项包括文件名、文件属性、文件在磁盘上的物理位置等，并对众多的目录项加以有效的组织，以实现方便的按名字存取。</p><h3 id="3-文件的读-写管理和保护"><a href="#3-文件的读-写管理和保护" class="headerlink" title="3. 文件的读/写管理和保护"></a>3. 文件的读/写管理和保护</h3><p>根据用户的请求，从外存中读取数据或将数据写入外存。并且保护文件防止其被非法盗取和破坏。</p><h2 id="1-5-5-操作系统与用户间的接口"><a href="#1-5-5-操作系统与用户间的接口" class="headerlink" title="1.5.5 操作系统与用户间的接口"></a>1.5.5 操作系统与用户间的接口</h2><p>接口主要分为两大类：用户接口和程序接口。用户接口是供用户调用，方便用户直接或间接控制自己的作业。程序接口是为用户程序在执行中访问系统资源而设定的，是用户取得操作系统服务的唯一途径。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android多线程2--Java中的线程池</title>
      <link href="/posts/b39fd0ab.html"/>
      <url>/posts/b39fd0ab.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>我们在写项目经常要用到多线程。但是线程的创建和摧毁都是较消耗资源和性能的，如果你每需要一个任务就新建一个线程，那可能会在线程的创建和摧毁上浪费掉很多资源。那如果我们让线程执行任务后不摧毁，接着执行下一个任务，这样是不是就能避免这种情况了。Java1.5中提供了<code>Executor</code>框架用于把任务的提交和执行解耦，任务的执行就交给<code>Runnable</code>或者<code>Callable</code>，而<code>Executor</code>框架用于处理任务。<code>Executor</code>中最核心的成员就是<code>ThreadPoolExecutor</code>，他就是线程池核心实现类。</p><a id="more"></a><h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><p>我们现在先来看下这个方法。<br>构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> maximumPoolSize,markdownlint</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                        TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                        BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                        ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                        RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看下这些参数：</p><ul><li><code>corePoolSize</code>：核心线程数。线程池刚创建的时候，线程数量为0，只有任务提交的时候才会创建线程。如果当前线程数量小于<code>corePoolSize</code>，则创建新线程；如果等于或者大于，则不再创建。</li><li><code>maximumPoolSize</code>：线程池允许创建的最大线程数。当<code>workQueue</code>满了而且线程数小于<code>maximumPoolSize</code>时，线程池仍会创建新的线程。但是如果超过了<code>maximumPoolSize</code>时，则会抛出异常。</li><li><code>keepAliveTime</code>：非核心线程闲置的超过时间。当线程池中线程数量大于workQueue，如果一个线程的空闲时间大于keepAliveTime，则该线程会被回收。如果任务很多，并且每个任务 的执行事件很短，则可以调大keepAliveTime来提高线程的利用率。另外，如果设置 allowCoreThreadTimeOut属性为true时，keepAliveTime也会应用到核心线程上。</li><li><code>timeUnit</code>：keepAliveTime参数的时间单位。可选的单位有天(DAYS)、小时(HOURS)、分钟(MINUTES)、秒(SECONDS)、毫秒(MILLISECONDS)等。</li><li><code>workQueue</code>：任务队列。如果当前线程数大于<code>corePoolSize</code>，则将任务添加到此任务队列中。该任务 队列是<code>BlockingQueue</code>类型的，也就是阻塞队列。</li><li><code>threadFactory</code>：线程工厂。可以用线程工厂给每个创建出来的线程设置名字。一般情况下无须设置该参数。</li><li><code>RejectedExecutionHandler</code>：饱和策略。这是当任务队列和线程池都满了时所采取的应对策略，默认是AbordPolicy，表示无法处理新任务，并抛出<code>RejectedExecutionException</code>异常。此外还有3种策略，它们分别如下:<ol><li><code>CallerRunsPolicy</code>：用调用者所在的线程来处理任务。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。</li><li><code>DiscardPolicy</code>：不能执行的任务，并将该任务删除。</li><li><code>DiscardOldestPolicy</code>：丢弃队列最近的任务，并执行当前的任务。</li></ol></li></ul><h1 id="线程池的处理流程"><a href="#线程池的处理流程" class="headerlink" title="线程池的处理流程"></a>线程池的处理流程</h1><p>线程池的任务处理主要分为3个步骤</p><ol><li>提交任务后，线程池先判断线程数是否达到了核心线程数<code>corePoolSize</code>。如果未达到核心线程数，则创建核心线程处理任务；否则，就执行下一步操作。</li><li>接着线程池判断任务队列是否满了。如果没满，则将任务添加到任务队列中；否则，就执行下一步操作。</li><li>接着因为任务队列满了，线程池就判断线程数是否达到了最大线程数。如果未达到，则创建非核心线程处理任务；否则，就执行饱和策略，默认会抛出<code>RejectedExecutionException</code>异常。</li></ol><p><img src="http://psb1j8lvg.bkt.clouddn.com/mweb/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A72019-06-16%E4%B8%8B%E5%8D%883.03.51.png" alt="线程池执行流程"></p><ol><li>如果线程池中的线程数未达到核心线程数，则创建核心线程处理任务。</li><li>如果线程数大于或者等于核心线程数，则将任务加入任务队列，线程池中的空闲线程会不断地从 任务队列中取出任务进行处理。</li><li>如果任务队列满了，并且线程数没有达到最大线程数，则创建非核心线程去处理任务。</li><li>如果线程数超过了最大线程数，则执行饱和策略。</li></ol><h1 id="线程池的种类"><a href="#线程池的种类" class="headerlink" title="线程池的种类"></a>线程池的种类</h1><h2 id="CachedThreadPool：可缓存线程池"><a href="#CachedThreadPool：可缓存线程池" class="headerlink" title="CachedThreadPool：可缓存线程池"></a>CachedThreadPool：可缓存线程池</h2><ol><li>线程数无限制</li><li>有空闲线程则复用空闲线程，若无空闲线程则新建线程</li><li>一定程序减少频繁创建/销毁线程，减少系统开销</li></ol><p>创建源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CachedThreadPool</code>的<code>corePoolSize</code>为0，<code>maximumPoolSize</code>设置为<code>Integer.MAX_VALUE</code>，这意味着<code>CachedThreadPool</code>没有核心线程，非核心线程是无界的。<code>keepAliveTime</code>设置为60L，则空闲线程等待新任务 的最长时间为60s。在此用了阻塞队列<code>SynchronousQueue</code>，它是一个不存储元素的阻塞队列，每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都等待另一个线程的插入操作。</p><h2 id="FixedThreadPool：定长线程池"><a href="#FixedThreadPool：定长线程池" class="headerlink" title="FixedThreadPool：定长线程池"></a>FixedThreadPool：定长线程池</h2><ol><li>可控制线程最大并发数（同时执行的线程数）</li><li>超出的线程会在队列中等待</li></ol><p>创建源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FixedThreadPool</code>的<code>corePoolSize</code>和<code>maximumPoolSize</code>都设置为创建<code>FixedThreadPool</code>指定的参数<code>nThreads</code>，也就意味着<code>FixedThreadPool</code>只有核心线程，并且数量是固定的，没有非核心线程。<code>keepAliveTime</code>设置为0L意味着多余的线程会被立即终止。因为不会产生多余的线程，所以<code>keepAliveTime</code>是无效的参数。另外，任务队列采用了无界的阻塞队列<code>LinkedBlockingQueue</code>。</p><h2 id="ScheduledThreadPool：定长线程池"><a href="#ScheduledThreadPool：定长线程池" class="headerlink" title="ScheduledThreadPool：定长线程池"></a>ScheduledThreadPool：定长线程池</h2><p>支持定时及周期性任务执行。</p><p>创建源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到在创建源码中他跳转到了<code>ScheduledThreadPoolExecutor</code>的构造方法，我们继续看进去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">            DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> DelayedWorkQueue(), threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，<code>ScheduledThreadPoolExecutor</code>的构造方法最终调用的是<code>ThreadPoolExecutor</code>的构造方法。<code>corePoolSize</code>是传进来的固定数值，<code>maximumPoolSize</code>的值是<code>Integer.MAX_VALUE</code>。因为采用的<code>DelayedWorkQueue</code>是无界的，所以<code>maximumPoolSize</code>这个参数是无效的。</p><h2 id="SingleThreadExecutor：单线程化的线程池"><a href="#SingleThreadExecutor：单线程化的线程池" class="headerlink" title="SingleThreadExecutor：单线程化的线程池"></a>SingleThreadExecutor：单线程化的线程池</h2><ol><li>有且仅有一个工作线程执行任务</li><li>所有任务按照指定顺序执行，即遵循队列的入队出队规则</li></ol><p>创建源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>corePoolSize</code>和<code>maximumPoolSize</code>都为1，意味着<code>SingleThreadExecutor</code>只有一个核心线程，其他的参数都和<code>FixedThreadPool</code>一样，这里就不赘述了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Next配置备份</title>
      <link href="/posts/5b6e53a4.html"/>
      <url>/posts/5b6e53a4.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo配置备份"><a href="#Hexo配置备份" class="headerlink" title="Hexo配置备份"></a>Hexo配置备份</h1><a id="more"></a><h1 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h1><ul><li>来必力 - <a href="https://www.livere.com/" target="_blank" rel="noopener">https://www.livere.com/</a></li><li>valine(在用) - <a href="https://valine.js.org/" target="_blank" rel="noopener">https://valine.js.org/</a></li></ul><h1 id="阅读量显示"><a href="#阅读量显示" class="headerlink" title="阅读量显示"></a>阅读量显示</h1><ul><li>leancloud - <a href="https://leancloud.cn/" target="_blank" rel="noopener">https://leancloud.cn/</a></li><li>valine(在用) - <a href="https://valine.js.org/" target="_blank" rel="noopener">https://valine.js.org/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android多线程1--Java中的阻塞队列</title>
      <link href="/posts/63ab42b7.html"/>
      <url>/posts/63ab42b7.html</url>
      
        <content type="html"><![CDATA[<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在谈论阻塞队列之前我们先看下操作系统多线程部分一个经典的例子——生产者和消费者问题：</p><blockquote><p>现在有两个进程，一个是生产者一个是消费者，还有一个线程缓冲区。生产者主要作用就是向缓冲区中添加数据，消费者就是从缓冲区中取出数据。这个问题的核心就是如何确保生产者不会在缓冲区满了的时候还往其中添加元素，消费者不会在缓冲区空了的时候还要求取出数据。</p></blockquote><a id="more"></a><p>关于这个问题的解决办法我们以后再说，我们现在主要讨论线程缓冲区——阻塞队列。</p><h2 id="阻塞队列简介"><a href="#阻塞队列简介" class="headerlink" title="阻塞队列简介"></a>阻塞队列简介</h2><p>阻塞队列就是队列，只是在一般的队列上添加了两个条件：</p><ol><li>当队列满了的时候不允许再添加数据</li><li>当队列空了的时候不允许从中取数据</li></ol><p>在Java中，阻塞队列是通过<code>BlockingQueue</code>来实现的，<code>BlockingQueue</code>是<code>Java.util.concurrent</code>包下一个重要的数据结构。</p><h2 id="BlockingQueue的操作方法"><a href="#BlockingQueue的操作方法" class="headerlink" title="BlockingQueue的操作方法"></a>BlockingQueue的操作方法</h2><table><thead><tr><th align="center">方法</th><th align="center">抛异常</th><th align="center">返回特定值</th><th align="center">阻塞</th><th align="center">超时</th></tr></thead><tbody><tr><td align="center">插入</td><td align="center">add(E e)</td><td align="center">offer(E e)</td><td align="center">put(E e)</td><td align="center">offer(E e, long timeout, TimeUnit unit)</td></tr><tr><td align="center">移除</td><td align="center">remove()</td><td align="center">poll()</td><td align="center">take()</td><td align="center">poll(time, unit)</td></tr><tr><td align="center">检查</td><td align="center">element()</td><td align="center">peek()</td><td align="center">不可用</td><td align="center">不可用</td></tr></tbody></table><blockquote><p>解释：</p><ol><li>抛异常：如果操作无法执行，则抛出一个异常</li><li>特定值：如果操作无法执行，则返回一个特定的值</li><li>阻塞： 如果操作无法执行，则方法调用被阻塞，直到可以执行</li><li>超时：如果操作无法执行，则方法调用被阻塞，直到可以执行或者超过限定的时间。返回一个特定值以告知该操作是否成功(典型的是true / false)。</li></ol></blockquote><h2 id="Java中的各种阻塞队列"><a href="#Java中的各种阻塞队列" class="headerlink" title="Java中的各种阻塞队列"></a>Java中的各种阻塞队列</h2><p><code>Java</code>基于<code>BlockingQueue</code>给开发者提供了7个阻塞队列：</p><ol><li><code>ArrayBlockingQueue</code>：基于数组的有界阻塞队列。有界就意味着他有一个最大限度，所存储的线程的数量不能超过这个限定值。你也可以在对其初始化的时候给定这个限定值。但是由于它是基于数组所以他和数组一样，在初始化的时候限定了这个大小以后就不能改变。</li><li><code>LinkedBlockingQueue</code>：基于链表的阻塞队列。它内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用<code>Integer.MAX_VALUE</code>作为上限。<code>LinkedBlockingQueue</code>内部以FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。由于默认是无上限的，所以在使用他的时候，如果生产者的速度大于消费者的速度，系统内存可能会被耗尽。所以使用他一定要设置初值。</li><li><code>PriorityBlockingQueue</code>：支持优先级的无界队列。默认情况按照自然顺序生序排列，你可以重写<code>compateTo()</code>方法来制定元素按规定排序。</li><li><code>DelayQueue</code>：支持延时获取元素的无界阻塞队列。队列中的元素必须实现<code>Delayed</code>接口。</li><li><code>SynchromousQueue</code>：是一个特殊的队列。他不能存储任何元素，他的每一次插入操作必须等待另一个线程相应的删除操作，反之亦然。</li><li><code>LinkedTransferQueue</code>：基于链表的无界阻塞<code>TransferQueue</code>队列。相对于其他队列，他多了<code>transfer(E e)</code>、<code>tryTransfer(E e)</code> 和 <code>tryTransfer(E e, long timeout, TimeUnit unit)</code>方法。</li><li><code>LinkedBlockingDeque</code>：是一个链表结构的双向阻塞队列。可在两端入队出对。所以当多线程入队时，减少了一半的竞争。</li></ol><h2 id="阻塞队列实现原理"><a href="#阻塞队列实现原理" class="headerlink" title="阻塞队列实现原理"></a>阻塞队列实现原理</h2><p>下面我们以<code>ArrayBlockingQueue</code>源码为例，来看下阻塞队列实现原理：</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>首先就是一堆变量的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The queued items */</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** items index for next take, poll, peek or remove */</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** items index for next put, offer, or add */</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Number of elements in the queue */</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Concurrency control uses the classic two-condition algorithm</span></span><br><span class="line"><span class="comment"> * found in any textbook.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Main lock guarding all access */</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Condition for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span></span><br><span class="line"><span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Condition for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span></span><br><span class="line"><span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure><p><code>items</code>是存储队列元素的数组，<code>takeIndex</code>和<code>putIndex</code>分别是取数据和存数据的索引，<code>count</code>是队列中元素个数，<code>lock</code>为看一个可重入锁，<code>notEmpty</code>和<code>notFull</code>均为等待条件，由<code>loc</code>k创建。</p><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>接下来看下它的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造器有三个重载的版本，第一个构造器只有一个参数用来指定容量，第二个构造器多了一个参数来指定访问策略，第三个构造器又多了一个参数可以指定用另外一个集合进行初始化。</p><h3 id="数据的添加"><a href="#数据的添加" class="headerlink" title="数据的添加"></a>数据的添加</h3><p>接下来我们看看<code>BlockingQueue</code>的三个插入的方法：<code>put()</code>、<code>add()</code>和<code>offer()</code>：</p><ul><li><code>put()</code> 方法：队列满，会阻塞调用存储元素的线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 先检查e是不是空，如果空则抛异常</span></span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    <span class="comment">// 获取一个重入锁lock</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁，保证调用put方法的时候只有1个线程</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 如果线程中的元素数量是否等于当前数组的长度，如果相等则调用await方法等待，如果不相等则enqueue方法插入元素</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>add()</code>方法：实际上调用了<code>offer()</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>offer()</code>方法：成功返回true，失败返回false</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查e是否为空</span></span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    <span class="comment">// 获取重入锁lock</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果如果线程中的元素数量是否等于当前数组的长度，如果相等则调返回false，如果不相等则enqueue方法插入元素并返回true</span></span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上三个方法都调用了<code>enqueue()</code>方法。下面我们就来看看这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts element at current put position, advances, and signals.</span></span><br><span class="line"><span class="comment"> * Call only when holding lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = e;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length) </span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先获取元素数组<code>items</code>，然后添加<code>putIndex</code>上，如果<code>++putIndex</code>等于<code>items</code>的长度，则证明当前这个<code>items</code>所有元素都添加进了，就让<code>putIndex</code>等于0.然后调用<code>notEmpty.signal()</code>方法唤醒正在获取元素的线程，让他们从队列中取数据。</p><h3 id="数据的取出"><a href="#数据的取出" class="headerlink" title="数据的取出"></a>数据的取出</h3><p>ArrayBlockingQueue的取数据方法总共也有三个方法：<code>poll()</code>、<code>take()</code>和<code>remove()</code></p><ul><li><code>poll()</code>方法：获取元素，存在返回元素e,不存在返回null</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取重入锁lock</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果元素数量等于0就返回null，否则调用dequeue()方法</span></span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>take()</code>方法：取元素。如果队列为空,则会阻塞调用获取元素的线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取重入锁lock</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果线程中的元素数量是否等于0，如果相等则调用await方法等待，如果不相等则dequeue方法删除元素</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>remove()</code>方法：取元素，它是取特定的那个元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断o是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 获取重入锁lock</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果元素数量大于0，则获取items，然后便利元素，判断o是其中的哪个，然后删除那个</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = takeIndex, end = putIndex, to = (i &lt; end) ? end : items.length; ; i = <span class="number">0</span>, to = end) &#123;</span><br><span class="line">                <span class="keyword">for</span> (; i &lt; to; i++)</span><br><span class="line">                    <span class="keyword">if</span> (o.equals(items[i])) &#123;</span><br><span class="line">                        removeAt(i);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">if</span> (to == end) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>poll()</code>和<code>take()</code>两个方法都调用了<code>dequeue()</code>方法，我们就看下<code>dequeue()</code>是如何来实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Extracts element at current take position, advances, and signals.</span></span><br><span class="line"><span class="comment"> * Call only when holding lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    E e = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length) takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上面的<code>enqueue()</code>方法类似，再次就不再赘述。</p><h2 id="阻塞队列的应用"><a href="#阻塞队列的应用" class="headerlink" title="阻塞队列的应用"></a>阻塞队列的应用</h2><p>前面我说过，阻塞队列主要用在生产者和消费者模式中，那下面我们就来写一个简单的小demo</p><blockquote><blockquote><p>这段代码来自刘望舒所著《Android进阶之光》</p></blockquote></blockquote><p>如果不用阻塞队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueSize = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(queueSize);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        Producer producer = test.new Producer();</span><br><span class="line">        Consumer consumer = test.new Consumer();</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"队列空，等待数据"</span>);</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            queue.notify();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 每次移走队首元素</span></span><br><span class="line">                    queue.poll();</span><br><span class="line">                    queue.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"队列满，等待有空余空间"</span>);</span><br><span class="line">                        queue.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        queue.notify();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 每次插入一个元素</span></span><br><span class="line">                queue.offer(<span class="number">1</span>);</span><br><span class="line">                queue.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用阻塞队列<code>ArrayBlockingQueue</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueSize = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> ArrayBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(queueSize);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueueTest test = <span class="keyword">new</span> BlockingQueueTest();</span><br><span class="line">        BlockingQueueTest.Producer producer = test.new Producer();</span><br><span class="line">        BlockingQueueTest.Consumer consumer = test.new Consumer();</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.take();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.put(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin入门1:Kotlin和Java区别基础篇</title>
      <link href="/posts/343b01ae.html"/>
      <url>/posts/343b01ae.html</url>
      
        <content type="html"><![CDATA[<h1 id="Koltin入门"><a href="#Koltin入门" class="headerlink" title="Koltin入门"></a>Koltin入门</h1><h1 id="Kotlin简介"><a href="#Kotlin简介" class="headerlink" title="Kotlin简介"></a>Kotlin简介</h1><blockquote><p>科特林岛(Котлин)是一座俄罗斯的岛屿,位于圣彼得堡以西约30公里处,形状狭长,东西长度约14公里,南北宽度约2公里,面积有16平方公里,扼守俄国进入芬兰湾的水道。科特林岛上建有喀琅施塔得市,为圣彼得堡下辖的城市。</p></blockquote><p>而我们虽说的kotlin，就是一门根据它命名的一种现代程序设计语言。Kotlin 是一个用于现代多平台应用的静态编程语言，由 JetBrains 开发。Kotlin可以编译成Java字节码，也可以编译JavaScript，方便在没有JVM的设备上运行。Kotlin已正式成为Android官方支持开发语言。</p><a id="more"></a><hr><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>kotlin和Java的最基本的区别就是kotlin中<strong>万物皆对象</strong>，Java中还存在着int、float等基本类型，但是在kotlin中，它把这些都定义成了对象，类似于Java中的封装类</p><h2 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h2><p>上面说了，kotlin万物皆对象，所以所有的变量也都是对象。<br>在kotlin定义对象和Java有点小区别。<br>kotlin定义对象的格式为</p><blockquote><p> 声明类型 变量名： 变量类型</p></blockquote><p>其中：</p><ul><li>声明类型分为<code>val</code>和<code>var</code>。<code>val</code>是不可变类型，类似于const，定义时必须赋值，赋值后不能被修改。<code>var</code>是可变类型。</li><li>变量名就是你定义的这个变量的名称。</li><li>变量类型就是你这个变量对应的类的名字。</li></ul><h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><h3 id="省去变量类型"><a href="#省去变量类型" class="headerlink" title="省去变量类型"></a>省去变量类型</h3><p>kotlin里面类似c++的<code>auto</code>类型，对于基本类型，你可以不写变量类型，kotlin会自动帮你判断。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line">println(a <span class="keyword">is</span> <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = “<span class="number">123</span></span><br><span class="line">println(b <span class="keyword">is</span> String)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">1.3</span></span><br><span class="line">println(c <span class="keyword">is</span> <span class="built_in">Float</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">true</span></span><br><span class="line">println(d <span class="keyword">is</span> <span class="built_in">Boolean</span>)</span><br></pre></td></tr></table></figure><h3 id="is关键字"><a href="#is关键字" class="headerlink" title="is关键字"></a><code>is</code>关键字</h3><p><code>is</code>顾名思义，就是判断这个变量是不是这个类型的实例。<br>例子见上。</p><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><table><thead><tr><th>类型</th><th>宽度(bit)</th></tr></thead><tbody><tr><td>Byte</td><td>8</td></tr><tr><td>Short</td><td>16</td></tr><tr><td>Int</td><td>32</td></tr><tr><td>Long</td><td>64</td></tr><tr><td>Float</td><td>32</td></tr><tr><td>Double</td><td>64</td></tr></tbody></table><p>这些类型都继承自<code>Number</code>和<code>Comparable</code>类。</p><h3 id="字面常量值"><a href="#字面常量值" class="headerlink" title="字面常量值"></a>字面常量值</h3><ul><li>十进制：<code>123</code></li><li>十六进制：<code>0x0f</code></li><li>二进制：<code>0b0010</code></li><li>Long类型：<code>123L</code></li><li>double类型：123.4</li><li>Float类型：<code>123.4f</code>或者<code>123.4F</code></li></ul><p>我们也可以使用下划线<code>_</code>来方便我们阅读</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1_000_000</span> <span class="comment">// 1000000</span></span><br><span class="line"><span class="number">0xFF_EC</span> <span class="comment">// 0xFFEC</span></span><br></pre></td></tr></table></figure><h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h3><p>kotlin中不可隐式转换<br>比如Java 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">long</span> b = a;</span><br></pre></td></tr></table></figure><p>但是在kotlin中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a : <span class="built_in">Int</span>? = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> b : <span class="built_in">Long</span>? = a; <span class="comment">// error</span></span><br><span class="line"><span class="keyword">var</span> b : <span class="built_in">Long</span>? = a.toLong()</span><br></pre></td></tr></table></figure><h2 id="Char类型"><a href="#Char类型" class="headerlink" title="Char类型"></a>Char类型</h2><p>kotlin中的<code>Char</code>表示字符。但是和Java不同，他不能直接当ASCII码值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(c : <span class="type">Char</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123; <span class="comment">// error </span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h2><p>kotlin中的布尔类型用<code>Boolean</code>来表示，他有两个值<code>true</code>和<code>false</code>。用法和Java一样。</p><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>和Java一样，kotlin中的字符串也是<code>String</code>。但是kotlin中<code>String</code>是不可变的。所以kotlin中<code>String</code>必须是<code>val</code>类型。同时，<code>String</code>是<code>final</code>不可继承的。</p><h2 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h2><p>kotlin中数组必须使用<code>Array</code>表示。<br>基本写法</p><blockquote><p>val array: Array&lt;类型&gt; = arrayOf(..)</p></blockquote><p>例如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**整型Int的数组*/</span></span><br><span class="line"><span class="keyword">val</span> arrayOfInt: IntArray = intArrayOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>)</span><br><span class="line"><span class="comment">/**字符Char类型的数组*/</span></span><br><span class="line"><span class="keyword">val</span> arrayOfChar: CharArray = charArrayOf(<span class="string">'H'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>,<span class="string">'W'</span>,<span class="string">'o'</span>,<span class="string">'r'</span>,<span class="string">'l'</span>,<span class="string">'d'</span>)</span><br><span class="line"><span class="comment">/**字符串String数组*/</span></span><br><span class="line"><span class="keyword">val</span> arrayOfString: Array&lt;String&gt; = arrayOf(<span class="string">"Hello"</span>,<span class="string">"World"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">//查看有多少个元素</span></span><br><span class="line">    println(arrayOfInt.size)</span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (char <span class="keyword">in</span> arrayOfChar)&#123;</span><br><span class="line">        println(char)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据所引获取数据,数组是从0开始的，现在获取第二个东京大学</span></span><br><span class="line">    println(arrayOfUniversity[<span class="number">1</span>])</span><br><span class="line">    <span class="comment">//重新给数组赋值，早稻田大学</span></span><br><span class="line">    arrayOfUniversity[<span class="number">1</span>] = University(<span class="string">"早稻田大学"</span>)</span><br><span class="line">    println(arrayOfUniversity[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将char连接成一个字符串,默认是自动由逗号","分割的，输出H, e, l, l, o, W, o, r, l, d</span></span><br><span class="line">    println(arrayOfChar.joinToString())</span><br><span class="line">    <span class="comment">//如果想要连成HelloWorld</span></span><br><span class="line">    println(arrayOfChar.joinToString (<span class="string">""</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组的切片,输出3，5,结尾需要arrayOfInt-1，不然会报索引越界异常</span></span><br><span class="line">    println(arrayOfInt.slice(<span class="number">1</span>..<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    println(arrayOfInt.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin Anko入门</title>
      <link href="/posts/62bb1dd7.html"/>
      <url>/posts/62bb1dd7.html</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin-Anko入门"><a href="#Kotlin-Anko入门" class="headerlink" title="Kotlin Anko入门"></a>Kotlin Anko入门</h1><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Anko的官网就是他的GitHub地址</p><blockquote><p><a href="https://github.com/Kotlin/anko" target="_blank" rel="noopener">https://github.com/Kotlin/anko</a></p></blockquote><p>官方对Anko的解释是</p><blockquote><p>Anko是一个 <a href="https://www.kotlinlang.org/" target="_blank" rel="noopener">Kotlin</a> 库，它使Android应用程序开发更快更容易。它使您的代码清晰易读，让您忘记Android SDK for Java的粗糙边缘。</p></blockquote><a id="more"></a><p>为什么这样说呢？<br>比方说如果你写Android，你在xml中定义了一个<code>Button</code>，他的ID是<code>button_login</code>。如果是Java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setContentView(R.layout.activity_words_detail);</span><br><span class="line">Button button = findViewById(R.Id.button_login);</span><br></pre></td></tr></table></figure><p>而如果你使用kotlin的话，你可以就按如下代码写</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_kotlin_main.*</span><br><span class="line">...</span><br><span class="line">button_login.setText(<span class="string">"Kotlin Android Extensions 我不太喜欢"</span>);</span><br></pre></td></tr></table></figure><p>这样确实比Java方便多了，不需要对每一个组件都定义再findViewById，可以就直接输入组件的id然后就能使用了。但是我们还是觉得不够啊，为什么我们不能就直接在代码中写入各个组件呢，于是，Anko来了。</p><h1 id="导入Anko"><a href="#导入Anko" class="headerlink" title="导入Anko"></a>导入Anko</h1><p>Anko由几部分组成：</p><ul><li><em>Anko Commons</em>：一个轻量级的库，包含用于Layouts，Intent，Log等的帮助程序;</li><li><em>Anko Layouts</em>：一种快速且类型安全的方式来编写动态Android布局;</li><li><em>Anko SQLite</em>：Android SQLite的查询DSL和解析器集合;</li><li><em>Anko Coroutines</em>：基于<a href="https://github.com/Kotlin/kotlinx.coroutines" target="_blank" rel="noopener">kotlinx.coroutines</a>库的实用程序。</li></ul><p>你可以在app的<code>build.gradle</code>中添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">     <span class="comment">// Anko Layouts</span></span><br><span class="line">    implementation <span class="string">"org.jetbrains.anko:anko-sdk25:$anko_version"</span> <span class="comment">// sdk15, sdk19, sdk21, sdk23 are also available</span></span><br><span class="line">    implementation <span class="string">"org.jetbrains.anko:anko-appcompat-v7:$anko_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Coroutine listeners for Anko Layouts</span></span><br><span class="line">    implementation <span class="string">"org.jetbrains.anko:anko-sdk25-coroutines:$anko_version"</span></span><br><span class="line">    implementation <span class="string">"org.jetbrains.anko:anko-appcompat-v7-coroutines:$anko_version"</span>&#125;</span><br></pre></td></tr></table></figure><p>这个依赖可以直接导入所有的可用特性（包括Commons, Layouts, SQLite)。</p><h1 id="使用Anko-layout"><a href="#使用Anko-layout" class="headerlink" title="使用Anko layout"></a>使用Anko layout</h1><h2 id="创建简单布局"><a href="#创建简单布局" class="headerlink" title="创建简单布局"></a>创建简单布局</h2><p>使用Anko创建布局很简单：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        verticalLayout &#123;</span><br><span class="line">            padding = dip(<span class="number">30</span>)</span><br><span class="line">            editText &#123;</span><br><span class="line">                hint = <span class="string">"Name"</span></span><br><span class="line">                textSize = <span class="number">24f</span></span><br><span class="line">            &#125;</span><br><span class="line">            editText &#123;</span><br><span class="line">                hint = <span class="string">"Password"</span></span><br><span class="line">                textSize = <span class="number">24f</span></span><br><span class="line">            &#125;</span><br><span class="line">            button(<span class="string">"登录"</span>) &#123;</span><br><span class="line">                textSize = <span class="number">26f</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你只需要在Activity中写入DSL代码就能使用它。</p><h2 id="AnkoComponent"><a href="#AnkoComponent" class="headerlink" title="AnkoComponent"></a>AnkoComponent</h2><p>尽管我们现在可以直接在Activity中写入DSL代码，但是我们还是觉得把代码和布局文件放在一起不太好，希望把Activity和DSl代码放到两个不同的类里面，所以AnkoComponent就出来了。<br>代码如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        MainActivityUI().setContentView(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivityUI</span> : <span class="type">AnkoComponent</span>&lt;<span class="type">MainActivity</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createView</span><span class="params">(ui: <span class="type">AnkoContext</span>&lt;<span class="type">MainActivity</span>&gt;)</span></span> = with(ui) &#123;</span><br><span class="line">        verticalLayout &#123;</span><br><span class="line">            padding = dip(<span class="number">30</span>)</span><br><span class="line">            editText &#123;</span><br><span class="line">                hint = <span class="string">"Name"</span></span><br><span class="line">                textSize = <span class="number">24f</span></span><br><span class="line">            &#125;</span><br><span class="line">            editText &#123;</span><br><span class="line">                hint = <span class="string">"Password"</span></span><br><span class="line">                textSize = <span class="number">24f</span></span><br><span class="line">            &#125;</span><br><span class="line">            button(<span class="string">"登录"</span>) &#123;</span><br><span class="line">                textSize = <span class="number">26f</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h2><p>在Anko如果你想设置Theme需要使用<code>themeable</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">verticalLayout &#123;</span><br><span class="line">    padding = dip(<span class="number">30</span>)</span><br><span class="line">    themedButton(<span class="string">"登陆"</span>, theme = R.style.Base_TextAppearance_AppCompat_Button)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LayoutParams"><a href="#LayoutParams" class="headerlink" title="LayoutParams"></a>LayoutParams</h2><p>在Anko中也可以使用<code>LayoutParams</code>。比方说我现在要显示一个button，下面显示一个图片。</p><p>如果使用XML:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Hello World!"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">center</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"20sp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"@color/colorAccent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是使用Anko:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">verticalLayout &#123;</span><br><span class="line">    textView (<span class="string">"Hello World!"</span>) &#123;</span><br><span class="line">        textSize = sp(<span class="number">12</span>).toFloat()</span><br><span class="line">    &#125;.lparams(height = wrapContent, width = wrapContent) &#123;</span><br><span class="line">        horizontalGravity = Gravity.CENTER_HORIZONTAL</span><br><span class="line">    &#125;</span><br><span class="line">    imageView &#123;</span><br><span class="line">        backgroundColor = Color.BLUE</span><br><span class="line">    &#125;.lparams(height = matchParent, width = matchParent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>horizontalMargin</code> 同时设置 left 和 right margins</li><li><code>verticalMargin</code> 同时设置 top 和 bottom</li><li><code>margin</code> 同时设置4个方向的 margins</li></ul><h2 id="Listeners"><a href="#Listeners" class="headerlink" title="Listeners"></a>Listeners</h2><p>在Anko中设置<code>Listeners</code>非常简单，我下面以<code>Button</code>的<code>OnClick</code>举例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button(<span class="string">"登录"</span>) &#123;</span><br><span class="line">    id = buttonLogin</span><br><span class="line">    textSize = <span class="number">26f</span></span><br><span class="line">    onClick &#123; toast(<span class="string">"OnClickLoginButton"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Fragment加载"><a href="#使用Fragment加载" class="headerlink" title="使用Fragment加载"></a>使用Fragment加载</h2><p>先创建一个<code>Activity</code>，把<code>Fragment</code>加进去</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnkoFragmentActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        linearLayout &#123;</span><br><span class="line">            id = R.id.fragment_id</span><br><span class="line">            supportFragmentManager.beginTransaction().replace(id, AnkoFragment.newInstance()).commit()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>Fragment</code>的<code>onCreateView()</code>中加入DSL代码，然后返回<code>View</code>即可</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnkoFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">        <span class="comment">// return inflater.inflate(R.layout.fragment_anko, container, false)</span></span><br><span class="line">        <span class="keyword">return</span> UI &#123;</span><br><span class="line">            verticalLayout &#123;</span><br><span class="line">                editText()</span><br><span class="line">                button(<span class="string">"OK"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.view</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newInstance</span><span class="params">()</span></span>: AnkoFragment &#123;</span><br><span class="line">            <span class="keyword">return</span> AnkoFragment()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>AnkoLayout确实挺好的，因为他把UI代码集成到了代码文件中，不用再像以前一样写一个点击事件还得先<code>findViewBuId</code>，然后再<code>setOnClickListeners</code>。代码能非常简洁。</p><p>但是AnkoLayout还是不够完美，感觉写起来还是没有XML那个顺手（可能是我写惯了XML，刚开始用Anko还不够熟练），而且Anko还有很多控件都不支持。<br>最重要的是，<strong>他没有实时预览</strong>！！！</p><blockquote><p>Android Studio里面有一个叫<code>Anko Support</code>的插件，可以实现anko的预览，但是他必须是先将项目构建了再预览的，不算是实时预览</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android类之SharedPreferences</title>
      <link href="/posts/8a47fe84.html"/>
      <url>/posts/8a47fe84.html</url>
      
        <content type="html"><![CDATA[<h1 id="Android类之SharedPreferences"><a href="#Android类之SharedPreferences" class="headerlink" title="Android类之SharedPreferences"></a>Android类之SharedPreferences</h1><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>SharedPreferences是一个轻量的存储类，用于把一些只需要少量简单类型数据保存到本地，例如搜索历史、用户设置等。 他只适合处理简单的数据，处理太过于庞大的数据会减慢程序运行。</p><a id="more"></a><h1 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h1><h2 id="1-存储数据"><a href="#1-存储数据" class="headerlink" title="1. 存储数据"></a>1. 存储数据</h2><ol><li>使用Activity类的getSharedPreferences()方法获得SharedPreferences对象，其中存储key-value的文件名由getSharedPreferences()方法的第一个参数指定。</li><li>使用SharedPreferences接口的edit()获得SharedPreferences.Editor对象。</li><li>通过SharedPreferences.Editor接口的putXxx()方法保存key-value对，其中Xxx表示不同的数据类型。例如：字符串类型的value需要用putString方法。</li><li>通过SharedPreferences.Editor接口的commit()方法保存key-value对，commit方法相当于数据库事务中的提交操作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences sharedPreferences = getSharedPreferences(<span class="string">"test"</span>, Context.MODE_PRIVATE);</span><br><span class="line">Editor editor = sharedPreferences.edit();<span class="comment">//获取编辑器</span></span><br><span class="line">editor.putString(<span class="string">"name"</span>, <span class="string">"小明"</span>);</span><br><span class="line">editor.putInt(<span class="string">"age"</span>, <span class="number">24</span>);</span><br><span class="line">editor.commit();<span class="comment">//提交修改</span></span><br></pre></td></tr></table></figure><h2 id="2-读取数据"><a href="#2-读取数据" class="headerlink" title="2. 读取数据"></a>2. 读取数据</h2><ol><li>使用Activity类的getSharedPreferences()方法获得SharedPreferences对象。</li><li>通过SharedPreferences对象的getXxx()方法得到数据。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences sharedPreferences= getSharedPreferences(<span class="string">"test"</span>, Activity.MODE_PRIVATE);</span><br><span class="line"><span class="comment">// 使用getString方法获得value，注意第2个参数是value的默认值   </span></span><br><span class="line">String name =sharedPreferences.getString(<span class="string">"name"</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">int</span> age =sharedPreferences.getInt(<span class="string">"age"</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><code>SharedPreferences</code>的四种模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Context.MODE_PRIVATE：为默认操作模式,代表该文件是私有数据,只能被应用本身访问,在该模式下,写入的内容会覆盖原文件的内容</span><br><span class="line">Context.MODE_APPEND：模式会检查文件是否存在,存在就往文件追加内容,否则就创建新文件.</span><br><span class="line">Context.MODE_WORLD_READABLE：表示当前文件可以被其他应用读取.</span><br><span class="line">Context.MODE_WORLD_WRITEABLE：表示当前文件可以被其他应用写入.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AndroidView之PopupWindow</title>
      <link href="/posts/1900f7eb.html"/>
      <url>/posts/1900f7eb.html</url>
      
        <content type="html"><![CDATA[<h1 id="AndroidView之PopupWindow"><a href="#AndroidView之PopupWindow" class="headerlink" title="AndroidView之PopupWindow"></a>AndroidView之PopupWindow</h1><p>因为项目中有很多地方都需要使用PopupWindow，所以特别查了一下，做了一个简单的总结，过两天就加到项目中去。</p><a id="more"></a><h1 id="PopupWindow"><a href="#PopupWindow" class="headerlink" title="PopupWindow"></a>PopupWindow</h1><p>PopupWindow，顾名思义，就是一个用来显示弹窗的组件。</p><h1 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h1><ol><li>创建PopupWindow实例</li><li>设置一些基本参数</li><li>显示PopupWindow<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PopupWindow window = <span class="keyword">new</span> PopupWindow(View contentView, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">boolean</span> focusable);</span><br></pre></td></tr></table></figure><p>这个方法有四个参数，第一个参数是用于PopupWindow中的View，第二个参数是PopupWindow的宽度，第三个参数是PopupWindow的高度，第四个参数指定PopupWindow能否获得焦点。</p><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">View contentView = LayoutInflater.from(MainActivity.<span class="keyword">this</span>).inflate(R.layout.popuplayout, <span class="keyword">null</span>);</span><br><span class="line">PopupWindwo window = PopupWindow (contentView, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h1 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h1><ul><li>window.setBackgroundDrawable(Drawable background); 设置PopupWindow的背景</li><li>window.setOutsideTouchable(boolean touchable); 设置PopupWindow是否能响应外部点击事件</li><li>window.setTouchable(boolean touchable); 设置PopupWindow是否能响应点击事件<br>只有同时设置PopupWindow的背景和可以响应外部点击事件，它才能“真正”响应外部点击事件。</li></ul><h1 id="显示PopupWindow"><a href="#显示PopupWindow" class="headerlink" title="显示PopupWindow"></a>显示PopupWindow</h1><ul><li>window.showAtLocation(View parent, int gravity, int x, int y); 第一个参数是PopupWindow的父View，第二个参数是PopupWindow相对父View的位置，第三和第四个参数分别是PopupWindow相对父View的x、y偏移</li><li>window.showAsDropDown(View anchor, int xoff, int yoff, int gravity); 第一个参数是PopupWindow的锚点，第二和第三个参数分别是PopupWindow相对锚点的x、y偏移</li></ul><h1 id="为PopupWindow添加动画"><a href="#为PopupWindow添加动画" class="headerlink" title="为PopupWindow添加动画"></a>为PopupWindow添加动画</h1><ul><li>进入时动画：(context_menu_enter.xml)</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;set xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration=<span class="string">"@android:integer/config_shortAnimTime"</span></span><br><span class="line">        android:fromXDelta=<span class="string">"0"</span></span><br><span class="line">        android:fromYDelta=<span class="string">"100%p"</span></span><br><span class="line">        android:interpolator=<span class="string">"@android:anim/accelerate_decelerate_interpolator"</span></span><br><span class="line">        android:toXDelta=<span class="string">"0"</span></span><br><span class="line">        android:toYDelta=<span class="string">"0"</span>/&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure><ul><li>退出时动画：(context_menu_exit.xml)</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;set xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span> &gt;</span><br><span class="line"> </span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration=<span class="string">"@android:integer/config_shortAnimTime"</span></span><br><span class="line">        android:fromXDelta=<span class="string">"0"</span></span><br><span class="line">        android:fromYDelta=<span class="string">"0"</span></span><br><span class="line">        android:interpolator=<span class="string">"@android:anim/accelerate_decelerate_interpolator"</span></span><br><span class="line">        android:toXDelta=<span class="string">"0"</span></span><br><span class="line">        android:toYDelta=<span class="string">"100%p"</span> /&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure><ul><li>生成style</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;contextMenuAnim&quot; parent=&quot;@android:style/Animation.Activity&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowEnterAnimation&quot;&gt;@anim/context_menu_enter&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowExitAnimation&quot;&gt;@anim/context_menu_exit&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
