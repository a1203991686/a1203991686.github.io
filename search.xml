<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解JVM-类加载器]]></title>
    <url>%2Fposts%2F594da31f.html</url>
    <content type="text"><![CDATA[1. 概念虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流(即字节码)”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。 一般来说，Java 虚拟机使用 Java 类的方式如下： Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成字节码（.class 文件）。 类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。 实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。更详细的内容可以参考上一篇文章中讲类加载过程中的加载阶段时介绍的几个例子（JAR包、Applet、动态代理、JSP等）。 2. 类与类加载器类加载器虽然只用于实现类的加载动作，但他在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载他的类加载器和这个类本身异同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。 通俗一点就是：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等（这里指的相等，包括类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof()关键字对做对象所属关系判定等情况）。 3. 双亲委派模型从Java虚拟机角度来讲，只存在两种不同的类加载器： 启动类加载器（Bootstrap ClassLoader），这个类加载器用C++实现，是虚拟机自身的一部分 所有其他类的加载器，这些类加载器由Java实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader 从Java开发人员角度来看，类加载器还可以划分的更细致一些： 启动类加载器（Bootstrap ClassLoader） 此类加载器负责将存放在 \lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在lib 目录中也不会被加载）类库加载到虚拟机内存中。 启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，直接使用null代替即可。 扩展类加载器（Extension ClassLoader） 这个类加载器是由ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将/lib/ext或者被 java.ext.dir系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader） 这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 由开发人员开发的应用程序都是由这三种类加载器相互配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这些类加载器的关系一般如下图所示： 上图展示的类加载器之间的层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器，这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现。 3.1 工作过程如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。 这样的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。无论哪个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。 相反，如果没有使用双亲委派模式，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。 3.2 实现双亲委派模型的实现很简单，主要都集中在java.lang.ClassLoader的loadClass()方法中：先检查是否已经被加载过，如果没有，就调用父加载器的loadClass()，若父加载器为空，则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。 12345678910111213141516171819202122232425protected synchronized Class&lt;?&gt; loadClass(String name,boolean resolve)throws ClassNotFoundException&#123; // 首先，检查请求的类是否已经加载过了 Class c = findLoadedClass(name); if(c == null)&#123; try&#123; if(parent != null)&#123; c = parent.loadClass(name,false); &#125;else&#123; c = findBootstrapClassOrNull(name); &#125; &#125;catch(ClassNotFoundException e)&#123; // 如果父类加载器抛出ClassNotFoundException // 说明父类加载器无法完成加载请求 &#125; if(c == null)&#123; // 在父类加载器无法加载的时候 // 再调用本身的findClass方法进行类加载 c = findClass(name); &#125; &#125; if(resolve)&#123; resolveClass(c); &#125; return c;&#125; 4. 破坏双亲委派模型三种破坏双亲委派模型的方式： 4.1 JDK1.2引入的双亲委派模型和JDK1.0就有的ClassLoader双亲委派模型是JDK1.2之后才被引用的，而在JDK1.0就有ClassLoader了。所以面对已存在的用户自定义类加载器的实现代码，Java设计者引入了双亲委派模型时不得不做出一些妥协。 为了向前兼容，JDK1.2之后的java.lang.ClassLoader添加了一个新的protected方法findClass()。开发者只需要将自己的类加载逻辑代码写到findClass()方法中，在loadClass()方法的逻辑里如果父类加载失败，就会调用自己的findClass()方法来完成加载，这样就可以保证新写出来的类加载器符合双亲委派规则。 4.2 线程上下文类加载器这个是因为双亲委派模式自身设计缺陷导致的。 双亲委派很好解决了各个类加载器的基础类统一的问题，但是如果基础类要调用会用户的代码咋办？ 这个使用场景我不太了解，我看书上和别人博客上的例子也看不懂。我只能抄一下别人的例子。 Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。这些 SPI 的接口由 Java 核心库来提供，如 JAXP 的 SPI 接口定义包含在 javax.xml.parsers包中。这些 SPI 的实现代码很可能是作为 Java 应用所依赖的 jar 包被包含进来，可以通过类路径（ClassPath）来找到，如实现了 JAXP SPI 的 Apache Xerces所包含的 jar 包。SPI 接口中的代码经常需要加载具体的实现类。如 JAXP 中的 javax.xml.parsers.DocumentBuilderFactory类中的 newInstance() 方法用来生成一个新的 DocumentBuilderFactory 的实例。这里的实例的真正的类是继承自 javax.xml.parsers.DocumentBuilderFactory，由 SPI 的实现所提供的。如在 Apache Xerces 中，实现的类是 org.apache.xerces.jaxp.DocumentBuilderFactoryImpl。而问题在于，SPI 的接口是Java 核心库的一部分，是由引导类加载器加载的，而SPI 实现的 Java 类一般是由系统类加载器加载的。引导类加载器是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能委派给系统类加载器，因为它是系统类加载器的祖先类加载器。也就是说，类加载器的双亲委派模型无法解决这个问题。 为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。线程上下文类加载器是从 JDK 1.2 开始引入的。类 java.lang.Thread中的方法 getContextClassLoader()和 setContextClassLoader(ClassLoader cl)用来获取和设置线程的上下文类加载器。如果没有通过 setContextClassLoader(ClassLoader cl)方法进行设置的话，线程将继承其父线程的上下文类加载器。Java 应用运行的初始线程的上下文类加载器是应用程序类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。 4.3 程序动态性这里所说的“动态性”指的是当前一些非常热门的名词：代码热替换（HotSwap）、模块热部署(Hot Deployment)等。即希望应用程序能像计算机的外设一样，接上鼠标、键盘，不用重启就能立即使用，鼠标出了问题或需要升级就换个鼠标，不用停机或重启。 当前业界“事实上”的Java模块化标准是OSGi，而OSGi实现代码热部署的关键则是它自定义的类机载器的实现。 每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。 在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索： 将以java.*开头的类委派给分类加载器加载 否则，将委派列表名单内的类委派给父类加载器加载 否则，将import列表中的类委派给Export这个类的Bundle的类加载器加载 否则，查找当前Bundle的ClassPath，使用自己的类加载器加载 否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载 否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载 否则，类查找失败]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM-虚拟机类加载机制]]></title>
    <url>%2Fposts%2F65c09aaf.html</url>
    <content type="text"><![CDATA[1. 概述虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 Java类型的加载、连接和初始化过程都是在程序运行期间完成的，为Java应用程序提供高度的灵活性 2. 类加载的时机类从被加载到虚拟机内存中开始，到卸载处内存为止它的整个生命周期包括： 加载（Loading） 验证 （Verification） 准备（Preparation） 解析（Resolution） 初始化（Initialization） 使用（Using） 卸载（Unloading） 验证、解析、准备统称为连接（Linking） 其中，加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的。但是解析不一定，某些情况下可以在初始化之后再开始，这是为了支持Java的运行时绑定。 2.1 加载的时机这个Java虚拟机规范中并没有进行强制约束，这个可以交给虚拟机自订。 2.2 初始化的时机对于初始化的时机，虚拟机规范强制规定只有5中情况必须立即对类进行“初始化” 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有初始化过，则需要先触发其初始化。对应着使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段外）的时候，以及调用一个类的静态方法的时候 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化 当虚拟机启动时，用户需要制定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化 而对于接口，当一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口时（如引用父接口中定义的常量）才会初始化。 这五种场景中的行为称为对一个类进行主动引用所有引用类的方式都不会触发初始化，被称为被动引用。 通过子类引用父类的静态字段，不会导致子类初始化。 对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中的静态字段，只会触发父类的初始化，而不会触发子类的初始化 通过数组定义来引用类，不会触发此类的初始化 常量在编译阶段会存储调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化 3. 类加载的过程分为加载、验证、准备、解析和初始化5个阶段 3.1 加载加载是类加载中的一个阶段。 在加载阶段，虚拟机需要完成以下3件事 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存汇总生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 虚拟机对这几点的要求其实并不具体，因此虚拟机实现与具体应用的灵活度都是相当大的。 例如第一条，他只说了获取二进制字节流，但是没说具体从哪获取。所以这一点为很多Java技术都建立了基础： 从ZIP包读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。 从网络中获取，这种场景最典型的应用是Applet。 运行时计算生成，这种场景使用得最多得就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass的代理类的二进制字节流。 由其他文件生成，典型场景是JSP应用，即由JSP文件生成对应的Class类。 从数据库读取，这种场景相对少见，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。 3.1.1 非数组类的加载相对于类加载过程的其它阶段，一个非数组类的加载阶段是开发人员可控性最强的。因为加载阶段既可以使用系统提供的引导类加载类去完成，也可以由用户自定义的类加载器去完成，通过定义自己的类加载器去控制字节流的获取，即重写一个类加载器的loadClass()方法。 3.1.2 数组类的加载数据类本身不通过类加载器创建，她是由Java虚拟机直接创建的。 但是数据类的元素类型（数组去掉所有维度的类型）最终是要靠加载器去创建。 一个数组类创建过程必须遵循以下规则： 如果数组的组件类型（数组去掉一个维度的类型）是引用类型，那就递归采用本书定义的加载过程去加载这个组件类型，数组类将在加载该组件类型的类加载器的类名称空间上被标识 如果数组的组件类型不是引用类型，Java虚拟机将会数组类标记为与引导类加载器关联 数组类的可见性与他的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的这些类型数据的外部接口。 3.2 验证验证是连接阶段的第一步，为了确保输入的Class文件的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求，并且不会危害虚拟机自身的安全。 如果不检查输入的字节流，对齐完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。 验证阶段是非常重要的，这个阶段是否严瑾，直接决定了Java虚拟机是否能承受恶意代码的攻击，从性能的角度上讲，验证阶段的工作量在虚拟机的类加载子系统又占了相当大的一部分。 从整体上看，验证阶段大致会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。 3.2.1 文件格式验证第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。 可能包括以下验证点： 是否以魔数0xCAFEBABE开头 主、次版本号是否在当前虚拟机处理范围之内 常量池的常量中是否有不被支持的常量类型 指向常量的各种索引值是否有指向不存在的常量或不符合类型的常量 CONSTANT_Utf8_info型的常量是否有不符合UTF8编码的数据 Class文件中各个部分及文件本身是否有被删除的或附加的其它信息 …… 该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。 这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证都是基于方法区的存储结构进行的，不会再直接操作字节流。 3.2.2 元数据验证第二阶段是对字节码描述的信息进行语法分析，以保证其描述的信息符合Java语言规范的要求。 可能包括以下验证点： 这个类是否有父类（除了Object之外，其他类都有父类） 这个类的父类是否继承了不允许被继承的类（被final修饰的类） 如果这个类不是抽象类，是否实现了其父类或接口中要求实现的方法 类中的字段、方法是否与父类产生矛盾 …… 主要目的是对类的元数据信息就行语义检验，保证不存在不符合Java语言规范的元数据信息。 3.2.3 字节码验证第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确实程序语义是合法的、符合逻辑的。 在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。 由于数据流校验的高复杂性，耗时较大，所以JDK1.6之后，在Javac中引入一项优化方法（可以通过参数关闭）：在方法体的Code属性的属性表中增加一项“StackMapTable”属性，该属性描述了方法体中所有基本块开始时本地变量表和操作栈应有的状态，从而将字节码验证的类型推导转变为类型检查从而节省一些时间。 如果一个类方法体的字节码没有通过字节码验证，那一定是有问题的；但是如果通过了，那不一定是完全没问题的。 3.2.4 符号引用验证最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。 符号引用的验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验下列内容： 符号引用中通过字符串描述的全限定名是否能找到对应的类。 指定的类中是否存在符合描述符与简单名称描述的方法与字段。 符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。 …… 符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出一个java.lang.IncompatibleClassChangeError异常的子类。 3.2.5 验证总结对于jvm的类加载机制来说，验证阶段是一个非常重要但不是一定必要（因为对运行期没有影响）的阶段。如果所运行的全部代码都已经被反复验证过，那么在实施阶段就可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 3.3 准备任务: 为类变量分配内存 设置类变量初始值 这些变量所使用的内存都将在方法区中进行分配。 首先，在准备阶段进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。 其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为： 1public static int value = 123; 那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器()方法之中，所以把value赋值为123的动作在初始化阶段才会执行。 值得注意的是，如果类字段的字段属性中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，假设上面类变量value的定义变为： 1public static final int value = 123; 编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。 3.4 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 3.4.1 什么是符号引用和直接引用那我们吸纳来说一下符号引用和直接引用的概念： 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须一致，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。 直接饮用：直接引用可以是直接目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局有关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那么引用的目标必定已经在内存中存在。 虚拟机规范没有规定解析阶段发生的具体时间，虚拟机实现可以根据需要来判断到底是在类被加载时解析还是等到一个符号引用将要被使用前才去解析。 3.4.2 对解析结果进行缓存同一符号引用进行多次解析请求是很常见的，除invokedynamic指令以外，虚拟机实现可以对第一次解析结果进行缓存，来避免解析动作重复进行。无论是否真正执行了多次解析动作，虚拟机需要保证的是在同一个实体中，如果一个引用符号之前已经被成功解析过，那么后续的引用解析请求就应当一直成功；同样的，如果 第一次解析失败，那么其他指令对这个符号的解析请求也应该收到相同的异常。 但是以上规则对invokedynamic不成立。当碰到某个前面已经由invokedynamic指令触发过解析的符号引用时，并不意味着这个解析结果对其它invokedynamic指令也同样生效。 原因是因为这个指令用于动态语言支持，也就是等程序执行到这条指令时，才去解析。相对的，其它的都是静态的，也就是刚完成加载阶段，还没开始执行代码就解析了。 3.4.3 解析的对象解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。 对于后面3中，与JDK1.7新增的动态语言支持有关。 3.5 初始化类初始化阶段是类加载过程的最后一步。 前面的过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。而在从初始化阶段开始，才是真正的执行定义的Java程序代码。 在准备阶段时，我们说过这时程序已经为static修饰的类变量进行了初始化操作。而当时我们也说过，在准备阶段初始化的值只是Java对该变量定义的默认值，就好比int是0，float是0.0f，Boolean是false。他才不管你在代码里面有没有给这些变量定义值。 而在初始化阶段，才是根据程序员通过程序制定的主观计划去初始化类变量和其他资源。简单点说，初始化阶段是执行类构造器&lt;client&gt;()方法的过程。 下面来详细讲讲&lt;client&gt;()方法是怎么生成的： &lt;client&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定，特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码： 1234567public class Test &#123; static &#123; i = 0; // 给变量复制可以正常编译通过 System.out.print(i); // 这句编译器会提示“非法向前引用” &#125; static int i = 1;&#125; &lt;clinit&gt;()方法与类的构造函数（或者说实例构造器&lt;init&gt;()方法）不同，不需要显式的调用父类的()方法。虚拟机会自动保证在子类的&lt;clinit&gt;()方法运行之前，父类的&lt;clinit&gt;()方法已经执行结束。因此虚拟机中第一个执行&lt;clinit&gt;()方法的类肯定为java.lang.Object。 由于父类的&lt;clinit&gt;()方法先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作。例如以下代码： 1234567891011121314static class Parent &#123; public static int A = 1; static &#123; A = 2; &#125;&#125;static class Sub extends Parent &#123; public static int B = A;&#125;public static void main(String[] args) &#123; System.out.println(Sub.B);//输出结果是父类中的静态变量值A，也就是2&#125; &lt;clinit&gt;()方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成&lt;clinit&gt;()方法。 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成&lt;clinit&gt;()方法。但接口与类不同的是，执行接口的&lt;clinit&gt;()方法不需要先执行父接口的&lt;clinit&gt;()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的&lt;clinit&gt;()方法。 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的&lt;clinit&gt;()方法，其它线程都会阻塞等待，直到活动线程执行&lt;clinit&gt;()方法完毕。如果在一个类的&lt;clinit&gt;()方法中有耗时的操作，就可能造成多个进程阻塞，在实际过程中此种阻塞很隐蔽。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合源码之HashMap]]></title>
    <url>%2Fposts%2F2982320f.html</url>
    <content type="text"><![CDATA[简介HashMap是一个哈希表，线程不安全，key唯一，value可重复，允许key和value为null。遍历时是无序的。 底层结构是基于链表散列，也就是数组+链表。数组也被称为哈希桶，桶里面就装着链表，链表中的每个节点，就是哈希表中的每个元素。 在JDK8中，当链表长度达到8的时候，就会转为红黑树。 它实现了Map&lt;K, V&gt;, Cloneable, Serializable接口。 接下来我们就来看下源码： 属性1234567891011121314151617181920212223242526272829303132333435// 序列化ID，用于序列化和反序列化private static final long serialVersionUID = 362498820763181265L;// 默认初始容量也就是16-必须为2的幂。static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16// 最大容量。// 如果两个构造函数都使用参数隐式指定了更高的值，则使用该容量。 // 必须是2的30次方。static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// 默认的负载因子static final float DEFAULT_LOAD_FACTOR = 0.75f;// Entry数组，也就是哈希桶，长度为2的n次幂transient Node&lt;K,V&gt;[] table;/** * 保存缓存的entrySet()。 注意，AbstractMap字段用于keySet（）和values（）。 */transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;/** * 包含的键-值对的数，也就是元素的个数 */transient int size;// 这个与fast-fail有关，可以参考我上一篇将ArrayList部分博客的modCount变量。transient int modCount;// 当前 HashMap 所能容纳键值对数量的最大值，超过这个值，则需扩容int threshold;// 负载因子final float loadFactor; 这些可能现在看起来还很迷，可能都不知道有些变量到底是拿来干嘛的。不急，我们继续往后面看。 构造方法1234567891011121314151617181920212223242526272829303132333435363738// 构造一个指定初始容量和构造因子的HashMappublic HashMap(int initialCapacity, float loadFactor) &#123; // 如果指定的初始容量小于0，抛异常 if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); // 如果指定的初始容量大于设定好的最大容量 if (initialCapacity &gt; MAXIMUM_CAPACITY) // 就直接把初始容量设置为最大容量 initialCapacity = MAXIMUM_CAPACITY; // 如果负载因子小于0或者为空，抛异常 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); // 赋值 this.loadFactor = loadFactor; // -&gt;&gt; 分析3.1 this.threshold = tableSizeFor(initialCapacity);&#125;// 构造一个具有指定容量和默认负载因子的HashMap。public HashMap(int initialCapacity) &#123; // 调用了上面那个构造方法 this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;// 无参构造方法public HashMap() &#123; // 直接加载默认负载因子 this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125;// 将Map里面的值传入HashMappublic HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; // 使用默认的加载因子 this.loadFactor = DEFAULT_LOAD_FACTOR; // 分析3.2 putMapEntries(m, false);&#125; 分析3.1 HashMap # tableSizeFor(int cap)12345678910111213/** * 分析 3.1 */static final int tableSizeFor(int cap) &#123; int n = cap - 1; // &gt;&gt;&gt; 无符号右移 n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 这个方法有点纠结，你光看代码确实看不出来个啥，但是如果你在纸上顺便找几个例子写写就懂了。 他的用途，总结起来就是：找到大于或等于cap的最小2的幂。 这里借用一下一位大佬的图： 这个图就是第一个例子。cap=536870913，经过运算之后，n+1=1073741824。 分析3.2 HashMap # putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)123456789101112131415161718192021222324252627282930313233final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; // 先拿到map的大小 int s = m.size(); // 如果map大于0才去进行操作，如果等于0那就证明Map是空的，就不进行操作 if (s &gt; 0) &#123; // 如果当前哈希表还是空的 if (table == null) &#123; // pre-size // 根据m的元素数量和当前表的加载因子，计算出阈值 float ft = ((float)s / loadFactor) + 1.0F; // 修正阈值的边界 不能超过MAXIMUM_CAPACITY int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); // 如果新的阈值大于当前阈值 if (t &gt; threshold) // 返回一个新的阈值的 满足2的n次方的阈值 // -&gt;&gt; 分析3.1 threshold = tableSizeFor(t); &#125; // 如果当前哈希表不是空的，而且map中元素个数大于当前的阈值，那就重新扩容 else if (s &gt; threshold) // 扩容 // -&gt;&gt; 分析3.3 resize(); // 遍历Map，取出map每一个键值对并复制给HashMap for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); // 将取出Key和Value放入HashMap // -&gt;&gt; 分析3.4 putVal(hash(key), key, value, false, evict); &#125; &#125;&#125; 分析3.3 HashMap # resize()重点！！！ 扩容函数。 先来看源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; // 旧数组也就是旧哈希桶的容量，如果oldTab为空就为0，否则为oldTab长度 int oldCap = (oldTab == null) ? 0 : oldTab.length; // 旧的阈值 int oldThr = threshold; int newCap, newThr = 0; // 如果旧哈希桶容量大于0 if (oldCap &gt; 0) &#123; // 如果旧哈希桶容量大于限定的最大值 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; // 阈值就设置为int的最大值 threshold = Integer.MAX_VALUE; return oldTab; &#125; // 否则新的容量是旧的容量的两倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; // 旧的容量为默认初始化容量也就是16 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) // 新的阈值也等于旧的阈值 newThr = oldThr &lt;&lt; 1; // double threshold &#125; // 如果当前表是空的，但是有阈值。代表是初始化时指定了容量、阈值的情况 else if (oldThr &gt; 0) // initial capacity was placed in threshold // 直接把新的容量的值设置为旧的阈值 newCap = oldThr; // 如果当前表是空的，而且也没有阈值。代表是初始化时没有任何容量/阈值参数的情况 else &#123; // zero initial threshold signifies using defaults // 新容量为默认的初始容量 newCap = DEFAULT_INITIAL_CAPACITY; // 新的阈值默认为默认负载因子 * 默认初始容量 = 16 * 0.7 = 12 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 如果新的阈值是0，对应的是 当前表是空的，但是有阈值的情况 if (newThr == 0) &#123; // 根据新表容量 和 加载因子 求出新的阈值 float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; // 更新阈值 threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) // 创建新的哈希桶 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; // 更新引用 table = newTab; // 如果以前的哈希桶中还有元素，那就把原来的数组复制过来 if (oldTab != null) &#123; // 遍历以前的哈希桶 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; // 如果当前节点不为空 if ((e = oldTab[j]) != null) &#123; // 把旧哈希桶中的该位置为空，方便GC回收 oldTab[j] = null; // 如果该节点的后一位为空了，也就是说哈希桶里面的链表只有一个节点 if (e.next == null) //直接将这个元素放置在新的哈希桶里。 //注意这里取下标 是用 哈希值 与 桶的长度-1 。 由于桶的长度是2的n次方，这么做其实是等于 一个模运算。但是效率更高 // 具体会在文章最后面讲 newTab[e.hash &amp; (newCap - 1)] = e; // 如果发生过哈希碰撞 ,而且是节点数超过8个，转化成了红黑树（暂且不谈 避免过于复杂， 后续专门研究一下红黑树） else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); // 如果发生过哈希碰撞，节点数小于8个。则要根据链表上每个节点的哈希值，依次放入新哈希桶对应下标位置。 else &#123; // preserve order // 由于现在容量加倍了，按照哈希表的算法，之前在这个哈希桶里面的现在不一定属于该哈希桶了 // 比如，之前哈希长度是4，有一个元素为5 // 未扩容前，他应该在5%4=1这个桶里面 // 但是现在扩容了，哈希长度变成了8，那么他现在就应该在5%8=5这个桶里面了 // 而且新桶的位置就是老位置1加上oldCap4，也就是j + oldCap = 1 + 4 = 5 // 代表扩容后还应该在老桶里面的元素 Node&lt;K,V&gt; loHead = null, loTail = null; // 代表扩容后应该在新桶里面的元素 Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 这里又是一个利用位运算 代替常规运算的高效点： 利用哈希值 与 旧的容量，可以得到哈希值去模后，是大于等于oldCap还是小于oldCap，等于0代表小于oldCap，应该存放在低位，否则存放在高位 if ((e.hash &amp; oldCap) == 0) &#123; // 以下均为简单的单链表操作 if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; // 以下均为简单的单链表操作 if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 遍历两个链表，把lo放到原来的位置上，并把hi放入新位置也就是j+oldCap if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 总结来说就是: 扩容 如果之前的哈希表有值，而且元素的个数大于限定的哈希表最大容量的话，那就把新的哈希表的阈值设置为Integer.MAX_VALUE也就是int的最大值，并直接返回旧和哈希表 如果之前的哈希表有值，而且元素个数没有大于哈希表最大容量，而且个数的两倍还小于限定的哈希表最大容量、元素个数大于默认的初始容量也就是16的话，就设置新的阈值为旧的阈值的2倍 如果之前的哈希表的空的，但是阈值是存在值的，也就相当于你初始化时指定了容量和阈值然后构造的哈希表，此时就直接让新的容量指定为旧的阈值 如果之前哈希表是空的，阈值也不大于0，也就相当于采用了无参构造，这时就直接让新容量为默认的初始容量也就是16，让新的阈值为默认负载因子默认初始容量 = 16 0.7 = 12 如果新的阈值是0的话，也就是在之前的4个判断中没有对新的阈值进行更改的情况，也就是之前的哈希表是空的，然后指定了阈值的情况，这是就根据新表的容量和负载因子求出新的阈值 复制到新表 如果以前的哈希表中有元素，就直接遍历原表，然后判断当前哈希桶里面有没有元素 如果有而且他的下一个为空，就代表这个链表只有一个节点，那就直接求出他的哈希值，然后给对应的哈希桶 如果他下一个不为空而且他是红黑树的实例，那就调用split方法 如果他下一个不为空，也不是红黑树的实例，那就开始遍历链表，判断当前及节点新的哈希值，如果还是当前值，那就放到lo链表上去，如果不是当前值，那就放到hi链表 然后遍历完成后，直接把lo链表放到当前哈希桶，把hi放到当前哈希值+旧的哈希数组长度也就是新的哈希值对应的哈希桶上去 分析3.4 HashMap # putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 如果哈希表是空的的话，代表是初始化的 if ((tab = table) == null || (n = tab.length) == 0) // 那就直接扩容哈希表，并且将扩容后的哈希桶长度赋值给n n = (tab = resize()).length; // 如果当前index的节点是空的，表示没有发生哈希碰撞。 直接构建一个新节点Node，挂载在index处即可。 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; // 发生哈希碰撞 Node&lt;K,V&gt; e; K k; // 如果哈希值相等、key也相等，那就直接覆盖 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 如果是红黑树的实例，暂时不讨论 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 如果以上情况都不满足，也就代表不是红黑树，但是该链表不止一个节点 else &#123; // 对链表进行遍历 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; // 放入链表最后面 p.next = newNode(hash, key, value, null); // 如果当前链表节点个数大于8 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st // 转为红黑树 treeifyBin(tab, hash); break; &#125; // 如果找到了要覆盖的节点 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // 如果e不为null，也就是说找到了需要覆盖的节点 if (e != null) &#123; // existing mapping for key V oldValue = e.value; // 如果onlyIfAbsent为false，或者oldValue不存在才进入if // onlyIfAvsent这个变量的意思是如果为true，则此key对应的节点有value的情况，否则是没有value的情况，此变量用于putIfAbsent方法 if (!onlyIfAbsent || oldValue == null) e.value = value; // 这是一个空实现的函数，用作LinkedHashMap重写使用 afterNodeAccess(e); return oldValue; &#125; &#125; // 由于节点插入成功，或者覆盖成功，所以需要修改modCount通知HashMap结构发生变化 ++modCount; // 更新size，如果size达到了阈值，那就扩容 if (++size &gt; threshold) resize(); // 这是一个空实现的函数，用作LinkedHashMap重写使用 afterNodeInsertion(evict); return null;&#125; 常用API增、改HashMap # put(K key, V value)功能： 如果原来的表里面没有key对应的节点，就把key和value插入 如果有对应的节点，就把将key对应节点的value更改为传入的value 1234public V put(K key, V value) &#123; // -&gt;&gt; 见分析3.4 return putVal(hash(key), key, value, false, true);&#125; HashMap # putAll(Map&lt;? extends K, ? extends V&gt; m)功能： 直接把Map里面的内容传入HashMap 1234public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; // -&gt;&gt; 分析3.2 putMapEntries(m, true);&#125; HashMap # putIfAbsent(K key, V value)功能： 根据key找到对应节点 如果该节点已经有value，就返回此value 否则就将此value插入，并返回null 12345@Overridepublic V putIfAbsent(K key, V value) &#123; // -&gt;&gt; 分析3.4 return putVal(hash(key), key, value, true, true);&#125; HashMap # replace(K key, V oldValue, V newValue)功能： 根据key和value找到对应节点，然后把旧值用newValue替换 123456789101112131415@Overridepublic boolean replace(K key, V oldValue, V newValue) &#123; Node&lt;K,V&gt; e; V v; // -&gt;&gt; 分析4.3.1 // 根据key找到对应的节点，并判断节点为不为空，以及此时的value的值等不等于传入的oldValue if ((e = getNode(hash(key), key)) != null &amp;&amp; ((v = e.value) == oldValue || (v != null &amp;&amp; v.equals(oldValue)))) &#123; // 替换为新值 e.value = newValue; // 这是一个空实现的函数，用作LinkedHashMap重写使用 afterNodeAccess(e); return true; &#125; return false;&#125; HashMap # replace(K key, V value)功能： 根据key找到对应的节点，然后直接把value替换过去 1234567891011121314151617@Overridepublic V replace(K key, V value) &#123; Node&lt;K,V&gt; e; // -&gt;&gt; 分析4.3.1 // 找到对应的节点，并判断为不为空 if ((e = getNode(hash(key), key)) != null) &#123; // 取出之前的值 V oldValue = e.value; // 替换为新的值 e.value = value; // 这是一个空实现的函数，用作LinkedHashMap重写使用 afterNodeAccess(e); // 把旧值返回 return oldValue; &#125; return null;&#125; 删remove(Object key)功能： 根据key找到节点并删除 123456public V remove(Object key) &#123; Node&lt;K,V&gt; e; // -&gt;&gt; 分析4.2.1 return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125; remove(Object key, Object value)功能： 根据key和value找到对应节点，然后删除 1234public boolean remove(Object key, Object value) &#123; // -&gt;&gt; 分析4.2.1 return removeNode(hash(key), key, value, true, true) != null;&#125; 分析4.2.1 HashMap # removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 分析4.2.1：HashMap.removeNode() */final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; // 如果哈希桶不为空并且哈希桶的长度大于0并且key对应的哈希桶不为空 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; // 如果链表第一个节点就是要删除的节点 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 直接赋值给node node = p; // 否则的话，看下一位是否为空，如果不为空，那就证明此处有链表或者红黑树 else if ((e = p.next) != null) &#123; // 红黑树 if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); // 不是红黑树，就代表只是链表，而且链表长度不超过8 else &#123; // 遍历找到对应的节点，然后赋值给node do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; // 找到了节点并且要么matchValue为false，要么node的value得和传入的value相等 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; // 红黑树，不管 if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); // 如果node==p也就是该哈希桶里面第一个节点就是我们需要找的 else if (node == p) // 操作 tab[index] = node.next; // 上面if不成立也就代表着要找的节点不是哈希桶里面的第一个节点 else // 操作 p.next = node.next; // 由于我们改变了哈希表的结构，所以需要更新modCount ++modCount; // 更新size --size; // 这是一个空实现的函数，用作LinkedHashMap重写使用 afterNodeRemoval(node); return node; &#125; &#125; // 在对应哈希桶里面找不到对应的节点，就返回null return null;&#125; 查HashMap # get(Object key)功能： 根据key找到对应节点，并返回节点的value。 123456public V get(Object key) &#123; Node&lt;K,V&gt; e; // -&gt;&gt; 分析4.4.1 // 找得到节点就返回节点的value，找不到则返回null return (e = getNode(hash(key), key)) == null ? null : e.value;&#125; HashMap # containsValue(Object value)功能： 根据value找到第一个找到的节点； 如果找到了就返回true； 没有返回false。 12345678910111213141516public boolean containsValue(Object value) &#123; Node&lt;K,V&gt;[] tab; V v; // 如果哈希表由内容的话进入if if ((tab = table) != null &amp;&amp; size &gt; 0) &#123; // 直接遍历哈希桶数组 for (int i = 0; i &lt; tab.length; ++i) &#123; // 再遍历当前哈希桶里面的节点，判断有没有需要找的value，如果有就返回，没有就遍历下一个哈希桶 for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; if ((v = e.value) == value || (value != null &amp;&amp; value.equals(v))) return true; &#125; &#125; &#125; return false;&#125; HashMap # containsKey(Object key)功能： 根据key找到对应节点； 如果有返回true； 否则返回false。 1234public boolean containsKey(Object key) &#123; // -&gt;&gt; 分析4.3.1 return getNode(hash(key), key) != null;&#125; HashMap # getOrDefault(Object key, V defaultValue)功能： 根据key找到对应节点； 如果有返回找到节点的value； 否则返回传入的defaultValue。 12345public V getOrDefault(Object key, V defaultValue) &#123; Node&lt;K,V&gt; e; // -&gt;&gt; 分析4.3.1 return (e = getNode(hash(key), key)) == null ? defaultValue : e.value;&#125; 分析4.3.1 HashMap # getNode(int hash, Object key)123456789101112131415161718192021222324final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; // 哈希表里面有数据 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 如果是该哈希桶里面的第一个节点就是要找的节点，那么直接将该节点返回 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 如果第一个节点不是，那就遍历后续节点 if ((e = first.next) != null) &#123; // 红黑树，不做讨论 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 在节点数小于等于8时，此时还没转为红黑树，这时就遍历该链表，找到要找的节点，并返回 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 判空 isEmpty()这个方法没啥好说的 123public boolean isEmpty() &#123; return size == 0;&#125; 遍历先将一下用法吧。因为HashMap的遍历有点特别。 他的遍历并不是直接使用迭代器或者他自己有个啥foreach方法能遍历(虽说他有foreach方法，但是他那个方法不是用来遍历，而是遍历进行操作的)。 他的遍历方式很奇特：123for(Object key : map.keySet()) &#123; // do something&#125; 或123for(HashMap.Entry entry : map.entrySet()) &#123; // do something&#125; 从上面代码片段中可以看出，大家一般都是对 HashMap 的 key 集合或 Entry 集合进行遍历。上面代码片段中用 foreach 遍历 keySet 方法产生的集合，在编译时会转换成用迭代器遍历，等价于：123456Set keys = map.keySet();Iterator ite = keys.iterator();while (ite.hasNext()) &#123; Object key = ite.next(); // do something&#125; 大家在遍历 HashMap 的过程中会发现，多次对 HashMap 进行遍历时，遍历结果顺序都是一致的。但这个顺序和插入的顺序一般都是不一致的。产生上述行为的原因是怎样的呢？ 现在咱们就先来看看代码吧。 首先看下keySet方法： HashMap # keySet()1234567891011public Set&lt;K&gt; keySet() &#123; // 复制，尽管我在HashMap类里面没有找到这个变量，但是不妨碍我们看源码 Set&lt;K&gt; ks = keySet; if (ks == null) &#123; // 构造方法 // -&gt;&gt; 4.5.2 ks = new KeySet(); keySet = ks; &#125; return ks;&#125; HashMap # KeySet123456789101112131415161718192021222324252627282930313233343536final class KeySet extends AbstractSet&lt;K&gt; &#123; // 返回HashMap的size public final int size() &#123; return size; &#125; // 调用HashMap的clear方法 public final void clear() &#123; HashMap.this.clear(); &#125; // -&gt;&gt; 4.5.3 public final Iterator&lt;K&gt; iterator() &#123; return new KeyIterator(); &#125; // 调用HashMap的containsKey方法 public final boolean contains(Object o) &#123; return containsKey(o); &#125; // 调用HashMap的removeNode方法 public final boolean remove(Object key) &#123; return removeNode(hash(key), key, null, false, true) != null; &#125; public final Spliterator&lt;K&gt; spliterator() &#123; return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super K&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; // fast-fail 可以看我之前ArrayList源码博客 int mc = modCount; // Android-changed: Detect changes to modCount early. // 遍历每一个哈希桶 for (int i = 0; (i &lt; tab.length &amp;&amp; modCount == mc); ++i) &#123; // 遍历哈希桶里面每一个节点 for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key); &#125; // 在遍历过程中，如果有其他线程对此HashMap操作导致HashMap的结构发生了变化，导致modCount的值发生了变化，进而不等于mc，抛异常 if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125;&#125; HashMap # KeyIterator12345final class KeyIterator extends HashIterator implements Iterator&lt;K&gt; &#123; // nextNode()是HashIterator里的方法 public final K next() &#123; return nextNode().key; &#125;&#125; HashMap # HashIterator1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950abstract class HashIterator &#123; Node&lt;K,V&gt; next; // next entry to return Node&lt;K,V&gt; current; // current entry int expectedModCount; // for fast-fail int index; // current slot HashIterator() &#123; expectedModCount = modCount; Node&lt;K,V&gt;[] t = table; current = next = null; index = 0; // 找到第一个包含节点的桶 if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125; final Node&lt;K,V&gt; nextNode() &#123; Node&lt;K,V&gt;[] t; Node&lt;K,V&gt; e = next; // fast-fail if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (e == null) throw new NoSuchElementException(); if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123; // 寻找下一个包含节点的桶 do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; return e; &#125; public final void remove() &#123; Node&lt;K,V&gt; p = current; if (p == null) throw new IllegalStateException(); // fast-fail if (modCount != expectedModCount) throw new ConcurrentModificationException(); current = null; K key = p.key; // 调用HashMap的removeNode方法 removeNode(hash(key), key, null, false, false); expectedModCount = modCount; &#125;&#125; 如上面的源码，遍历所有的键时，首先要获取键集合KeySet对象，然后再通过 KeySet 的迭代器KeyIterator进行遍历。KeyIterator 类继承自HashIterator类，核心逻辑也封装在 HashIterator 类中。HashIterator 的逻辑并不复杂，在初始化时，HashIterator 先从桶数组中找到包含链表节点引用的桶。然后对这个桶指向的链表进行遍历。遍历完成后，再继续寻找下一个包含链表节点引用的桶，找到继续遍历。找不到，则结束遍历。 拓展为什么哈希桶的长度一定是2的次方幂这是因为在哈希表中，为了计算方便，他全部都用hash&amp;(n-1)代替了hash%n，但是这样替换的前提就是n必须是2的次方幂。 hash()方法核心1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); //key.hashCode()为哈希算法，返回初始哈希值&#125; 代码的流程就是执行key的hashCode方法得到他的hashCode，然后再让他的hashCode与hashCode右移16位之后的值相与。 那为啥要这样呢？ 理论上散列值是一个int型，如果直接拿散列值作为下标访问HashMap主数组的话，考虑到2进制32位带符号的int表值范围从-2147483648到2147483648。前后加起来大概40亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。 但问题是一个40亿长度的数组，内存是放不下的。你想，HashMap扩容之前的数组初始大小才16。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标。 这样的话，就算我的散列值分布的再松散，要是只取最后几位的话，碰撞也会很严重，这时，就可以让hashCode自己的高位和低位相与，这样加大了数据的随机性，很大程度降低了碰撞的几率。 变量table为什么被transient修饰HashMap明明实现了serializable接口，而且还定义里serialVersionUID，那为什么table还需要用transient修饰而不去直接序列化呢？ 其实HashMap并没有使用默认的序列化机制，而是通过实现readObject/writeObject两个方法自定义了序列化的内容。如果直接对table进行序列化的话存在着两个问题: table大多数情况下都是无法被存满的，序列化未使用的部分，浪费空间； 同一个键值对在不同JVM下，所处的桶位置可能是不同的，在不同的JVM下反序列化table可能会发生错误。 第一个好理解，那我们说一下第二个：大家都知道HashMap很多地方都是根据hash值来进行存入或者取出数据的，但是hash调用的是Object的hashCode方法。但是hashCode方法是native方法，这个是取决于JVM的，不同的JVM可能计算hashCode的方法不同。所以如果在不同的平台下，序列化和反序列化HashMap之后。可能序列化时的HashMap是对着的，直接反序列化后，可能序列化中的元素a应该放在哈希桶1中，这样，反序列化也放在桶1中，但是由于反序列化的平台不同，导致hashcode算法不同，导致在反序列时元素a应该在桶2中，这样就导致HashMap结构出问题。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
        <tag>集合</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合源码之ArrayList]]></title>
    <url>%2Fposts%2F970dc297.html</url>
    <content type="text"><![CDATA[简介ArrayList可以说是我们最常用的一种集合了。 他的本质是一个数组，一个可以自动扩容的动态数组，线程不安全，允许元素为null。 由于数组的内存连续，可以根据下标以O(1)的时间读写元素，因此时间效率很高。 内部属性我们先来看下ArrayList里面有哪几个属性: private static final long serialVersionUID = 8683452581122892189L;序列话UID。由于ArrayList实现了Serializable接口，为了序列化和反序列化的方便，我们就手动为他添加一个序列化UID。 private static final int DEFAULT_CAPACITY = 10;默认的容量。 private static final Object[] EMPTY_ELEMENTDATA = {};空数组。 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};默认的空数组。 transient Object[] elementData;真正存放元素的数组。 private int size;当前元素个数。 构造方法12345678910111213141516171819202122232425262728293031323334353637// 传入参数为初始化容量时的构造方法public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; // 如果传入参数大于零，那就创建一个对应大小的数组 this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; // 如果传入参数等于0，那就直接把属性中创建好的空数组复制 this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; // 如果传入参数小于0，那就抛异常 throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125;// 传入参数为空时的构造方法public ArrayList() &#123; // 将属性中创建好的空数组复制过来 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;// 传入参数为数组时的构造方法public ArrayList(Collection&lt;? extends E&gt; c) &#123; // 先转换为数组 elementData = c.toArray(); // 因为size代表ArrayList中元素个数，所以要把数组的长度赋过来 // 如果个数不为0进入此if if ((size = elementData.length) != 0) &#123; //这里是当c.toArray出错，没有返回Object[]时，利用Arrays.copyOf 来复制集合c中的元素到elementData数组中 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // 如果个数为0，那就把属性中的空数组复制过来 this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 常用API增ArrayList # add(E e)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public boolean add(E e) &#123; // -&gt;&gt; 分析4.1.1 ensureCapacityInternal(size + 1); // Increments modCount!! // 将需要加入的元素加到最后面 elementData[size++] = e; return true;&#125;/** * 分析4.1.1 ensureCapacityInternal() */private void ensureCapacityInternal(int minCapacity) &#123; // DEFAULTCAPACITY_EMPTY_ELEMENTDATA这个变量只有在通过无参构造的时候用到过 // 也就是说，他判断创建出来的这个数组，到底是不是无参构造方法创建出来的，如果是就找出DEFAULT_CAPACITY和minCapacity中较大的那个 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 但是按道理来说，add一个元素minCapacity肯定为1，肯定小于DEFAULT_CAPACITY，为什么还要做一个判断呢？ // 但是你得注意，还有AddAll这个方法 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; // -&gt;&gt; 分析4.1.2 ensureExplicitCapacity(minCapacity);&#125;/** * 分析4.1.2 ensureExplicitCapacity() */private void ensureExplicitCapacity(int minCapacity) &#123; // modCount是AbstractList中的属性，如果需要扩容，则会修改modCount modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) // -&gt;&gt; 分析4.1.3 grow(minCapacity);&#125;/** * 分析4.1.3 grow() * 作用：扩容 */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 扩容为原数组的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 如果还不够，就直接用能容纳的最小大小 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8 // 如果新数组比MAX_ARRAY_SIZE还要大的话 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) // -&gt;&gt; 分析4.1.4 newCapacity = hugeCapacity(minCapacity); // minCapacity is usually clos2019e to size, so this is a win: // 生成新数组 elementData = Arrays.copyOf(elementData, newCapacity);&#125;/** * 分析4.1.4 */private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; ArrayList # add(E e)123456789101112131415// 按给定的位置添加指定元素public void add(int index, E element) &#123; // 如果给的位置超过了集合已存放的元素的个数或者小于0，就抛异常 if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); // -&gt;&gt; 分析4.1.1 ensureCapacityInternal(size + 1); // Increments modCount!! // 将elementData从index处分开，给index空出位置 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 放入数据 elementData[index] = element; size++;&#125; ArrayList # addAll(Collection&lt;? extends E&gt; c)1234567891011public boolean addAll(Collection&lt;? extends E&gt; c) &#123; // 转为数组 Object[] a = c.toArray(); int numNew = a.length; // 扩容数组 -&gt;&gt; 分析4.1.1 ensureCapacityInternal(size + numNew); // Increments modCount // 将a数组的全部内容添加到elementData数组从size开始之后 System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0;&#125; ArrayList # addAll(int index, Collection&lt;? extends E&gt; c)1234567891011121314151617181920public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); // 转为数组 Object[] a = c.toArray(); int numNew = a.length; // 扩容 -&gt;&gt; 分析4.1.1 ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; // 如果index小于size，也就是说需要在原数组的中间插入的haul，就需要先把原数组index之后的数据往后移动 if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125; 总结 无论是add还是addAll，都是先判断是否越界，如果越界就扩容，然后再移动数组 如果需要扩容，默认扩容原来的一般大小；如果还不够，那就直接将目标的size作为扩容后的大小 在扩容成功后，会修改modCount 删ArrayList # remove(int index)12345678910111213141516171819public E remove(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); // 修改modCount modCount++; // 将要删除的内容先保存下来 E oldValue = (E) elementData[index]; int numMoved = size - index - 1; // 判断要删除的数据是不是最后一位 // 如果不是最后一位，还得先把后面的数据往前移动 if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 清除数据，更改引用，让GC去清理 elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; ArrayList # remove(Object o)12345678910111213141516171819202122232425262728293031323334353637public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; // -&gt;&gt; 分析4.2.1 fastRemove(index); return true; &#125; &#125; else &#123; // 如果参数不为空，那就遍历整个数组集合 for (int index = 0; index &lt; size; index++) // 找到和参数相等的那一位，然后将该位移除 if (o.equals(elementData[index])) &#123; // -&gt;&gt; 分析4.2.1 fastRemove(index); return true; &#125; &#125; return false;&#125;/** * 分析4.2.1：fastRemove() * 作用：基本上和remove(int index)一样 */private void fastRemove(int index) &#123; // 修改modCount modCount++; int numMoved = size - index - 1; // 判断要删除的数据是不是最后一位 // 如果不是最后一位，还得先把后面的数据往前移动 if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 清除数据，更改引用，让GC去清理 elementData[--size] = null; // clear to let GC do its work&#125; ArrayList # removeAll(Collection&lt;?&gt; c)1234567891011121314151617181920212223242526272829303132333435363738394041public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); // -&gt;&gt; 分析4.2.2 return batchRemove(c, false);&#125;/** * 分析4.2.2 batchRemove() */private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; // 先赋值 final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; // 快速保存两个集合共有元素 for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) &#123; // 如果出现异常会导致r!=size，就把异常之后的数据全部覆盖到数组里面 System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work // 将后面的元素全部置空，让GC来回收 for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified;&#125; 这块我看的时候有点绕，但是一想通就好了。 其实这个地方是要把C集合中和原集合中共有的元素删除，那我就只需要遍历原数组，然后碰到和C集合相同的元素就直接放到前面去，然后等遍历完成后，一次性把后面的全部置空。 ArrayList # retainAll(Collection&lt;?&gt; c)12345public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); // -&gt;&gt; 分析4.2.2 return batchRemove(c, true);&#125; ArrayList # clear()12345678910public void clear() &#123; modCount++; // clear to let GC do its work // 直接遍历每一位，然后把每一位都置空，让GC去清理 for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0;&#125; 总结 所有的删除操作都会修改modCount 改12345678910public E set(int index, E element) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); // 取出原来的元素 E oldValue = (E) elementData[index]; // 把需要更改的数据放进去 elementData[index] = element; return oldValue;&#125; 没啥好分析的 不需要修改modCount，相对高效 查123456public E get(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); return (E) elementData[index];&#125; 没啥好分析的 不需要修改modCount，相对高效 包括 contains() &amp; indexOf()1234567891011121314151617181920public boolean contains(Object o) &#123; // -&gt;&gt; 分析4.5.1 return indexOf(o) &gt;= 0;&#125;/** * 分析4.5.1：indexOf() */public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; 没啥好分析的 判空 isEmpty()123public boolean isEmpty() &#123; return size == 0;&#125; 没啥好分析的 迭代器 Iterator创建迭代器1234public Iterator&lt;E&gt; iterator() &#123; // 构造Itr对象并返回 return new Itr();&#125; Itr属性123456789// 限制，也就是数组的元素个数protected int limit = ArrayList.this.size;// 下一个元素的下标int cursor; // index of next element to return// 上一次返回元素的下标int lastRet = -1; // index of last element returned; -1 if no such// 用于判断集合是否修改过结构的标志int expectedModCount = modCount; Itr # hasNext()123public boolean hasNext() &#123; return cursor &lt; limit;&#125; 不用多说 Itr # next()1234567891011121314151617public E next() &#123; // 判断是否修改过List的结构，如果修改了就抛异常 if (modCount != expectedModCount) throw new ConcurrentModificationException(); int i = cursor; // 如果越界了就抛异常 if (i &gt;= limit) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; // 再次判断是否越界，在 我们这里的操作时，有异步线程修改了List if (i &gt;= elementData.length) throw new ConcurrentModificationException(); // 标记加1 cursor = i + 1; // 返回数据，并设置上一次的下标 return (E) elementData[lastRet = i];&#125; Itr # remove()123456789101112131415161718public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); try &#123; // 调用ArrayList的remove方法移除数据 ArrayList.this.remove(lastRet); // 更新一系列数据 cursor = lastRet; lastRet = -1; expectedModCount = modCount; limit--; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125;&#125; 总结modCount到底是个什么东西？如果你看过很多集合源码的话，你就会发现你会在很多地方都会碰到这个modCount，例如ArrayList、LinkedList、HashMap等等。modCount字面意思就是修改次数，那么为什么需要纪录这个修改次数呢？ 你回想下，似乎用到modCount的地方，如ArrayList、LinkedList等等，他们都用一个共性——线程不安全。 而在你看了这几个类的迭代器后就会发现，他们迭代器中一定有一个属性(如我们上面的expectedModCount)初始化时的值就是modCount的值。 然后在迭代器的方法中，只要是遍历这个集合的时候，都需要将两个值进行对比，然后再移除元素的时候，都需要更新迭代器里面的modCount变量。 这时，你需要了解下Fail-Fast机制。 我们都知道这些集合是线程不安全的，如果在使用迭代器的过程中，有其他线程对集合进行了修改，那么就会抛出ConcurrentModificationException异常，这就是Fail-Fast策略。而这个时候源码中就通过modCount进行了操作。迭代器在创建时，会创建一个变量等于当时的modCount，如果在迭代过程中，集合发生了变化，modCount就是++。这时迭代器中的变量的值和modCount不相等了，那就抛异常。 所以，遍历线程不安全的集合时，尽量使用迭代器 解决办法： 在遍历过程中所有涉及到改变 modCount 值得地方全部加上 synchronized 或者直接使用 Collections.synchronizedList，这样就可以解决。但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。 使用 CopyOnWriteArrayList 来替换 ArrayList。推荐使用该方案。关于CopyOnWriteArrayList的内容此处不再过多的去将，想了解的同学可以百度或者谷歌。 ArrayList和Vector的区别 ArrayList线程不安全，Vector线程安全 扩容的时候ArrayList默认扩容1.5倍，Vector默认扩容1倍]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
        <tag>集合</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android消息机制之Handler详解]]></title>
    <url>%2Fposts%2F21eb5c30.html</url>
    <content type="text"><![CDATA[简介作为一个Android开发者，Handler的大名你一定听过。做Android开发肯定离不开Handler，它通常被我们用来连通主线程和子线程。 可以说只要有异步的地方一定有Handler。 那么，你了解过为什么Handler能连通主线程和子线程吗，也就是说，你了解过Handler背后的原理吗？ 就让本文带你了解。 Handler的基本用法按照惯例，我们首先看下Handler的一般用法：12345678910Handler mHandler = new Handler() &#123; @Override public void handleMessage(final Message msg) &#123; // 在这里接受并处理消息 &#125;&#125;;//发送消息mHandler.sendMessage(message);mHandler.post(runnable); 也就是创建一个Handler对象，并重写handlerMessage方法，然后在需要的时候调用sendMessage方法传入一个message对象，或者调用post方法传入一个runnable对象。 那么我们从他的构造方法开始看起吧。 从Handler构造方法入手1234public Handler() &#123; // -&gt;&gt; 分析1.1 this(null, false);&#125; 分析1.1 Handler # 构造方法1234567891011121314151617181920212223242526272829/** * 分析1.1：实际上调用的又是另一个构造方法 */public Handler(@Nullable Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; // 这个变量字面意思是找到内存泄漏， // 但是整个Handler中除了这块以及定义这个变量为false之外， // 就没有其他地方使用到过这个变量了，所以这块我也不太懂这个变量是怎么变为true的 final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, "The following Handler class should be static or leaks might occur: " + klass.getCanonicalName()); &#125; &#125; // -&gt;&gt; 分析1.2 mLooper = Looper.myLooper(); // -&gt;&gt; 分析1.3 if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread " + Thread.currentThread() + " that has not called Looper.prepare()"); &#125; // 获取对象的mQueue属性，mQueue就是MessageQueue mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 分析1.2 Looper # myLooper()1234567/** * 分析1.2：Looper.myLopper() * 实际上调用的是ThreadLocal的get方法，然后返回该线程的Looper对象 */public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125; ThreadLocal是一个数据存储类，他的特别之处在于他是线程间独立的，也就是说这个线程放入到ThreadLocal的数据，其它线程是获取不到的。sThreadLocal就是获取当前线程的Looper对象。详细可见我之前的博客。 分析1.3 Looper # prepare()为什么说如果mLooper为空就抛异常呢，这是因为一个Handler必须和一个Looper绑定，并且要先初始化Looper才能去初始化Handler。初始化Looper就通过Looper的prepare方法。1234567891011121314/** * 分析1.3：Looper.prepare() */public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; // -&gt;&gt; 分析1.4 sThreadLocal.set(new Looper(quitAllowed));&#125; 这个方法和myLooper方法类似，就是通过ThreadLocal设置Looper。 分析1.4 Looper # 构造方法1234567/** * 分析1.4：Looper的构造方法 */private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; Looper的构造方法是私有的，也就是说外界并不能直接创建Looper方法，必须通过Looper.prepare方法来创建Looper对象，这样也就方便了保证一个线程只能有一个Looper对象。 在构造方法中，我们创建了一个MessageQueue对象。这个对象就是用来存放消息的消息队列。关于MessageQueue我们后面再来讲。 消息是如何存放的上面就是Handler和Looper的一个构造方式，构造完成后，我们就要关注Handler是如何把消息放入MessageQueue中的，以及是如何从MessageQueue中取出的。 上面我们在讲Handler的基本用法的时候，讲到过sendMessage方法和post方法。我们先来看下这两个方法： Handler # sendMessage() &amp; post()其实这块先不上具体的方法实现，先说一下他们的方法调用流程：123456789sendMessage() -&gt; sendMessageDelayed() -&gt; sendMessageAtTime() -&gt; enqueueMessage()post() -&gt; sendMessageDelayed() -&gt; sendMessageAtTime() -&gt; enqueueMessage() 可以看到，这两个方法都会调用立马调用sendMessageDelayed():12345678public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) &#123; // 默认都传入0 if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; // -&gt;&gt; 分析2.1 return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; 分析2.1 Handler # sendMessageAtTime()1234567891011121314151617/** * 分析2.1：sendMessageAtTime() * 传入参数： * msg：需要传递的消息 * uptimeMillis：更新时间，也就是系统从开机到目前经过的时候 + delayMillis(也就是0) */public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; // -&gt;&gt; 分析2.2 return enqueueMessage(queue, msg, uptimeMillis);&#125; 分析2.2 Handler # enqueueMessage()1234567891011121314/** * 分析2.2：enqueueMessage() */private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) &#123; msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; // -&gt;&gt; 这块就将消息存放到MessageQueue队列中去 return queue.enqueueMessage(msg, uptimeMillis);&#125; 那么消息就成功的从Handler中被存入了MessageQueue，那么消息什么时候从MessageQueue中被调出来呢? 消息是如何取出的Looper # loop()Looper里面有一个loop方法，我们可以看下这个方法:123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void loop() &#123; // 获取当前线程的Looper对象 final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; // 获取当前线程的MessageQueue final MessageQueue queue = me.mQueue; // ...省略中间代码 // 死循环 for (;;) &#123; // 从消息队列中取出一个消息 // -&gt;&gt; 分析3.1 Message msg = queue.next(); // might block // 如果取出的消息为空，就退出。 // 但是我之前说这个循环是个死循环？ // 这是因为虽然会有这个if可能会导致循环退出，但是通过next方法取出消息的时候，如果没有消息了，next方法会阻塞线程，直到有新的消息进来 // 这也就意味着，一般正常的遍历MessageQueue情况下，是不会有msg==null的。 // 但是如果你调用了Looper的quit或者quitSafely方法，这个时候next会返回null，就会退出循环。 if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // ...省略中间代码 try &#123; // 传给Handler去处理消息 // -&gt;&gt; 分析3.2 msg.target.dispatchMessage(msg); if (observer != null) &#123; observer.messageDispatched(token, msg); &#125; dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; catch (Exception exception) &#123; // ...省略中间代码 &#125; finally &#123; // ...省略中间代码 &#125; // ...省略中间代码 &#125;&#125; 分析3.1 MessageQueue # next()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/** * 分析3.1 MessageQueue.next() * 作用： * 用于取出消息队列中的下一个消息 * PS： * 看到这个next你或许就应该懂了，其实这个MessageQueue并不是咱们顾名思义以为的那个Queue，其实他的实现是一个链表 */Message next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. // 如果Looper已经退出（调用了dispose方法后mPtr=0） final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; // 记录空闲时需要处理的IdleHandler数量 int pendingIdleHandlerCount = -1; // -1 only during first iteration // -&gt;&gt; 分析3.2.1 int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; // 刷新Binder命令 Binder.flushPendingCommands(); &#125; // 调用native层，如果返回了就说明可以从队列中取出一条消息 // 如果消息队列中没有消息就阻塞等待，靠enqueueMessage()中最后一步调用nativeWake()来唤醒该方法 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. // 得到时间-从手机开机到现在调用经过的时间 final long now = SystemClock.uptimeMillis(); Message prevMsg = null; // 得到队头 Message msg = mMessages; // 判断这个message是不是barrier if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. // 循环遍历出第一个异步消息，如果设置了barrier，就不能再执行同步消息了，除非将barrier移除。 // 但是异步消息不受影响照样执行，所以在这里要找到异步消息 do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; // 如果分发时间还没到 if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. // 更新执行时间点 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // 时间到了 // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // 如果没有其他消息了 nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. // 正在退出了，返回null。 if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. // 判断如果这是第一次循环（只有第一次循环时会小于0）并且队列为空或还没到处理第一个的时间 if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. // 置为阻塞状态 mBlocked = true; continue; &#125; // 初始化最少四个要被执行的IdleHandler if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. // 开始循环执行所有的IdleHandler并根据返回值判断是否保留 for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, "IdleHandler threw exception", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // IdleHandler只会在消息队列阻塞之前执行一次，之后再不会执行，知道下一次被调用next()。 pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. // 当执行了IdleHandler后，会消耗一段时间，刺死可能已经到达执行消息的时间了，所以重置该变量再重新检查时间。 nextPollTimeoutMillis = 0; &#125;&#125; 分析3.2.1nextPollTimeoutMillis是一个变量，用于表示时间。 如果nextPollTimeoutMillis = -1，则一直会阻塞不会超时 如果nextPollTimeoutMillis = 0，不会阻塞，立即返回 如果nextPollTimeoutMillis &gt; 0，最长阻塞nextPollTimeoutMillis毫秒，如果期间有程序唤醒会立即返回 分析3.2 Handler # dispatchMessage()12345678910111213141516171819/** * 分析3.2 Handler.dispatchMessage() */public void dispatchMessage(@NonNull Message msg) &#123; // 先查看message自己callback有没有被设置，如果有那就交给自己的callback去处理 if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; // 如果没有message自己的callback，那就看看Handler有没有callback， // 如果有，那就交给Handler的Callback去处理， if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; // 如果Handler自己还没有Callback，那就Handler自己处理 handleMessage(msg); &#125;&#125; 从上面可以得到以下信息：处理消息的方式有3个，分别为Message自己的Callback、Handler的Callback以及Handler自己。 优先级最高的是Message自己的callback，这是一个Runnable对象，我们用Handler post一个Runnable的时候，其实就是把这个Runnable赋值个一个Message对象的callback，然后把Message对象发送给MessageQueue。 优先级第二的是Handler自己的mCallback，在我们创建一个Handler对象的使用可以传一个Handler.Callback对象给它并实现Callback里的handleMessage(msg)方法，作为我们的消息处理方法。 优先级最低的是Handler自己的handleMessage(msg)方法，这也是我们最常用的消息处理方法。 流程图（图片来自于此处） 延伸1. 为什么说Handler可能会导致内存泄漏只要你用Android Studio，并在Activity里面用过Handler，都会注意到一个地方，就是如果你直接创建Handler对象并重写handleMessage方法的话，AS一把都会报一个warning：123This Handler class should be static or leaks might occur.该处理程序类应为静态，否则可能发生泄漏 就是说如果直接这样写就可能会导致内存泄漏，但是如果你在不是Activity的类里面这样写又不会报warning，这是为什么呢？ 因为Handler允许我们发送延时消息，但是如果在延时期间，用户关闭了Activity。这时Message持有Handler，而又因为Java的特性，内部类会持有外部类，也就是说Handler会持有Activity，这样就导致Activity泄漏了。 解决办法就是把Handler定义为静态内部类，并在内部持有Activity的弱引用，并及时移除所有消息：123456789101112private static class SafeHandler extends Handler &#123; private WeakReference&lt;MainActivity&gt; ref; public SafeHandler(MainActivity activity) &#123; this.ref = new WeakReference&lt;&gt;(activity); &#125; @Override public void handleMessage(@NonNull Message msg) &#123; &#125;&#125; 2. 为什么主线程不需要创建Looper，而且主线程的Looper不许退出因为在主线程创建时会自动调用Looper的prepare方法，并调用loop方法。我们就可以直接在主线程使用Handler。 而为什么不能退出，是因为如果Looper退出了，那么主线程就会挂掉。Android也不许你手动退出主线程的Looper。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
        <tag>ThreadLocal</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android消息机制之ThreadLocal]]></title>
    <url>%2Fposts%2F64f0a9f6.html</url>
    <content type="text"><![CDATA[简介ThreadLocal是一个线程内部的数据储存类，通过他可以在指定的线程中存储数据。数据存储以后，只有在指定的线程中可以获取到存储的数据，对于其他线程来说则无法获取。 在源码中是这样写的： This class provides thread-local variables. These variables differ fromtheir normal counterparts in that each thread that accesses one (via its{@code get} or {@code set} method) has its own, independently initializedcopy of the variable. {@code ThreadLocal} instances are typically privatestatic fields in classes that wish to associate state with a thread (e.g.,a user ID or Transaction ID). 翻译过来，就是说这个类提供线程局部变量，但是他和普通变量不同，他是每个线程都有自己的一个独立初始化的变量副本。而通过get()和set()方法就能得到和设置当前线程对应的该变量的值。 示例接下来我们看一下示例代码，在一个Activity的onCreate方法中写入如下代码：12345678910111213141516171819202122232425262728293031323334public class MainActivity extends AppCompatActivity &#123; // 需要添加的代码 private static final String TAG = "MainActivity"; // 需要添加的代码 private ThreadLocal&lt;Boolean&gt; mBooleanThreadLocal = new ThreadLocal&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 需要添加的代码 mBooleanThreadLocal.set(true); Log.d(TAG, "[Thread#main]mBooleanThreadLocal=" + mBooleanThreadLocal.get()); // 需要添加的代码 new Thread("Thread#1") &#123; @Override public void run() &#123; mBooleanThreadLocal.set(false); Log.d(TAG, "[Thread#1]mBooleanThreadLocal=" + mBooleanThreadLocal.get()); &#125; &#125;.start(); // 需要添加的代码 new Thread("Thread#2") &#123; @Override public void run() &#123; Log.d(TAG, "[Thread#2]mBooleanThreadLocal=" + mBooleanThreadLocal.get()); &#125; &#125;.start(); &#125;&#125; 根据我们上面说的ThreadLocal的特性，就可以猜出应该会输出：123[Thread#main]mBooleanThreadLocal=true[Thread#1]mBooleanThreadLocal=false[Thread#2]mBooleanThreadLocal=null 然后运行输出的结果，不出所料，果然和上面一样。 使用场景一般来说，当某些数据是以线程作为作用域并且不同线程具有不同的数据副本的时候，就可以考虑使用ThreadLocal。比如对于Handler来说，它需要获取当前线程的Looper，很显然Looper的作用域就是线程并且不同线程具有不同的Looper，这个时候通过ThreadLocal就可以轻松实现Looper在线程中的存取，如果不采用ThreadLocal，那么系统就必须提供一个全局的哈希表供Handler查找指定线程的Looper，这样一来就必须提供一个类似于LooperManager的类了，但是系统并没有这么做而是选择了ThreadLocal，这就是ThreadLocal的好处。 另一个使用场景就是复杂逻辑下的对象传递。比如监听器的传递，有些时候一个线程中的任务过于复杂，这可能表现为函数调用栈比较深以及代码入口的多样性，在这种情况下，我们又需要监听器能够贯穿整个线程的执行过程，这个时候可以怎么做呢？其实就可以采用ThreadLocal，采用ThreadLocal可以让监听器作为线程内的全局对象而存在，在线程内部只要通过get方法就可以获取到监听器。而如果不采用ThreadLocal，那么我们能想到的可能是如下两种方法：第一种方法是将监听器通过参数的形式在函数调用栈中进行传递，第二种方法就是将监听器作为静态变量供线程访问。上述这两种方法都是有局限性的。第一种方法的问题时当函数调用栈很深的时候，通过函数参数来传递监听器对象这几乎是不可接受的，这会让程序的设计看起来很糟糕。第二种方法是可以接受的，但是这种状态是不具有可扩充性的，比如如果同时有两个线程在执行，那么就需要提供两个静态的监听器对象，如果有10个线程在并发执行呢？提供10个静态的监听器对象？这显然是不可思议的，而采用ThreadLocal每个监听器对象都在自己的线程内部存储，根据就不会有方法2的这种问题。 源码作为一个存储数据的类，关键点就在get和set方法。 ThreadLocal # set123456789101112131415161718192021222324252627282930public void set(T value) &#123; // 获取当前线程 Thread t = Thread.currentThread(); // 实际上存储数据的结构类型 // -&gt;&gt; 分析1 ThreadLocalMap map = getMap(t); // 如果存在Map就直接set，没有就创建map并set if (map != null) map.set(this, value); else // -&gt;&gt; 分析2 createMap(t, value);&#125;/** * 分析1：getMap()方法 */ThreadLocalMap getMap(Thread t) &#123; // 返回传入线程的ThreadLocalMap return t.threadLocals;&#125;/** * 分析2：createMap()方法 */void createMap(Thread t, T firstValue) &#123; // 创建一个新的ThreadLocalMap并将值传入 t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 当你调用set方法时，就会拿到当前线程并得到当前线程的ThreadLocalMap，如果map不为空，那就直接把值传入map；如果map为空那就新建一个再传值。 这块我们就能懂为啥ThreadLocal能只操作自己线程里面的东西了，因为所有ThreadLocal都与他线程中的ThreadLocalMap有关。 那我们再来看看ThreadLocalMap。 ThreadLocalMap属性变量先来看下ThreadLocalMap的一些变量。123456789101112131415161718192021222324252627282930313233343536373839404142434445// 存储数据的结构为Entry，而且key是弱引用static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125;// table的初始容量private static final int INITIAL_CAPACITY = 16;// table用于存储数据private Entry[] table;// private int size = 0;// 负载因子，用于扩容private int threshold; // Default to 0// 设置负载因子，默认为当前大小的2/3private void setThreshold(int len) &#123; threshold = len * 2 / 3;&#125;// 下一个索引private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0);&#125;// 上一个索引private static int prevIndex(int i, int len) &#123; return ((i - 1 &gt;= 0) ? i - 1 : len - 1);&#125;// 构造函数ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY);&#125; ThreadLocalMap # set()1234567891011121314151617181920212223242526272829private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; // 根据哈希算法找到对应节点 int i = key.threadLocalHashCode &amp; (len-1); //判断当前位置是否有数据，如果key值相同，就替换，如果不同则找空位放数据。 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); //判断key值相同否，如果是直接覆盖 （第一种情况） if (k == key) &#123; e.value = value; return; &#125; //如果当前Entry对象对应Key值为null,则清空所有Key为null的数据（第二种情况） if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; //以上情况都不满足，直接添加（第三种情况） tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; 先根据key通过哈希算法得到对应的i，然后再开始从这个i开始遍历，进行判断，由于下面三个判断比较复杂，所以我们分开来讲。 第一种情况这种情况下，key值相同，就需要将value替换掉。 第二种情况这种情况比较复杂，先看下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) &#123; Entry[] tab = table; int len = tab.length; Entry e; int slotToExpunge = staleSlot; // 先往前进行判断，看是否能找到空的节点，找到了就更新slotToExpunge for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; // 再往后遍历 for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); // 如果当前i节点的key和传入的key相同，那就进行替换 if (k == key) &#123; e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; /* * 如果在整个扫描过程中（包括函数一开始的向前扫描与i之前的向后扫描） * 找到了之前的无效slot则以那个位置作为清理的起点， * 否则则以当前的i作为清理起点 */ if (slotToExpunge == staleSlot) slotToExpunge = i; // 进行一次连续段的清理，再做一次启发式清理 // -&gt;&gt; 分析1 // -&gt;&gt; 分析2 cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; &#125; // 如果当前的slot已经无效，并且向前扫描过程中没有无效slot，则更新slotToExpunge为当前位置 if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; &#125; // 如果key在table中不存在，则在原地放一个即可 tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); // 在探测过程中如果发现任何无效slot，则做一次清理（连续段清理+启发式清理） // -&gt;&gt; 分析1 // -&gt;&gt; 分析2 if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);&#125;/** * 分析1：expungeStaleEntry() * 作用：把连续段内所有无效的slot都清理一遍 */private int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; tab[staleSlot].value = null; tab[staleSlot] = null; size--; Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; tab[i] = null; size--; &#125; else &#123; int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) &#123; tab[i] = null; while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; return i;&#125;/** * 分析2：cleanSomeSlots() * 作用：遍历删除所有位置下key==null的数据 */private boolean cleanSomeSlots(int i, int n) &#123; boolean removed = false; Entry[] tab = table; int len = tab.length; do &#123; i = nextIndex(i, len); Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) &#123; n = len; removed = true; // -&gt;&gt; 分析3 i = expungeStaleEntry(i); &#125; &#125; while ( (n &gt;&gt;&gt;= 1) != 0); return removed;&#125; 示意图如下： 第三种情况第三种情况就是上面两种情况都不满足的情况，也就是需要插入的位置为null的时候，就直接扩大ThreadLocalMap，然后再插入： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950tab[i] = new Entry(key, value);int sz = ++size;// -&gt;&gt; cleanSomeSlots见上面第二种情况的分析2if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) // -&gt;&gt; 分析1 rehash();/** * 分析1：rehash() */private void rehash() &#123; // -&gt;&gt; expungeStaleEntries见上面第二种情况的分析1 expungeStaleEntries(); if (size &gt;= threshold - threshold / 4) // -&gt;&gt; 分析2 resize();&#125;/** * 分析2：resize() */private void resize() &#123; Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j &lt; oldLen; ++j) &#123; Entry e = oldTab[j]; if (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; // Help the GC &#125; else &#123; int h = k.threadLocalHashCode &amp; (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; &#125; &#125; &#125; setThreshold(newLen); size = count; table = newTab;&#125; ThreadLocalMap # getEntry()12345678910111213141516171819202122232425262728293031private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else // -&gt;&gt; 分析1 return getEntryAfterMiss(key, i, e);&#125;/** * 分析1：getEntryAfterMiss() */private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; // 从当前往后一个个进行遍历，直至找到和key相等的然后返回 while (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; &#125; return null;&#125; ThreadLocalMap # remove()123456789101112131415private void remove(ThreadLocal&lt;?&gt; key) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; if (e.get() == key) &#123; // 显式断开弱引用 e.clear(); expungeStaleEntry(i); return; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
        <tag>ThreadLocal</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View的事件分发]]></title>
    <url>%2Fposts%2Fbfb9e8a9.html</url>
    <content type="text"><![CDATA[从我刚进实验室的时候，学长学姐就说View的事件分发机制是Android里面一个很重要的内容，要我们好好学。 但是随着自己对Android了解的深入，越发觉得这个东西很有必要了解下，正好Android艺术开发探索也看到了View这块，也看了郭霖大神的博客和另一位大神的博客，所以就好好学习了一番，并写了此博客。 1. MotionEvent在开始讲View事件分发之前，我们先来了解下MotionEvent。 这个就是手指解除到屏幕后所产生的一系列事件，主要为一下三个典型事件： ACTION_DOWM——手指刚接触屏幕 ACTION_MOVE——手指在屏幕上移动 ACTION_UP——手指从屏幕上松开 ACTION_CANCEL——结束事件（非人为） 正常情况下，一次手指触摸屏幕然后离开可能触发一下两种情况： 点击屏幕然后松开：ACTION_DOWN -&gt; ACTION_UP 点击屏幕然后滑动再松开：ACTION_DOWN -&gt; ACTION_MOVE -&gt; ACTION_UP 下面一个图片来概括下： 2. 事件分发传递规则众所周知，AndroidUI是由Activity、ViewGroup、View及其派生类组成的。 大致示意图如下： 其中： Activity：控制生命周期或者处理事件 ViewGroup：一组View或者多个View的集合。也是布局Layout的基类。但是特别的是，他也集成自View。 View：所有UI组件的基类 从上图我们就可以看出来，事件分发的顺序就是：Activity -&gt; ViewGroup -&gt; View。也就是说一个点击事件产生，先交由Activity，再传到ViewGroup，再传到View。这个过程中只要有一个部分说要拦截，就不会再继续往下传递。 3. 事件分发的核心方法其实时间分发的核心方法很简单，就由三个方法组成： public boolean dispatchTouchEvent(MotionEvent ev)用来进行事件的分发。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示是否消耗当前事件。 public boolean onInterceptTouchEvent(MotionEvent event)在dispatchTouchEvent方法内部调用，用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一事件序列当中，此方法不会再次被调用，返回结果表示是否拦截当前事件。（只有ViewGroup中才有此方法，View中没有） public boolean onTouchEvent(MotionEvent event)在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件。 三个方法间的关系可以按下面一段伪代码表示：（参考的代码）1234567891011121314151617181920212223242526/** * 点击事件产生后 */ // 步骤1：调用dispatchTouchEvent（） public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean consume = false; //代表 是否会消费事件 // 步骤2：判断是否拦截事件 if (onInterceptTouchEvent(ev)) &#123; // a. 若拦截，则将该事件交给当前View进行处理 // 即调用onTouchEvent (）方法去处理点击事件 consume = onTouchEvent (ev) ; &#125; else &#123; // b. 若不拦截，则将该事件传递到下层 // 即 下层元素的dispatchTouchEvent（）就会被调用，重复上述过程 // 直到点击事件被最终处理为止 consume = child.dispatchTouchEvent (ev) ; &#125; // 步骤3：最终返回通知 该事件是否被消费（接收 &amp; 处理） return consume;&#125; 对于一个根ViewGroup，点击事件产生后，就会传递给他，这时他的dispatchTouchEvent就会被调用，然后就开始判断他是否拦截。如果拦截，那么点击事件就会给ViewGroup去处理，如果不拦截，就调用child.dispatchTouchEvent (ev) 传给子控件的dispatchTouchEvent方法。然后继续循环，直到到最底层view，也就是没有child的时候，或者直到事件被拦截。 4. 源码分析4.1 Activity事件分发首先先来看dispatchTouchEvent方法： 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); // -&gt;&gt; 分析1 &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; // -&gt;&gt; 分析2 return true; &#125; return onTouchEvent(ev); // -&gt;&gt; 分析5&#125;/** * 分析1：onUserInteraction() * 这个方法就是个空方法，但是我是在没搞懂这个方法是干嘛的，所以就直接粘贴了carson这位大神的说明 * 作用：实现屏保功能 * 注： * a. 该方法为空方法 * b. 当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法 */public void onUserInteraction() &#123;&#125;/** * 分析2：getWindow().superDispatchTouchEvent(ev) * 点开之后进入Window类， * 但是发现这个类是个抽象类，这个方法是个抽象方法。 * * 了解过View的同学都知道，Window的唯一实现类就是PhoneWindow * 那我们进入PhoneWindow看下他的superDispatchTouchEvent方法 */public abstract boolean superDispatchTouchEvent(MotionEvent event);// -&gt;&gt; 分析3/** * 分析3：PhoneWindow.superDispatchTouchEvent() * 实际上又调用了DecorView的superDispatchTouchEvent方法，DecorView是最顶层的View */@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event); // -&gt;&gt; 分析4&#125;/** * 分析4：DecorView.superDispatchTouchEvent() * 注： * a. DecorView继承自FrameLayout，而FrameLayout继承自ViewGroup，也就是说DecorView就是ViewGroup。 * b. DecorView调用了父类的dispatchTouchEvent方法，也就相当于ViewGroup的dispatchTouchEvent方法，就把事件交给了ViewGroup去处理，这块后面再说 */public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event);&#125;/** * 分析5：return onTouchEvent(ev) * 当触摸屏事件未由其下的任何视图处理时调用 * */public boolean onTouchEvent(MotionEvent event) &#123; if (mWindow.shouldCloseOnTouch(this, event)) &#123; // -&gt;&gt; 分析6 finish(); return true; &#125; return false; // 只有在点击事件在Window边界外才会返回true，一般情况都返回false，分析完毕&#125;/** * 分析6：Window.shouldCloseOnTouch() * * 返回： * 返回true：说明事件在边界外，即 消费事件 * 返回false：未消费（默认） */public boolean shouldCloseOnTouch(Context context, MotionEvent event) &#123; final boolean isOutside = event.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; isOutOfBounds(context, event) || event.getAction() == MotionEvent.ACTION_OUTSIDE; // 主要是对于处理边界外点击事件的判断：是否是DOWN事件，event的坐标是否在边界内等 if (mCloseOnTouchOutside &amp;&amp; peekDecorView() != null &amp;&amp; isOutside) &#123; // peekDecorView是返回PhoneWindow的mDecor return true; &#125; return false;&#125; 流程 4.2 ViewGroup事件分发源码由于此部分代码过长，我们将代码拆分成两部分： part11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; ...// 仅贴出关键代码 boolean handled = false; /** * onFilterTouchEventForSecurity(ev) * 筛选touch事件，进去之后的判断核心就是当前视图是否被其它窗口遮挡或者隐藏 */ if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // Handle an initial down. // -&gt;&gt; 分析1 if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); &#125; // Check for interception. final boolean intercepted; /** * 分析2 * 可以看到会有两种情况下拦截事件：事件类型为DOWN，或者mFirstTouchTarget != null。 * 那么这个mFirstTouchTarget是什么呢？ * 从后面的代码我们可以得知，当ViewGroup不拦截事件交给子元素处理的时候，mFirstTouchTarget不为null。 * 所以，也就是说当MotionEvent为UP或者MOVE的时候，都进不去这个方法，也就是不调用ViewGroup的onInterceptTouchEvent，他不拦截事件 */ if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; /** * 分析1 * 事件开始时会调用resetTouchState()来清空mFirstAndClearTouchTarget */if (actionMasked == MotionEvent.ACTION_DOWN) &#123; cancelAndClearTouchTargets(ev); // 核心目的就是清空mFirstAndClearTouchTarget resetTouchState();&#125; part2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118 ...//省略中间代码 // 进入if语句，判断条件为没有对事件进行拦截，同时事件没有结束。对ViewGroup的子元素进行遍历 if (!canceled &amp;&amp; !intercepted) &#123; ...//继续省略中间代码 // 得到所有的子View final View[] children = mChildren; // 对子View进行遍历 for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. // 该viewgroup设置事件了指向焦点View并且焦点View在前面已经找到了 if (childWithAccessibilityFocus != null) &#123; // 判断遍历的此View是否是焦点View，如果不是就直接下一遍循环 if (childWithAccessibilityFocus != child) &#123; continue; &#125; // 如果是的话就将找到的焦点view置空 // i回到到数第一个下标 // 这样做的目的是先让该焦点view尝试进行下面的普通分发操作 // 如果成功了，会在下面跳出循环。 // 如果不成功，就将记录的焦点view置空， // 从最后一个开始重新遍历，不再进入这个判断。 childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; // 判断当前子View是否能获取焦点或者是否正在做动画 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); // -&gt;&gt; 分析1 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (chifcldren[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); // -&gt;&gt; 分析2 newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn't handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; ... //省略 &#125;/** * 分析1 dispatchTransformedTouchEvent() * * 核心就是那个if (child == null)。 * 如果child不为空，那么事件就交给子View处理 */private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; // Canceling motions is a special case. We don't need to perform any transformations // or filtering. The important part is the action, not the contents. final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; ...//省略&#125;/** * 分析2 * 如果子View能处理点击事件，那么就调用addTouchTarget方法，对mFirstTouchTarget方法进行复制，然后再进入part1中分析2。 */private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) &#123; final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target;&#125; part31234567891011121314151617181920212223242526272829303132333435363738394041 // Dispatch to touch targets. // 如果part2开头的那个if没有进，也就是对事件进行拦截的话，直接到这来 // 并且如果没有进入part2，那么mFirstTouchTarget仍然为空，那么就进入if if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. // 此处在上面分析过了，但是不同的是由于child直接传入了null，那么就执行super.dispatchTouchEven。 // 那么super是谁呢？我们在前面说过，ViewGroup是继承自View的，那么他就是执行View的dispatchTouchEvent。 handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; ... //省略 &#125; // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; // -&gt;&gt; 分析1 resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; ...//省略 &#125;/** * 分析1 * 在同一事件系列结束后调用resetTouchState(); */private void resetTouchState() &#123; // 对mFirstTouchTarget清空还原 clearTouchTargets(); resetCancelNextUpFlag(this); mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; mNestedScrollAxes = SCROLL_AXIS_NONE;&#125; 流程此图搬自Carson_Ho大佬的博客 4.3 View事件分发源码dispatchTouchEvent1234567891011121314151617181920212223242526272829303132public boolean dispatchTouchEvent(MotionEvent event) &#123; ...//省略 boolean result = false; ...//省略 // 和ViewGroup一样的判断，判断当前视图是否被遮挡或者不可见 if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; // 检测有没有设置OnTOuchListener，如果有，并且onTouch方法返回true那么进入if，结果导致onTouchEvent不被执行 if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; // 如果没进入上面的if，也就相当于没有设置OnTouchListener，那么执行onTOuchEvent if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; ...//省略 return result;&#125; 从上面可以看出，onTouch的优先级高于onTouchEvent。 onTouchEvent1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); /** * 注释1 * 只有在Click、LongClick、contextClick都不可用的时候才为false */ final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; // 首先判断是不是不可用，如果是，则进入if if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. // -&gt;&gt; 注释1（见上面👆） return clickable; &#125; // 如果View有代理会执行这个方法 if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; // 这块我们只调出ACTION_UP来看 // 只要clickable为true(见上面注释1👆)或者TOOLTIP(可能是Android8.0新出的提示功能吧) if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: ...//省略 if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; // -&gt;&gt; 分析1 performClickInternal(); &#125; &#125; &#125; ... //省略 &#125; mIgnoreNextUpEvent = false; break; ... //省略其它几种MotionEvent &#125; return true; &#125; // 由代码可知只要上面的if语句成立，不管进入switch中的任何ACTION或是都不进入，返回值都是true，即事件消费了。 return false;&#125;/** * 分析1：performClick（） */public boolean performClick() &#123; if (mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); mOnClickListener.onClick(this); return true; // 只要我们通过setOnClickListener（）为控件cvView注册1个点击事件 // 那么就会给mOnClickListener变量赋值（即不为空） // 则会往下回调onClick（） &amp; performClick（）返回true &#125; return false; &#125; 流程]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
        <tag>源码</tag>
        <tag>事件分发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL ES 2.0笔记2——顶点、坐标、图元]]></title>
    <url>%2Fposts%2F268eb1c2.html</url>
    <content type="text"><![CDATA[上节我们对OpenGL做了一个大致的介绍，并写了一个基本框架，在这节中我们将会介绍顶点、坐标系和图元 顶点在OpenGL中，所有的东西的结构都是从一个顶点开始的。 所谓顶点，就是一个几何图形的拐点。在介绍顶点之前，我们首先介绍下OpenGL坐标。 OpenGL坐标系如果有会Android开发的朋友，一定会默认为从屏幕的左上角开始，水平往右是x轴，竖直向下是y轴。 但是在OpenGL中是不同的，OpenGL是从显示视窗的正中心是中心，也就是$(0, 0)$，而屏幕最左边的x轴坐标是-1，屏幕最右边的x轴坐标是1，屏幕最上面的y轴坐标是1，屏幕最下面的y轴坐标是-1，也就是下面这幅图： 在代码中定义顶点在OpenGL中定义顶点有点特殊，我们第一反应都是直接拿数组将顶端存起来就行了，但是在OpenGL中，你除了要将顶点的坐标用数组存起来以外，还得定义一个常量，用来标记一个顶点有两个分量：1234567891011121314151617181920private static final int POSITION_COMPONENT_COUNT = 2;float[] tableVerticesWithTriangles = &#123; // Triangle 1 -0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, // Triangle 2 -0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, // Line 1 -0.5f, 0f, 0.5f, 0f, // Mallets 0f, -0.25f, 0f, 0.25f&#125;; 我们采用浮点数的顺序列表定义顶点数据，这个数组通常被成为顶点属性。 图元在OpenGL中，只能绘制点、直线和三角形，这三个也被称为图元。 也就意味着，其它所有的图形都得通过这三个基本图元来实现。 如果我们需要绘制一个点，那么一个坐标就可以了，但是如果我们需要绘制一条直线，就需要两个坐标，如果绘制一个三角形，就需要三个坐标。 那么我们就以绘制一个正方形举例： 123456float[] squareVerticesWithTriangles = &#123; -0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, 0.5f, -0.5f&#125;; 如果我要在这个正方形中间加一个横线的话，那么就直接在上面的数组里面去加，到时候要将顶点着色器加载到图形中的时候再去处理：1234567891011float[] squareVerticesWithTriangles = &#123; // Square -0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, 0.5f, -0.5f, // Line -0.5f, 0, 0.5f, 0&#125;; 让数据可以被OpenGL读取在上面，我们已经完成了顶点的定义，但是现在OpenGL尚还不能读取他们。其原因是这些代码的运行环境与OpenGL运行环境使用了不一样的语言。 当我们运行Java语言的时候，并不是直接运行在硬件上的，而是运行在JVM(纯Java)或者Dalvik(Android)虚拟机上的，并且运行在这些虚拟机上的时候，并不能直接访问本地环境；其次，虚拟机还采用的垃圾回收机制，当检测到变量、对象不再被使用时，就自动释放掉这些内存。 但是本地环境不能这样，因为他是直接运行在硬件上的，他不希望内存会被移来移去或者自动释放。 所以我们就需要一个方案，让Android程序与OpenGL进行通信。其实Android代码与硬件通信有两种方法： 通过JNI技术； 通过调用android.opengl.GLES20包里面的方法。 我们这块主要是通过第二种方法。 Java中有一种特殊的集合，可以分配本地的内存块，并将Java的数据复制到本地内存。代码如下：12345678910111213// 因为Java中国一个Float型数据占4个字节private static final int BYTES_PER_FLOAT = 4;// 声明一个字节缓冲区private final FloatBuffer vertexData; vertexData = ByteBuffer // 分配一块本地内存，所以是数组长度 * 类型所占字节 .allocateDirect(tableVerticesWithTriangles.length * BYTES_PER_FLOAT) // 按照本地字节序组织内容 .order(ByteOrder.nativeOrder()) .asFloatBuffer(); // 将数据存入 .put(tableVerticesWithTriangles);]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>OpenGL</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL ES 2.0笔记1——简介]]></title>
    <url>%2Fposts%2Fa92b4a54.html</url>
    <content type="text"><![CDATA[OpenGL是什么？OpenGL ES又是什么？简介OpenGL是一个跨平台的软件接口语言，用于调用硬件的2D、3D图形处理器。 然而受限于现在的移动设备性能，如果将OpenGL直接用在他们上面将会特别卡，于是就出现了OpenGL ES。 OpenGL ES是OpenGL的分支，他专门作用于嵌入式设备，去掉了OpenGL很多不必要的功能。 应用场景 游戏 视频播放器 视频编辑应用 图片编辑应用 等对图像处理的及时性要求较高的应用场景。 Android对OpenGL ES 的支持 OpenGL ES 版本 基于OpenGL的版本 Android引入的版本 兼容性 功能、特色 1.0&amp;1.1 1.3&amp;1.5 Android 1.0 - 固定的图像管道，开发难度相比2.0低 2.0 2.0 Android 2.2 不兼容1.x 可编程的渲染管道，性能效率更高，开发难度更高 3.0 3.x Android 4.3 兼容2.0 性能更高，支持ETC2格式的透明纹理压缩 3.1 4.x Android 5.0 兼容2.0/3.0 新增计算着色器、单独的着色器对象等新特性 版本的选择由于此篇博客是学习阶段写的，而我在网上找到的大部分博客都是2.0，所以就以2.0为主。 其实我觉得应该是3.0，2.0确实太老了，现在Android4.3的手机都较少见了，而3.1又太新了。 导入首先你得在AndroidManifest.xml中加入&lt;uses-feature android:glEsVersion=&quot;0x00020000&quot; android:required=&quot;true&quot; /&gt; 其中不同版本对应值： OpenGL ES 版本 glEsVersion 版本 2.0 0x00020000 3.0 0x00030000 3.1 0x00030001 基本框架Android框架里面提供了两个类来给你使用OpenGL ES API创建和操作图形：GLSrufaceView和GLSurfaceView.Renderer。 GLSrufaceView这是一个视图类，你可以通过OpenGL ES API来绘制和操作图形对象，他在功能上很类似与SurfaceView。你可以通过创建一个SurfaceView的实例并添加你的渲染器来使用这个类。 他的常用方法有： setEGLContextClientVersion：设置OpenGL ES版本，2.0则设置2 onPause：暂停渲染，最好是在Activity、Fragment的onPause()方法内调用，减少不必要的性能开销，避免不必要的崩溃 onResume：恢复渲染，用法类比onPause() setRenderer：设置渲染器 setRenderMode：设置渲染模式 requestRender: 请求渲染，由于是请求异步线程进行渲染，所以不是同步方法，调用后不会立刻就进行渲染。渲染会回调到Renderer接口的onDrawFrame()方法。 queueEvent：插入一个Runnable任务到后台渲染线程上执行。相应的，渲染线程中可以通过Activity的runOnUIThread的方法来传递事件给主线程去执行 其中，GLSurfaceView的渲染模式有： RENDERMODE_CONTINUOUSLY：不停地渲染 RENDERMODE_WHEN_DIRTY：只有调用了requestRender()之后才会触发渲染回调onDrawFrame方法 GLSurfaceView.Renderer此接口定义了在GLSurfaceView中绘制图形所需的方法。必须将此接口的实现作为单独的类提供，并使用GLSurfaceView.setRenderer()将其添加到GLSurfaceView的实现类中。 他的主要方法有三个： onSurfaceCreated(GL10 gl, EGLConfig config)：GLSurfaceView内的Surface被创建时会被调用到 onSurfaceChanged(GL10 gl, int width, int height)：Surface尺寸改变时调用到 onDrawFrame(GL10 gl)：渲染绘制每一帧时调用到 一般情况下，首次创建GLSurfaceView时，会顺序调用onSurfaceCreated() -&gt; onSurfaceChanged() -&gt; onDrawFrame()。然后每绘制一帧，都会不停地回调onDrawFrame()方法。 编写流程首先我们来写一个基本框架。 创建一个Android项目，然后Activity选择EmptyActivity。 注意：本项目某些类或者方法通过AndroidStudio导入的时候会让你选择是从哪个包里面导入，一致选择android.opengl.GLES20 编写Activity打开我们项目的MainActivity，你就能看到熟悉的onCreate方法，接下来我们要对这个Activity进行一些更改。 首先，我们要创建一个GLSurfaceView的对象,并添加一个新的成员变量：12private GLSurfaceView glSurfaceView;private boolean rendererSet = false; 接下来将setContentView()移除，并对glSurfaceView进行初始化：12345@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); glSurfaceView = new GLSurfaceView(this);&#125; 由于我们是在写OpenGL ES2.0的代码，所以我们需要检测当前运行APP的系统支不支持OpenGL ES2.0。我们将下面几行代码添加到onCreate()里面去:123final ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);final ConfigurationInfo configurationInfo = activityManager.deviceConfigurationInfo();final boolean supportsEs2 = configurationInfo.reqGlEsVersion &gt;= 0x20000; 但是这段代码在模拟器上不能工作，因为GPU模拟部分有缺陷。为了使代码在模拟器上运行，我们要按如下代码修改检查条件：1234567final boolean supportsEs2 = configurationInfo.reqGlEsVersion &gt;= 0x20000 || (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1 &amp;&amp; (Build.FINGERPRINT.startsWith("generic") || Build.FINGERPRINT.startsWith("unknown") || Build.MODEL.contains("google_sdk") || Build.MODEL.contains("Emulator") || Build.MODEL.contains("Android SDK build for x86"))) 接下来就是配置渲染表面：12345678910111213if (supportsEs2) &#123; // 配置这个surface视图 glSurfaceView.setEGLContextClientVersion(2); // 配置Renderer glSurfaceView.setRenderer(FirstOpenGLProjectRenderer()); rendererSet = true;&#125; else &#123; Toast.makeText(this, "This device does not support OpenGL ES 2.0", Toast.LENGTH_SHORT).show(); return;&#125;setContentView(glSurfaceView); 最后我们还得处理下Activity的生命周期，也就是将GLSurfaceView的生命周期跟Activity的生命周期绑定起来：123456789101112131415@Overridevoid onPause() &#123; super.onPause(); if (rendererSet) glSurfaceView.onPause();&#125;@Overridevoid onResume() &#123; super.onResume(); if (rendererSet) glSurfaceView.onResume();&#125; 编写Renderer创建一个新的文件，命名为FirstOpenGLProjectRenderer，让让这个类继承自GLSurfaceView.Renderer。 接着就实现三个必备方法: onSurfaceCreate()：创建时被调用 1234@Overridepublic void onSurfaceCreated(GL10 glUnsed, EGLConfig config) &#123; glClearColor(1.0f, 0.0f, 0.0f, 0.0f); //设置一个清空屏幕用的颜色&#125; onSurfaceChanged()：创建后每当Surface尺寸改变时，都调用此方法 1234@Overridepublic void onSurfaceChanged(GL10 glUnsed, int width, int height) &#123; glViewport(0, 0, width, height); //设置视窗尺寸&#125; onDrawFrame()：绘制每一帧时调用 1234@Overridepublic void onDrawFrame(GL10 glUnsed) &#123; glClear(GL_COLOR_BUFFER_BIT); //清空屏幕&#125; 然后就可以运行程序了，你就可以看到整个屏幕都成了红色，这是为啥呢？因为我们在onSurfaceCreated方法里面设置了glClearColor(1.0f,0.0f,0.0f,0.0f)。这个方法的参数对应的是RGBA，然后我们又在onDrawFrame方法中设置了清屏，所以这样你就会看到的是红色了。]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>OpenGL</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门并开发天气预报APP(8)——天气预报第二步-选择省、市、区界面及网络请求]]></title>
    <url>%2Fposts%2Ff0e3723.html</url>
    <content type="text"><![CDATA[项目Github地址：a1203991686/CoolWeather_Flutter 在第六章中我们写了天气预报的页面， 但是你作为天气预报肯定能选择城市吧。所以我们现在来写选择省、市、区的界面。 我们使用的是郭霖大神在第一行代码最后面酷欧天气的API。 1. 实现界面既然是一个选择省市区的界面，那么我们就用ListView。 首先看一下大致界面： 就直接使用ListView的builder()方法，忘了的同学可以看前面第5章。 省在view文件夹下新建一个类provinces_page.dart，接下来就在这个文件里面写代码：12345678910111213141516171819202122232425262728class ProvincesPageWidget extends StatefulWidget &#123; ProvincesPageWidget(&#123;Key key&#125;) : super(key: key); @override ProvincesPageStateWidget createState() =&gt; new ProvincesPageStateWidget();&#125;class ProvincesPageStateWidget extends State&lt;ProvincesPageWidget&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: new AppBar( title: Text( "省份", style: TextStyle(fontSize: 25.0), ), ), body: ListView.builder( itemCount: 30, itemBuilder: (context, index) &#123; return ListTile( title: Text("$index"), ); &#125;, ), ); &#125;&#125; 市和省一样。在view文件夹下新建一个类city_page.dart，接下来就在这个文件里面写代码。照着省的依葫芦画瓢，写一个ListView。 区和省一样。在view文件夹下新建一个类counties_page.dart，接下来就在这个文件里面写代码。照着省的依葫芦画瓢，写一个ListView。 2. 网络请求网络请求可以看下之前第7章的内容。主要是通过Dio进行网络请求。大家可以看下第7章网络请求的内容。 我们网络请求主要需要以下几个API： 请求省份列表：http://guolin.tech/api/china 请求对应市列表：http://guolin.tech/api/china/provinceID 请求对应区县列表：http://guolin.tech/api/china/provinceID/cityID 由于我们在之前文章中使用的省作为例子，这块我们就用区县作为例子： 转为Dart类首先使用网站https://caijinglong.github.io/json2dart/来讲Json数据转为Dart实体类： 然后在项目lib目录新建一个文件夹。名为bean。这个文件夹主要存放实体类的代码。然后在这个文件夹下面新建一个dart文件，命名为Counties。然后把生成的Dart代码复制粘贴进去。但是你会发现复制进去后会报错，这个不用急，接下来我们来处理错误。 生成.g.dart文件接下来在项目根目录的pubspec.yaml文件的dependencies项下面添加依赖json_annotation、dev_dependencies项下面添加build_runner和json_serializable。 接着打开终端，定位到项目根目录，输入flutter packages pub run build_runner build，运行即可。运行完毕你就会发现你项目的存实体类的lib/bean目录多了一个文件，名为Counties.g.dart。同时你Counties.dart里面的错误也没有了。 网络请求最后你就可以通过Dio来进行网络请求了。1Dio().get(http://guolin.tech/api/china/$_provinceID/$_cityID); 那么到这有的同学可能就会问了，你网址里面有provinceID和cityID，那这两个怎么获取，这个时候就得用上带值路由跳转了。 我们一般都是这样的一个逻辑:先选择省份、再选择城市、最后选择区和县。所以我们这个CountyPageWidget肯定是由CityPageWidget调用的。那么我们可以在CityPageWidget的ListView里面将Text通过GestureDetector包起来，然后将GestureDetector的onTap方法设置为跳转到CountyPageWidget。CityPageWidget的ListView代码如下：12345678910111213141516171819ListView.builder( itemCount: _cityList.cities.length, itemBuilder: (context, index) &#123; return GestureDetector( child: ListTile( title: Text("$&#123;_cityList.cities[index].name&#125;"), ), onTap: () &#123; Navigator.push(context, MaterialPageRoute(builder: (context) &#123; return CountiesPageWidget( provinceID: _provinceID, //由CityWidget的上一级ProvinceWidget传过来， cityID: _cityList.cities[index].id, // 由网络请求回来的数据传入 ); &#125;)); &#125;, ); &#125;,); 这样CountyPageWidget所需的provinceID和cityID都是由CityPageWidget传入的，那么我们怎么对他传入的值进行处理呢，怎么把它添加到网址里去？接下来大家看代码就行了：1234567891011121314151617181920212223242526272829303132333435363738394041class CountyPageWidget extends StatefulWidget &#123; //在Widget中定义两个，方便由其他Widget传入 final int provinceID; final int cityID; // 设置构造方法，在构造方法中传入两个变量 CountyPageWidget(&#123;Key key, this.provinceID, this.cityID&#125;) : super(key: key); @override CountyPageWidgetState createState() =&gt; CountyPageWidgetState();&#125;class CountyPageWidgetState extends State&lt;CountyPageWidget&gt; &#123; // 在State中定义两个变量 int _provinceID; int _cityID; List&lt;County&gt; _county; @override void initState() &#123; // 在此将Widget中的两个变量赋值给State中的变量 _provinceID = widget.provinceID; _cityID = widget.cityID; super.initState(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: new AppBar( title: Text( "区县", style: TextStyle(fontSize: 25.0), ), ), body: FutureBuilder( // UI异步更新组件 // 这块就可以调用了 future: Dio().get("http://guolin.tech/api/china/$_provinceID/$_cityID"), builder: (BuildContext context, AsyncSnapshot snapshot) &#123; ...省略后面所有代码&#125; 3. UI异步更新与异步更新相关的知识大家也可以看我们之前的第7章博客，这块只讲应用。 省将Scaffold的body参数设置为FutureBuilder，并在FutureBuilder里面调用ListView:12345678910111213141516171819202122232425262728293031323334FutureBuilder( future: Dio().get("http://guolin.tech/api/china"), builder: (BuildContext context, AsyncSnapshot snapshot) &#123; if (snapshot.connectionState == ConnectionState.done) &#123; Response response = snapshot.data; //发生错误 if (snapshot.hasError) &#123; return Text(snapshot.error.toString()); &#125; provinceList = getProvinceList(response.data); //请求成功，通过项目信息构建用于显示项目名称的ListView return ListView.builder( itemCount: provinceList.length, itemBuilder: (context, index) &#123; return GestureDetector( child: ListTile( title: Text("$&#123;provinceList[index].name&#125;"), ), onTap: () &#123; Navigator.push(context, MaterialPageRoute(builder: (context) &#123; return CityPageWidget( provinceID: provinceList[index].id, ); &#125;)); &#125;, ); &#125;, ); &#125; // 请求未完成时弹出loading return CircularProgressIndicator(); &#125;,) 市与省同理:1234567891011121314151617181920212223242526272829303132333435FutureBuilder( future: Dio().get("http://guolin.tech/api/china/$_provinceID"), builder: (BuildContext context, AsyncSnapshot snapshot) &#123; if (snapshot.connectionState == ConnectionState.done) &#123; Response response = snapshot.data; //发生错误 if (snapshot.hasError) &#123; return Text(snapshot.error.toString()); &#125; _cityList = getCityList(response.data); //请求成功，通过项目信息构建用于显示项目名称的ListView return ListView.builder( itemCount: _cityList.length, itemBuilder: (context, index) &#123; return GestureDetector( child: ListTile( title: Text("$&#123;_cityList[index].name&#125;"), ), onTap: () &#123; Navigator.push(context, MaterialPageRoute(builder: (context) &#123; return CountiesPageWidget( provinceID: _provinceID, cityID: _cityList[index].id, ); &#125;)); &#125;, ); &#125;, ); &#125; // 请求未完成时弹出loading return CircularProgressIndicator(); &#125;,) 区县与省同理:1234567891011121314151617181920212223242526272829303132333435FutureBuilder( future: Dio().get("http://guolin.tech/api/china/$_provinceID/$_cityID"), builder: (BuildContext context, AsyncSnapshot snapshot) &#123; if (snapshot.connectionState == ConnectionState.done) &#123; Response response = snapshot.data; //发生错误 if (snapshot.hasError) &#123; return Text(snapshot.error.toString()); &#125; _county = getCountyList(response.data); //请求成功，通过项目信息构建用于显示项目名称的ListView return ListView.builder( itemCount: _county.length, itemBuilder: (context, index) &#123; return GestureDetector( child: ListTile( title: Text("$&#123;_county[index].name&#125;"), ), onTap: () &#123; _saveCityID(_county[index].weatherId); Navigator.push(context, MaterialPageRoute(builder: (context) &#123; return MainPage( cityID: _county[index].weatherId, ); &#125;)); &#125;, ); &#125;, ); &#125; // 请求未完成时弹出loading return CircularProgressIndicator(); &#125;,)]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门并开发天气预报APP(7)——Http网络请求、Json转Dart实体类及异步更新UI]]></title>
    <url>%2Fposts%2F163d319c.html</url>
    <content type="text"><![CDATA[相关Demo源码可见Github a1203991686/CoolWeather_Flutter Flutter Http 网络请求Flutter网络请求可分为两种方式，一种为Dart:IO库中为我们提供的HttpClient，另一种为Dart第三方库Dio。 HttpClientHttpClient是Dart:IO库自带的一个类，通过他来实现网络请求最底层、也可以完完全全的自定义设置，但是相对于其他人封装好的第三方库来说显得复杂。 引入导入Dart:IO库：1import 'dart:io'; 创建一个HttpClient:1HttpClient httpClient = new HttpClient(); 创建一个Uri如果你是Http请求：1234567var uri = new Uri.http( host, queryParameters: &#123; "xx":"xx", "yy":"dd" &#125;); 如果你是Https请求：1234567var uri = new Uri.https( host, queryParameters: &#123; "xx":"xx", "yy":"dd" &#125;); 根据uri获取返回数据12HttpClientRequest request = await httpClient.getUrl(uri);HttpClientResponse response = await request.close(); 读取内容进行这一步得导入dart:convert库：1234567import 'dart:convert';... //省略中间代码 String responseBody = await response.transform(Utf8Decoder()).join();print(respinseBody) 最后关闭Client1httpClient.close(); DioDio是Dart社区上别人上传的第三方库，他封装了HttpClient，相较来说更为简单、方便。 引入在项目的pubspec.yaml文件的dependencies中导入Dio：123dependencies: dio: // 如果冒号后面不带具体版本信息则表示自动下载最新版 接着在需要使用的代码文件里面，import导入他：1import 'package:dio/dio.dart'; 接着我们就可以使用Dio了。 示例首先得创建一个Dio对象。1Dio dio = Dio(); 发起GET请求：123Response response;response=await dio.get(uri)print(response.data.toString()); 发起POST请求：1response=await dio.post(uri); Json转Dart手动生成Dart实体类首先得大家安利一个网站，因为Dart实体类比Java实体类多了几个方法，所以相对来说麻烦，通过这个网站就可以自动生成json数据对应的实体类:https://caijinglong.github.io/json2dart/ 比方说我们使用这个链接(http://guolin.tech/api/china)，并让他自动转dart： 接下来只需要创建dart文件，然后再把代码复制进去就行了。 不出意外，代码肯定会报错。 报错信息为:12345error: Target of URI hasn't been generated: 'province.g.dart'. (uri_has_not_been_generated at [cool_weather] lib/bean/province.dart:3)error: The method '_$ProvinceFromJson' isn't defined for the class 'Province'. (undefined_method at [cool_weather] lib/bean/province.dart:31)error: The method '_$ProvinceToJson' isn't defined for the class 'Province'. (undefined_method at [cool_weather] lib/bean/province.dart:33) 这是因为我们项目下还没有province.g.dart这个文件，这个文件是根据dart实体类自动生成的，那么我们该怎么生成他呢？ 这个时候我们需要在pubspec.yaml文件中导入三个依赖包：我们重点只需要管三个写着需要导入的。输入之后点击pubspec.yaml文件右上角的packages get，就会自动下载包了。 然后在终端中，转到项目根目录下，输入1flutter packages pub run build_runner build 接着你就会惊喜的发现，在你的dart实体类下面多了一个文件，也就是你所缺失的~.g.dart文件，并且实体类中那些报错也都没了。 将请求回来的Response转为Dart实体类接着HttpClient返回来的responseBody或者Dio返回的response 12List&lt;Province&gt; provinceList;provinceList = ProvinceList.getProvinceList(jsonResponse); provinceList就是返回来的数据转成的实体类的对象了。 异步更新UI在此处介绍两种方法，第一种是我自己想出来的沙雕方法，第二种是通过Flutter提供的专门用于异步更新UI的组件FutureBuilder。 沙雕方法在此说一下我这个方法的想法。 大家可以回顾下我之前讲Widget的时候说过，Widget有一个方法initState可以用来加载UI，以及一个setState方法可用来提醒Flutter重新加载UI。 说到这很多同学一定想到了，我们可以在获取到数据之后通过setState方法来更新UI。 获取到数据这个不同多说，上面讲的全都是获取数据。 设置一个空的实体类此处我还是拿上面的Province.dart来做例子。我们正常情况下获取到的数据转成的实体类的对象是List&lt;Province&gt; provinceList。所以我们此处先设置一个空的对象:List&lt;Province&gt; _provinceList。 接着在initState里面调用网络请求的方法：12345@overridevoid initState() &#123; getProvince(); super.initState();&#125; 然后在getProvince方法里面获取数据，并将数据provinceList传给_provinceList： 1234567void getProvince() async &#123; var response = await Dio().get("http://guolin.tech/api/china"); provinceList = ProvinceList.getProvinceList(response); setState(() &#123; _provinces = provinceList; &#125;);&#125; 这样就可以当获取到数据的时候就通知Flutter更新状态了。这个时候有的同学可能会问我，你这个也只是获取到数据的时候才更新啊，那当还没获取到数据的时候呢？ 这块就体现到了为什么我们要设置一个_provinces了。 我们完全可以在build方法设置下，判断下_provinces为不为空:如果为空，就证明没数据，就加载其它页面；如果不为空，就证明有数据了，那就加载数据。12345body: _provinces == null ? new Text("正在请求") : new ListView.builder( ... //省去代码，总的来说就是将_provinces的数据加载ListView里面，一个ListView的基本构造方法 ) FutureBuilder回归正题，我上面那个方法真的是有够沙雕的。 那我们来看看这个名正言顺的Flutter亲生儿子FutureBuilder。 首先我们看下定义：12345FutureBuilder(&#123; this.future, this.initialData, @required this.builder,&#125;) future：异步任务； initialData：初始化数据； builder：builder方法。 示例1234567891011121314151617181920212223242526272829303132333435body: FutureBuilder( future: Dio().get("http://guolin.tech/api/china"), builder: (BuildContext context, AsyncSnapshot snapshot) &#123; if (snapshot.connectionState == ConnectionState.done) &#123; Response response = snapshot.data; print(response.toString()); //发生错误 if (snapshot.hasError) &#123; return Text(snapshot.error.toString()); &#125; provinceList = ProvinceList.fromJson(response.data); //请求成功，通过项目信息构建用于显示项目名称的ListView return ListView.builder( itemCount: provinceList.provinces.length, itemBuilder: (context, index) &#123; return GestureDetector( child: ListTile( title: Text("$&#123;provinceList.provinces[index].name&#125;"), ), onTap: () &#123; Navigator.push(context, MaterialPageRoute(builder: (context) &#123; return CityPageWidget( cityID: provinceList.provinces[index].id); &#125;)); &#125;, ); &#125;, ); &#125; // 请求未完成时弹出loading return CircularProgressIndicator(); &#125;,)]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门并开发天气预报APP(6)——天气预报第一步-界面]]></title>
    <url>%2Fposts%2F15395a84.html</url>
    <content type="text"><![CDATA[经过前面的对于Flutter的介绍，我们现在已经可以开始写我们的天气预报APP的界面了。 项目Github地址：a1203991686/CoolWeather_Flutter 1. 大致界面最终写成的大致界面如图： 我们可以把这个界面拆分成如下部分： 可以看到我们APP主要有最上面用来显示地点和刷新时间的Title、显示温度和天气的两个Text、显示3天预报的ListView、显示空气质量的GridView、以及最后显示生活建议的ListView。 此处会用到我们前面学过的所有知识，如果有同学没有看过前面内容的，可以看下本系列前面的文章。 2. 创建项目首先我们创建一个新的Flutter项目： 在AndroidStudio点击File-&gt;New Flutter Project； 接着选择Flutter Application-&gt;NEXT。接着填写你的项目名称等一系列信息后点击next； 接着输入你的组织/公司名称作为包名，最后点击Finish即可，这样就新建了一个Flutter项目，并且Flutter会自动为你生成一个计数器Demo； 让我们把mian.dart里面的所有注释以及_MyHomePageState里面的build方法里面的代码都删掉； 接着在lib文件夹下新建一个文件夹，名叫view，到时候我们把所有与界面有关的代码文件都放在这个文件夹下面； 然后我们在view文件夹下面新建一个dart文件，命名为main_page。这个就是我们的天气详情页。 3. 设计好天气详情页框架首先我们需要导入material包，我们项目主要用material风格UI来写。 在开头输入import &#39;package:flutter/material.dart&#39;;，这样就导入了material包。接着创建我们的界面类MainPage。 由于我们在到时候写好网络请求后，所有的数据都得从网络获取，并且使用了异步的方法，也就是说我们先把页面加载了然后等获取的数据回来了在通知Flutter更新状态，所以这块我们得使用StatefulWidget。12345678910111213class MainPage extends StatefulWidget &#123; MainPage(&#123;Key key&#125;) : super(key: key); @override MainPageState createState() =&gt; new MainPageState();&#125;class MainPageState extends State&lt;MainPage&gt; &#123; @override Widget build(BuildContext context) &#123; &#125;&#125; 接着我们就得开始写build()里面的内容了。由于我们需要一个全屏的背景图片，所以我们就使用Container作为我们最外层的Widget，并使用BoxDecoration装饰容器配合DecorationImage来放置图片：123456789101112@overrideWidget build(BuildContext context) &#123; return Container( decoration: BoxDecoration( image: DecorationImage( image: NetworkImage("http://blog.mrabit.com/bing/today"), //必应每日一图背景 fit: BoxFit.cover, // 设置为全屏 ), ), child: _weatherBody(), );&#125; 这个时候我们的运行结果如图(①你背景图片多半和我不一样，因为上面那个Uri获取的是必应的每日一图，每天图片都不一样；②运行的时候记得把child: _weatherBody(),给注释掉，因为我们还没有定义_weatherBody()这个方法): 4. 设计title为了方便我就直接把剩下的布局单领出来放到_weatherBody()这个方法:123Widget _weatherBody() &#123; return&#125; 由于我们需要实现一个有Title的页面，所以最外层我选用了Scaffold：12345678910111213141516171819202122232425Widget _weatherBody() &#123; return Scaffold( backgroundColor: Colors.transparent, //背景透明 appBar: AppBar( centerTitle: true, title: Text( "北京", style: TextStyle(fontSize: 25.0), ), backgroundColor: Colors.transparent, //背景透明 actions: &lt;Widget&gt;[ //右侧Widget，相当于Android Toolbar中的menu Container( alignment: Alignment.center, //向中间对齐 child: Text( "12:10", textAlign: TextAlign.center, //文字向中间对齐 ), ) ], ), body: SingleChildScrollView( // 由于到时候整个页面一个屏幕可能放不下，就放置了一个滚动布局 ), );&#125; 这个时候的运行结果是： 5. 设计下面天气预报页面接下来可以开始下下面的天气显示页面了。 当前温度和天气情况首先写一个纵向线性布局Column:1234567body: SingleChildScrollView( child: Column( children: &lt;Widget&gt;[ ] )), 由于我们要显示在屏幕最右边，所以使用Align:1234567891011121314151617181920212223242526body: SingleChildScrollView( child: Column( children: &lt;Widget&gt;[ Align( alignment: Alignment.centerRight, child:Text( "26°C", style: TextStyle( fontSize: 50.0, color: Colors.white, ), ), ), Align( alignment: Alignment.centerRight, child:Text( "阴", style: TextStyle( fontSize: 20.0, color: Colors.white, ), ), ), ] )), 运行结果是： 接下来我们需要显示3天天气预报、天气质量以及生活建议的三个子控件，同样为了方便我们也把他们给单领出来，于是上面的Column接下来可以这样写：12345678910111213141516171819202122232425262728293031323334353637383940body: SingleChildScrollView( child: Column( children: &lt;Widget&gt;[ ... //上面的两个Text Padding( padding: EdgeInsets.only( left: 15.0, right: 15.0, bottom: 15.0, ), child: Container( color: Colors.black54, child: _weatherList(), //3天天气预报 ), ), Padding( padding: EdgeInsets.only( left: 15.0, right: 15.0, ), child: Container( color: Colors.black54, child: _atmosphereList(), //空气质量 ), ), Padding( padding: EdgeInsets.only( top: 15.0, left: 15.0, right: 15.0, bottom: 15.0, ), child: Container( color: Colors.black54, child: _lifestyleList(), //生活建议 ), ), ] )), 3天天气预报对于3天天气预报我们主要通过ListView来实现，由于到时候数据比较灵活，所以我们就直接使用ListView.Builder来实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546List&lt;String&gt; dates = ["2019/10/01", "2019/10/02", "2019/10/03"];List&lt;String&gt; temperatures = ["29/14", "30/18", "29/18"];List&lt;String&gt; texts = ["阴", "晴", "雨"];Widget _weatherList() &#123; return Column( children: &lt;Widget&gt;[ Align( alignment: Alignment.centerLeft, child: Text( "预报", style: TextStyle( color: Colors.white, fontSize: 20.0, ), ), ), ListView.builder( shrinkWrap: true, //这个是指根据ListView所有子Widget的长度来设定ListView的长度 physics: NeverScrollableScrollPhysics(), //禁止ListView自己的滑动，因为我们在外面用了个SingleChildScrollView，我们通过他的滑动就可以了 itemCount: dates.length, //ListView子项个数 itemBuilder: (BuildContext context, int index) &#123; return ListTile( title: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, //这个是Row的主轴的子项的分布格式，spaceBetween是指平均分布 mainAxisSize: MainAxisSize.max, children: &lt;Widget&gt;[ Text( "$&#123;dates[index]&#125;", style: TextStyle(color: Colors.white), ), Text( "$&#123;temperatures[index]&#125;", style: TextStyle(color: Colors.white), ), Text( "$&#123;texts[index]&#125;", style: TextStyle(color: Colors.white), ), ], ), ); &#125;), ], );&#125; 这个时候运行结果是： 空气质量这块我们需要用到GridView，由于只有两个显示内容，而且我们后期也没有需要动态添加的需求，所以我们就直接使用GridView构造方法，而不去使用GridView的builder方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364List&lt;String&gt; atmospheres = ["16", "56"];Widget _atmosphereList() &#123; return Column( children: &lt;Widget&gt;[ Align( alignment: Alignment.centerLeft, child: Text( "空气质量", style: TextStyle( color: Colors.white, fontSize: 20.0, ), ), ), GridView( shrinkWrap: true, //见上面3天天气预报的ListView处 physics: NeverScrollableScrollPhysics(), //见上面3天天气预报的ListView处 gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 2, //横轴三个子widget childAspectRatio: 2 //显示区域宽高相等 ), children: &lt;Widget&gt;[ Column( children: &lt;Widget&gt;[ Text( "$&#123;atmospheres[0]&#125;", style: TextStyle( color: Colors.white, fontSize: 40.0, ), ), Text( "能见度", style: TextStyle( color: Colors.white, fontSize: 20.0, ), ), ], ), Column( children: &lt;Widget&gt;[ Text( "$&#123;atmospheres[1]&#125;", style: TextStyle( color: Colors.white, fontSize: 40.0, ), ), Text( "湿度", style: TextStyle( color: Colors.white, fontSize: 20.0, ), ), ], ), ], ), ], );&#125; 运行后的效果是： 生活建议这块和3天天气预报一样，而且数据比3天天气预报更多，所以他更适合用ListView.builder：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263List&lt;String&gt; _lifestyleWeatherBrf = [ "较舒适", "较舒适", "适宜", "适宜", "弱", "较适宜", "中"];List&lt;String&gt; _lifestyleWeatherTxt = [ "白天天气晴好，早晚会感觉偏凉，午后舒适、宜人。", "建议着薄外套、开衫牛仔衫裤等服装。年老体弱者应适当添加衣物，宜着夹克衫、薄毛衣等。", "各项气象条件适宜，无明显降温过程，发生感冒机率较低。", "天气较好，赶快投身大自然参与户外运动，尽情感受运动的快乐吧。", "天气较好，但丝毫不会影响您出行的心情。温度适宜又有微风相伴，适宜旅游。", "紫外线强度较弱，建议出门前涂擦SPF在12-15之间、PA+的防晒护肤品。", "较适宜洗车，未来一天无雨，风力较小，擦洗一新的汽车至少能保持一天。", ",气象条件对空气污染物稀释、扩散和清除无明显影响，易感人群应适当减少室外活动时间。"];Widget _lifestyleList() &#123; return Column( children: &lt;Widget&gt;[ Align( alignment: Alignment.centerLeft, child: Text( "生活建议", style: TextStyle( color: Colors.white, fontSize: 20.0, ), ), ), ListView.builder( shrinkWrap: true, physics: NeverScrollableScrollPhysics(), itemCount: _lifestyleWeatherBrf.length, itemBuilder: (BuildContext context, int index) &#123; return ListTile( title: Column( mainAxisAlignment: MainAxisAlignment.start, crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Text( "$&#123;_lifestyleWeatherBrf[index]&#125;", style: TextStyle( color: Colors.white, ), ), Text( "$&#123;_lifestyleWeatherTxt[index]&#125;", style: TextStyle( color: Colors.white, ), ), ], ), ); &#125;, ), ], );&#125; 运行结果是:]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门并开发天气预报APP(5)——SingleChildScrollView、ListView和GridView]]></title>
    <url>%2Fposts%2F30ff421d.html</url>
    <content type="text"><![CDATA[下面我们来介绍下Flutter中的滑动控件SingleChildScrollView、列表ListView和表格GridView。 SingleChildScrollViewSingleChildScrollView类似于Android中的ScrollView，我使用的较浅，在我目前看来，他和ScrollView的唯一区别就是它还可以横向滚动。 我们先来看下他的定义：123456789SingleChildScrollView(&#123; this.scrollDirection = Axis.vertical, //滚动方向，默认是垂直方向 this.reverse = false, this.padding, bool primary, this.physics, this.controller, this.child,&#125;) scrollDirection：设定滚动的方向，可以设定Axis.vertical或者Axis.horizon； reverse：是否按照阅读方向的反方向滑动，emmm这个可能有点觉得莫名其妙，但是如阿拉伯语言地区，他们阅读和我国古时候一样是从右向左的，所以如果reverse为true，且滚动方向是水平滚动的话，如果系统时阿拉伯语等从右向左阅读的语言时，方向是从右向左的； padding：留白的大小，和Padding的用法一样，通过EdgeInsets来设定，具体可以看前几章将Flutter基础Widget； primary：指是否使用widget树中默认的PrimaryScrollController；当滑动方向为垂直方向（scrollDirection值为Axis.vertical）并且没有指定controller时，primary默认为true； physics：用于控制滚动方式，这个等会重点讲解； controller：用于滚动监听及控制； child：子Widget。 physics这个参数是用于控制滚动方式，有几种参数： NeverScrollablePhysics：呈现不可滚动状态； BouncingScrollPhysics：当列表滑动结束时，会回弹列表，类似于iOS的列表滑动效果； ClampingScrollPhysics：滑动结束时会显示水波纹阴影，类似于Android的列表滑动效果； FixedExtentScrollPhysics：可以自己制作滑动效果，但是我也不会，所以在此不做解释😝。 ListViewListView可以沿一个方向上线性排布所有子组件（不仅局限于竖直方向）。 让我们来看下他的定义：1234567891011121314151617181920ListView(&#123; ... //可滚动widget公共参数 Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController controller, bool primary, ScrollPhysics physics, EdgeInsetsGeometry padding, //ListView各个构造函数的共同参数 double itemExtent, bool shrinkWrap = false, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, double cacheExtent, //子widget列表 List&lt;Widget&gt; children = const &lt;Widget&gt;[],&#125;) 公共属性我们就不讲了，上面SingleChildScrollView已经讲过了，我们现在只讲他特有的： itemExtent：用于控制ListView的长度，如果不为null，则强制所有子Widget合起来的长度小于设定的值：如果ListView是横向的，则所有子Widget横向长度的和小于它；如果ListView是纵向的，则所有子Widget纵向长度的和小于它； shrinkWrap：该属性表示是否根据子组件的总长度来设置ListView的长度，默认值为false 。默认情况下，ListView的会在滚动方向尽可能多的占用空间。当ListView在一个无边界(滚动方向上)的容器中时，shrinkWrap必须为true； addAutomaticKeepAlives：该属性表示是否将列表项（子组件）包裹在AutomaticKeepAlive组件中；典型地，在一个懒加载列表中，如果将列表项包裹在AutomaticKeepAlive中，在该列表项滑出视口时它也不会被GC（垃圾回收），它会使用KeepAliveNotification来保存其状态。如果列表项自己维护其KeepAlive状态，那么此参数必须置为false； addRepaintBoundaries：该属性表示是否将列表项（子组件）包裹在RepaintBoundary组件中。当可滚动组件滚动时，将列表项包裹在RepaintBoundary中可以避免列表项重绘，但是当列表项重绘的开销非常小（如一个颜色块，或者一个较短的文本）时，不添加RepaintBoundary反而会更高效。和addAutomaticKeepAlive一样，如果列表项自己维护其KeepAlive状态，那么此参数必须置为false； cacheExtent：设定缓存大小。 默认情况下一个一个设定children很麻烦，所以为了方便，Flutter还提供了一个builder构造方法： ListView.builder1234567ListView.builder(&#123; // ListView公共参数已省略 ... @required IndexedWidgetBuilder itemBuilder, int itemCount, ...&#125;) itemCount：是需要加载子Widget的长度； itemBuilder：列表项的构造器，当列表滚动到具体的index位置时，会调用该构建器构建列表项。 看例子：123456789101112ListView.builder( itemCount: _provinces.length, itemBuilder: (context, index) &#123; return GestureDetector( child: ListTile( title: Text("$index"), ), onTap: () &#123;&#125;)); &#125;, ); &#125;,) ListView.separated用于添加分割线。相较于ListView.builder多了一个separatorBuilder参数，该参数是一个分割组件生成器。 下面我们看一个例子：奇数行添加一条蓝色下划线，偶数行添加一条绿色下划线。12345678910111213141516171819class ListView3 extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; //下划线widget预定义以供复用。 Widget divider1=Divider(color: Colors.blue,); Widget divider2=Divider(color: Colors.green); return ListView.separated( itemCount: 100, //列表项构造器 itemBuilder: (BuildContext context, int index) &#123; return ListTile(title: Text("$index")); &#125;, //分割器构造器 separatorBuilder: (BuildContext context, int index) &#123; return index%2==0?divider1:divider2; &#125;, ); &#125;&#125; GridViewGridView可以构造一个网格列表，定义如下:1234567891011121314GridView(&#123; Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController controller, bool primary, ScrollPhysics physics, bool shrinkWrap = false, EdgeInsetsGeometry padding, @required SliverGridDelegate gridDelegate, //控制子widget layout的委托 bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, double cacheExtent, List&lt;Widget&gt; children = const &lt;Widget&gt;[],&#125;) 大部分参数和ListView都相同，我们只关注gridDelegate这个参数：gridDelegate作用是控制GridView子组件如何排列，Flutter中提供了两个类SliverGridDelegateWithFixedCrossAxisCount和SliverGridDelegateWithMaxCrossAxisExtent，我们可以直接使用，下面我们分别来介绍一下它们。 SliverGridDelegateWithFixedCrossAxisCount该子类实现了一个横轴为固定数量子元素的layout算法，其构造函数为：123456SliverGridDelegateWithFixedCrossAxisCount(&#123; @required double crossAxisCount, double mainAxisSpacing = 0.0, double crossAxisSpacing = 0.0, double childAspectRatio = 1.0,&#125;) crossAxisCount：横轴子元素的数量。此属性值确定后子元素在横轴的长度就确定了，即ViewPort横轴长度除以crossAxisCount的商。 mainAxisSpacing：主轴方向的间距。 crossAxisSpacing：横轴方向子元素的间距。 childAspectRatio：子元素在横轴长度和主轴长度的比例。由于crossAxisCount指定后，子元素横轴长度就确定了，然后通过此参数值就可以确定子元素在主轴的长度。 SliverGridDelegateWithMaxCrossAxisExtent该子类实现了一个横轴子元素为固定最大长度的layout算法，其构造函数为：123456SliverGridDelegateWithMaxCrossAxisExtent(&#123; double maxCrossAxisExtent, double mainAxisSpacing = 0.0, double crossAxisSpacing = 0.0, double childAspectRatio = 1.0,&#125;) maxCrossAxisExtent为子元素在横轴上的最大长度，之所以是“最大”长度，是因为横轴方向每个子元素的长度仍然是等分的。其它参数和SliverGridDelegateWithFixedCrossAxisCount相同。 GridView.builder和ListView一样，当子Widget数量较多时，也提供了builder方法:12345GridView.builder( ... @required SliverGridDelegate gridDelegate, @required IndexedWidgetBuilder itemBuilder,) 这个就不在这举例了，gridDelegate和前面一样的，itemBuilder和ListView的一样的。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门并开发天气预报APP(4)——基础Widget]]></title>
    <url>%2Fposts%2Fa3b37eac.html</url>
    <content type="text"><![CDATA[到这章我们就差不多可以开始写天气预报了。首先我们来看一下一些基础简单的Widget。 基础组件文本Text用于显示简单的文本，包含一些控制文本显示的属性。1234567891011Text( "1234",),Text( "1234", style: TextStyle( color: Colors.purple, fontSize: 32.0, fontWeight: FontWeight.bold, ),), 需要显示的文本信息直接放到一个双引号里面就可以了； textAlign：文本对齐方式； maxLines：文本显示的最大行数； overflow：指定多余文本的截断方式； textScaleFactor：指定文本相对于当前字体大小的缩放因子； TextStyle：设置显示文本的字体、颜色、粗细等样式： height：指定行高，但是不是绝对值，而是一个因子，相当于fontsize * height； fontFamily：设置字体； fontSize：设置字体大小 按钮不同的组件库有不同的按钮，我们现在只拿Material组件库中的按钮举例。 RaisedButton漂浮按钮，带有阴影和灰色背景。按下后阴影会变大。1234RaisedButton( child: Text("1234"), onPressed: () &#123;&#125;,); FlatButton扁平化按钮，背景透明且不带阴影，按下后会有背景色。1234FlatButton( child: Text("1234"), onPressed: () &#123;&#125;,) IconButton可点击的Icon，默认没有背景，按下后出现阴影1234IconButton( icon: Icon(Icons.thumb_up), onPressed: () &#123;&#125;,) 图片我们通过Image来显示图片，来源可以是asset、网络等位置。 从asset加载图片 现在项目根目录(也就是和android、ios、lib等目录同级)新建一个images目录，并把图片main.png拷进去； 在pubspec.yaml中的flutter部分添加一下内容： 加载该图片 123Image( image: AssetImage("images/amoled.png"),); Image也提供了一个快速构造函数：123Image.asset( "images/amoled.png",) 从网络加载图片1234Image( image: NetworkImage( "https://s2.ax1x.com/2019/05/27/VZrQ3V.png"),) 或者123Image.network( "https://s2.ax1x.com/2019/05/27/VZrQ3V.png",) 参数Image有一些基本参数123456789const Image(&#123; ... this.width, //图片的宽 this.height, //图片高度 this.fit,//缩放模式 this.alignment = Alignment.center, //对齐方式 this.repeat = ImageRepeat.noRepeat, //重复方式 ...&#125;) width和height：宽和高； fit：缩放模式： fill：拉伸图片知道填满； cover：按原图长宽比放大图片来填满，多余的部分舍去； contain：在保证图片长宽比不变的情况下尽可能去填满； fitWidth：宽度会缩放到显示空间的宽度，高度会按比例缩放，如果有多余的部分会被舍去； fitHeight：与fitWidth同理； none：没有适应策略，图片多大就显示多大，如果图片原尺寸小于显示空间就只显示原尺寸；如果大于则舍弃多余部分只显示中间部分； repeat：当图片小于显示空间时，会将图片重复显示。 布局组件线性布局(Row、Column)线性布局就相当于Android里面的LinearLayout，但是不同的是Flutter将竖直和水平布局单独拿了出来。 线性布局分为竖直布局Column和水平布局Row。他两属性都是一样的。再说属性之前我们先熟悉两个概念：主轴和交叉轴。如果是Column，主轴是竖直轴，交叉轴是水平轴；如果是Row，主轴是水平轴，交叉轴是竖直轴。1234567Row(&#123; ... MainAxisSize mainAxisSize = MainAxisSize.max, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, List&lt;Widget&gt; children = const &lt;Widget&gt;[],&#125;) mainAxisSize：主轴占用空间。默认是MainAxisSize.max，是指占用全部主轴空间。如果设置为MainAxisSize.min，那就只占用所有子组件所需要的空间； mainAxisAlignment：子Widget在主轴的对其方向； crossAxisAlignment：子Widget在交叉轴的对其方向； children：所有的子Widget。 弹性布局(Flex)其实这个布局和线性布局很有渊源，为什么这么说呢，因为Row和Column都继承自它。因此关于他和线性布局重复的地方我们现在就不再讲了，我们直说他“弹性”的部分。 Expanded可以按比例“拉伸”Row、Column和Flex子组件所占的空间。 1234const Expanded(&#123; int flex = 1, @required Widget child,&#125;) flex为弹性系数，如果为0或者null，则child不会阔伸占用的控件。如果大于0，则会按照flex的比例来分隔主轴全部空闲空间。其实说白了，就和Android里面LinearLayout的weight一样的。但是我们还是来举个例子吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869return Scaffold( appBar: new AppBar( title: Text("$_title"), ), body: Center( child: Flex( children: &lt;Widget&gt;[ Flex( direction: Axis.horizontal, children: &lt;Widget&gt;[ Expanded( flex: 1, child: Container( color: Colors.blue, child: Text("1234"), ), ), Expanded( flex: 2, child: Container( color: Colors.red, child: Text("1234"), ), ), ], ), Flex( direction: Axis.horizontal, children: &lt;Widget&gt;[ Expanded( flex: 3, child: Container( color: Colors.blue, child: Text("1234"), ), ), Expanded( flex: 1, child: Container( color: Colors.red, child: Text("1234"), ), ), ], ), Flex( direction: Axis.horizontal, children: &lt;Widget&gt;[ Expanded( flex: 1, child: Container( color: Colors.blue, child: Text("1234"), ), ), Expanded( flex: 1, child: Container( color: Colors.red, child: Text("1234"), ), ), ], ), ], direction: Axis.vertical, ), ),); 流式布局(Wrap、Flow)如果使用线性布局的话，当需要显示的内容超出屏幕边界的时候就会报错。 为了避免这种情况，我们就可以使用流式布局。当需要显示的内容超出屏幕边界的时候，就自动折行来继续显示。 Flutter中通过Wrap和Flow来实现流式布局。 Wrap我们来看下Wrap主要的一些参数：123456789101112Wrap(&#123; ... this.direction = Axis.horizontal, this.alignment = WrapAlignment.start, this.spacing = 0.0, this.runAlignment = WrapAlignment.start, this.runSpacing = 0.0, this.crossAxisAlignment = WrapCrossAlignment.start, this.textDirection, this.verticalDirection = VerticalDirection.down, List&lt;Widget&gt; children = const &lt;Widget&gt;[],&#125;) 其中很多参数Row和Column中都有，就不再介绍了，主要介绍点不同的： spacing：主轴方向子widget的间距 runSpacing：纵轴方向的间距 runAlignment：纵轴方向的对齐方式 下面有一个示例：1234567891011121314151617181920212223Wrap( spacing: 8.0, // 主轴(水平)方向间距 runSpacing: 4.0, // 纵轴（垂直）方向间距 alignment: WrapAlignment.center, //沿主轴方向居中 children: &lt;Widget&gt;[ new Chip( avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('A')), label: new Text('Hamilton'), ), new Chip( avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('M')), label: new Text('Lafayette'), ), new Chip( avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('H')), label: new Text('Mulligan'), ), new Chip( avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('J')), label: new Text('Laurens'), ), ],) FlowFlow较复杂，需要自己实现子Widget的位置转换，一般不推荐使用Flow。但是如果需要自定义布局策略，或者对性能要求较高，这个时候就得用Flow了。 但是由于太过于复杂，我也没咋用过，我就不在这讲了😝，大家有需要的可以百度，或者看我推荐的这篇：4.4 流式布局-《Flutter实战》 层叠布局(Stack)这个布局类似于Android中的Frame，允许在父布局的任意地方放置布局。1234567Stack(&#123; this.alignment = AlignmentDirectional.topStart, this.textDirection, this.fit = StackFit.loose, this.overflow = Overflow.clip, List&lt;Widget&gt; children = const &lt;Widget&gt;[],&#125;) alignment：决定如何去对齐； textDirection：确定alignment的参考系； fit：没有定位的子Widget如何去适应Stack的大小； overflow：决定超出Stack显示空间的子Widget如何去显示，如果Overflow.clip，则超出部分会隐藏，Overflow.visible则不会。 对齐与相对定位(Align)Align可以调整子Widget的位置，并且可以根据子Widget的宽高来确定自身的宽高。1234567Align(&#123; Key key, this.alignment = Alignment.center, this.widthFactor, this.heightFactor, Widget child,&#125;) alignment：代表子Widget在父Widget的起始位置； widthFactor和heightFactor确定Align本身的宽高。 来看一个简单的例子：1234567891011Container( height: 120.0, width: 120.0, color: Colors.blue[50], child: Align( alignment: Alignment.topRight, child: FlutterLogo( size: 60, ), ),) 运行结果： 3. 容器类组件填充(Padding)用过Android的同学一定熟悉，Padding就是负责留白的嘛。但是跟Android里面不同的是，在Android里面我们一般是在一个View里面添加Padding，但是在Flutter里面，Padding直接变成了一个Widget、一个布局。 使用方法：1234Padding (&#123; EdgeInsetsGeometry padding, Widget child,&#125;) 对于EdgeInsetsGeometry我们一般使用EdgeInsets类。 EdgeInsetsEdgeInsets类提供了几个便捷的方法： fromLTRB(double left, double top, double right, double bottom)：分别指定四个方向的填充； all(double value) : 所有方向均使用相同数值的填充； only({left, top, right ,bottom })：可以设置具体某个方向的填充(可以同时指定多个方向)； symmetric({ vertical, horizontal })：用于设置对称方向的填充，vertical指top和bottom，horizontal指left和right； 示例：12345678910111213141516body: Column( children: &lt;Widget&gt;[ Padding( padding: EdgeInsets.only(left: 12.0, bottom: 10.0), child: Text("1234"), ), Padding( padding: EdgeInsets.fromLTRB(0.0, 0.0, 10.0, 10.0), child: Text("1234"), ), Padding( padding: EdgeInsets.symmetric(vertical: 10.0), child: Text("1234"), ), ],), 运行结果：]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门并开发天气预报APP(3)——Widget]]></title>
    <url>%2Fposts%2Ffc77cdce.html</url>
    <content type="text"><![CDATA[简介在Flutter中，Widget是个非常基本的东西，我在上一章就说过，Flutter中只要是界面都是Widget，你可以把它就理解成是控件，但是又和Android的View控件不同的是，在Flutter中，包括Padding、Align、手势检测的GestureDetector等等，都算是Widget。 其实大多数时候，你就可以把Widget直接理解成UI控件就行了，因为Padding、Align、GestureDetector等等也都是为UI服务的，你就可以理解成Flutter中只要与UI有关的属性都可以算是控件。 Widget的状态在Android中，我们可以直接通过更新数据来达到刷新UI的目的。但是如果使用Flutter，就像我们前面说的计数器的Demo，如果直接通过StatelessWidget也就是无状态Widget的话，是没法进行刷新UI的，只能写一个死界面，也就是说如果在Flutter中界面写出来的就是一个死界面，只有通过刷新状态才能更新UI。 Widget有两个直接子类：StatelessWidget和StatefulWidget： StatelessWidget：这个是无状态Widget，实现build()方法后，就不可再变化，哪怕他的状态改变了。这句话可能有点矛盾，但是我来举个例子，比方说现在有一个StatelessWidget，他的内容就是一个Text，而这个Text的内容则显示了counter这个变量。当这个页面出现的时候，取了当时counter的值并显示了出来，但是我们后续不管counter这个值怎么改变，界面都是不会显示出来的。 StatefulWidget：这个是有状态Widget，当你有状态需要改变的时候就可以通过他来改变状态。 State的几种状态： 名称 状态 initState create之后被insert到渲染树时调用的，只会调用一次 didChangeDependencies state依赖的对象发生变化时调用 didUpdateWidget Widget状态改变时候调用，可能会调用多次 build 构建Widget时调用 deactivate 当移除渲染树的时调用 dispose Widget即将销毁时调用 StatelessWidget这个类相对简单，只需要实现build()方法就可以了。 StatelessWidget用于不需要维护状态的场景，也就是说如果他需要显示的某一个参数的值发生变化了他也不变。 123456789101112131415class Test extends StatelessWidget &#123; Test(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: new AppBar( title: Text("$title"), ), body: Text("1234"), ); &#125;&#125; 上面代码就演示了一个StatelessWidget的例子，功能是根据传入的title在界面的title了上显示出来。只实现了build()方法和构造方法。其中构造方法参数Key是必须得有的，而且如果该Widget还有其他状态的话，也需要写入构造方法。接着调用build()方法，将传入的title在界面的title上显示出来。 例如，如果我们调用它：12345678910@override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: Test(title: 'Flutter Demo Home Page'), ); &#125; 结果是： StatefulWidget与StatelessWidget相对的就是StatefulWidget。它的重点在于可以根据状态来更新。 他较于StatelessWidget，少了我们常用的build()方法，多了createState()方法。下面我就来讲一下他的用法，我还是拿上面的Test做例子。 123456789101112131415161718192021222324252627282930class Test extends StatefulWidget &#123; Test(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override _TestState createState() =&gt; _TestState();&#125;class _TestState extends State&lt;Test&gt; &#123; String _title; @override void initState() &#123; setState(() &#123; _title = widget.title; &#125;); super.initState(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: new AppBar( title: Text("$_title"), ), body: Text("1234"), ); &#125;&#125; 先看Test类，他继承自StatefulWidget，由于这个页面需要根据传入的参数来显示title，所以有一个状态title，并在构造方法中写入了他。接着调用了createState()方法。这个方法是所有StatefulWidget必须的，主要是为这个Widget创建他对应的State。 于是我们就在下面创建一个新的类，类名叫_TestState，继承自State&lt;Test&gt;。由于Widget有title这个状态，并且需要在界面中显示出来，所以为了降低他们的耦合度，我们在State类中也创建一个叫_title的状态，并_title = widget.title;。接下来是一个initState()方法，这个方法也是State必须的，在上面Widget的状态中我们讲到过，这个是初始化State的，同时在initSate()里面，我们写了一个setState()，也就是说我们告诉Flutter说这个方法里面的参数改变了接着Widget的状态也得改变。最后就是build()方法。 接下来我们调用它：12345678910@override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: Test(title: '1234'), ); &#125; 结果是：]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门并开发天气预报APP(2)——Flutter计数器Demo]]></title>
    <url>%2Fposts%2F956d1e66.html</url>
    <content type="text"><![CDATA[本文样例都是使用的AndroidStudio，如果你使用Xcode或者vscode，代码都是一样的，只是IDE创建项目的方式以及运行按键位置不同而已。 创建Flutter项目AndroidStudio中选择File-&gt;New-&gt;New Flutter Project-&gt;Flutter Application-&gt;NEXT。接着填写你的项目名称等一系列信息后就创建成功了，我们就会看到AndroidStudio已经为我们创建好了一个Demo，接着连上你的手机或者打开你的虚拟机，按下AndroidStudio的运行键，不一会儿，你就会惊喜的发现你的手机上就有一个Flutter计数器Demo了。 介绍下AndroidStudio界面这是我的AndroidStudio界面，接下来我分三个部分介绍下AndroidStudio的大致界面。 控制区 一次介绍每一个按钮的功能。 第一个是用来选择运行设备的，比方说我现在就选的是我的虚拟机，然后我按下运行后就可以将项目运行到我的虚拟机上而不会运行到连着我的电脑的手机上去； 第二个是选择运行哪个Flutter module，如果你同一个项目里面有多个module，你就可以在此选择你想要运行的module； 第三个灰色的选项框我也没弄懂她是干嘛的，我至今都没能选择过，一直都是灰的； 绿色的三角形，大家熟知，运行键； 红色的瓢虫，大家熟知，debug键； 不知道干嘛的； FlutterAPP的性能监视器； 闪电，这个是重点，也是Flutter的一大特性，热重载键，他能做到不需要重新编译代码就能将你修改的代码的效果在你的APP上显示出来； 不知道干嘛的； 红色的正方形，停止运行按钮。 Run运行区就是Flutter的信息显示区，类似于AndroidStudio的Logcat，能显示FlutterAPP运行中的一些信息。 Flutter Outline/Flutter Inspector区用于显示当前界面的一些构建信息。 Flutter项目结构 我们挑一些重要的说一下： .idea文件夹，AndroidStudio识别项目的必备文件夹，不用管； Android文件夹，存放Flutter构建的Android项目的文件夹； ios文件夹，存放Flutter构建的iOS项目的文件夹； lib文件夹，存放Flutter项目和资源的文件夹； pubspec.yaml文件，存放Flutter项目相关信息，如项目名称、版本、依赖等等，类似于Android项目的build.gradle文件。 main.dart文件我们通过讲这个文件来给大家大致介绍下Flutter项目代码结构。 全部源代码在此1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import 'package:flutter/material.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(title: 'Flutter Demo Home Page'), ); &#125;&#125;class MyHomePage extends StatefulWidget &#123; MyHomePage(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; _MyHomePageState();&#125;class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; int _counter = 0; void _incrementCounter() &#123; setState(() &#123; _counter++; &#125;); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( 'You have pushed the button this many times:', ), Text( '$_counter', style: Theme.of(context).textTheme.display1, ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: Icon(Icons.add), ), ); &#125;&#125; import首先我们看最开始的import区。 这块相当于C/C++的include，反而不像java的import。我为什么这么说呢，你想一下，你写java程序的时候，你是需要哪个类就直接在代码中输入类名，然后IDE会自动给你显示有这个类的所有的包，然后让你选包去导入；而写dart是需要你先导入包，才能在代码中写这个包中的类，如果你没有先导入包而直接到下面写的话，IDE是不会提示你这个类可能会在哪个包中，而是直接报错，这点和C/C++比较类似。 那我们为什么导入的是flutter/material.dart这个包呢？我在第一节里面说过，Flutter他内置了Android的Material Design风格和iOS的Cupertino风格的UI；所以这块就是导入Material Design风格UI文件，而如果你要使用Cupertino风格UI文件的话，把它改成Cupertino就行了。 main()1234567891011121314void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(title: 'Flutter Demo Home Page'), ); &#125;&#125; 第一行，指明项目的入口就是MyApp()。固定格式，可以不用管。 第二行就定义了一个类MyApp继承自StatelessWidget，并重写了父类的build()方法。Widget可以看成Flutter中的页面，只要是Flutter中的页面，都必须继承自Widget。他有点类似于Android中的View，但是不同于View的是，Flutter中的padding、align、layout等居然也是Widget。 如果是StatelessWidget，则代表她是一个“状态少”的Widget，我的理解就是状态相当于Widget的一些数值，比方说页面要显示计数器的计数count，那么这个count就是一个状态，只要有状态就使用StatefulWidget。像MyApp它没有状态，于是就用StatelessWidget。 继承自StatelessWidget的类必须实现build()方法，相当于这个类是一个死页面，只需要展示固定的内容，也就是不需要状态，所以直接通过build()直接写入界面就行。 build()方法必须同样返回一个Widget，所以我们就使用MaterialApp，其中我们给他的title、theme、home进行了赋值，同学们应该都能大致读懂啥意思，首页home则给了MyHomePage. MyHomePage123456789101112131415161718192021222324252627282930313233343536373839404142434445class MyHomePage extends StatefulWidget &#123; MyHomePage(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; _MyHomePageState();&#125;class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; int _counter = 0; void _incrementCounter() &#123; setState(() &#123; _counter++; &#125;); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( 'You have pushed the button this many times:', ), Text( '$_counter', style: Theme.of(context).textTheme.display1, ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: Icon(Icons.add), ), ); &#125;&#125; MyHomePage我们在前面说过，如果一个页面有数据也就是“状态”的话，那么他就得继承自StatefulWidget。 如果一个类继承自StatefulWidget，那这个类会很简单，只需要创建一个构造方法，构造方法中写入key以及该Widget需要的数据。然后重写createState()方法。 MyHomePageState如果一个类继承自StatefulWIdget，那么一定会有一个他的State类并继承自State&lt;该类&gt;，就像class _MyHomePageState extends State&lt;MyHomePage&gt;一样。 那我们来看看State类里面有些啥东西: 首先先定义“状态”：由于我们这个APP主要的功能是用来计数，所以必须定义一个int型变量来计数：1int _counter = 0; 接着如果我们这个_counter变量变了，那就得通知flutter说状态变了，需要更新UI：12345void _incrementCounter() &#123; setState(() &#123; _counter++; &#125;);&#125; 其中，setState()方法就是用来通知Flutter这个状态改变了，要去更新UI的。 最后重写build()方法来写入界面： Scaffold是一个组件，它提供了默认的导航栏、标题和包含主屏幕widget树（后同“组件树”或“部件树”）的body属性。 body后面是一个Center组件，它的作用是将它的子Widget定位到父Widget的中间。 Center后面是一个Column组件，这个组件类似于Android中的LinearLayout的orientation: Vertical，也就是垂直向的线性布局。同时Flutter也提供了Row这个水平向的线性布局。他们的子Widget是children属性，也就是可以写多个Widget。 Column里面是两个Text，这个没啥讲的 接下来是一个FloatingActionButton，这就是一个浮动按钮，Android里面有这个控件，核心是他的onPressed属性，这个就相当于onClick()，用于处理点击事件。 体验热重启首先先让项目在虚拟机或者手机上运行着，然后我们把页面Text中的”You have pushed the button this many times:”改为”You have clicked the button this many times:”，然后按热重启键（macOS版AndroidStudio默认是commond+s键），接着你就能里面在虚拟机或者手机上看到修改之后的结果。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门并开发天气预报APP(1)——Flutter安装]]></title>
    <url>%2Fposts%2F4bf666bf.html</url>
    <content type="text"><![CDATA[Flutter是什么Flutter是由谷歌推出的一个移动UI框架，可以让开发者快速的在Android和iOS上构建高质量的原生用户界面。 通过它来编写APP的好处在于： 它内置了Android的Material Design风格和iOS的Cupertino风格的UI； 它通过Dart语言编写，只需要编写一份代码就能在Android和iOS设备上得到同样的运行效果； 他有热重载功能，只需要运行APP后，代码更改一点然后点击热重载键就能快速显示出修改后的界面。 使用镜像安装由于一些众所周知的原因，Flutter在国内访问有时候会受到限制，因此Flutter官方为国内开发者搭建了临时镜像，大家可以将下面的环境变量添加到系统中：12export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 由于我用的是macOS，因此我就只演示macOS的。如果有Linux的用户则和macOS 的安装方式类似，甚至可以说一样；但是对于Windows用于，需要大家桌面右键此电脑-&gt;属性-&gt;弹出页面左侧栏的高级系统设置-&gt;环境变量，在下面的系统环境变量栏中点击新建，变量名输入上面等号左边的大写内容，不要export，值输入等号右边的内容，输入一组之后再点击新建接着输入下一组。 接下来我们开始说macOS。 首先你得确定你用的是什么shell如果你没更改过你macOS终端设置，那么你默认就是bash，但是如果你更改过，比方说我就换成了zsh，那么我觉得你应该知道在哪设置环境变量。 如果你是bash首先打开你macOS的终端，在启动台里面可以找到，接着对bash的环境变量进行设置，输入1vim ~/.bash_profile 回车，进入.bash_profile文件的编辑页面，然后按下键盘I键，进入vim的编辑模式，然后直接把上面的export环境变量赋值粘贴进去。然后按下Esc键退出vim的编辑模式，然后直接输入:wq回车保存并退出。接着输入1source ~/.bash_profile 让刚刚配置的环境变量生效即可。 如果你是zsh首先打开你macOS的终端，在启动台里面可以找到，接着对zsh的环境变量进行设置，输入1vim ~/.zshrc 回车，进入.zshrc文件的编辑页面，找到如图所示部分（重点在于有# export MANPATH=&quot;/Usrs/......的地方，因为我还有其它的环境变量，所以你的可能和我的不同）： 在# export下面，按下键盘I键，进入vim的编辑模式，然后直接把上面的export环境变量赋值粘贴进去。见我图中最下面标红的那地方，至于最后一行export PATH=~/development/flutter/bin:$PATH先不管。然后按下Esc键退出vim的编辑模式，然后直接输入:wq回车保存并退出。接着输入1source ~/.zshrc 让刚刚配置的环境变量生效即可。 下载Flutter SDK先去Flutter的官网去下载你对应系统的Flutter SDK 打开官网下载页：Flutter SDK release 选择你的系统对应的目录，然后默认选择Stable channel下载。(*Master channel这个是直接从github获取的github上的最新版，也就是说Flutter的开发者他写了点什么改了点什么都会里面在这个版本上显示出来，所以这个版本意味着非常不稳定，可能bug很多；Dev channel是开发版，Master channel经过一定测试之后的版本会发布到Dev channel上，但是不是大量的测试，所以可能还是不太稳定；Beta channel是测试版，每月发布一次，会把上个月所释放的所有Dev channel中最稳定的版本释放到Beta channel上，但是相对来说还是有点不稳定，适合想尝鲜的开发者；State channel是标准版，当Flutter维护人员认为某个版本足够稳定之后，就会发送到这个版本上去，一般开发者最好还是使用这个版本) 解压安装包到你想要的目录例如123// Linux/macOScd ~/developmentunzip ~/Downloads/flutter_macos_v0.5.1-beta.zip 添加Fluuter路径到环境变量中回顾第2项，把如下内容添加到环境变量中去1export PATH=/你上一步flutter解压的目录/flutter/bin:$PATH 运行Flutter doctor如果是macOS/Linux，直接在终端中输入flutter doctor即可。如果是Windows，则右键开始，选择PowerShell，然后输入flutter doctor即可。 这个命令的功能是检查你的Flutter是否正常安装。 如果正常安装的话会出现如下信息：1234567891011121314151617181920212223242526Doctor summary (to see all details, run flutter doctor -v):[✓] Flutter (Channel stable, v1.9.1+hotfix.4, on Mac OS X 10.13.6 17G65, locale zh-Hans-CN) [✓] Android toolchain - develop for Android devices (Android SDK version 29.0.1)[✗] Xcode - develop for iOS and macOS ✗ Xcode installation is incomplete; a full installation is necessary for iOS development. Download at: https://developer.apple.com/xcode/download/ Or install Xcode via the App Store. Once installed, run: sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer ✗ CocoaPods not installed. CocoaPods is used to retrieve the iOS and macOS platform side's plugin code that responds to your plugin usage on the Dart side. Without CocoaPods, plugins will not work on iOS or macOS. For more info, see https://flutter.dev/platform-plugins To install: sudo gem install cocoapods pod setup[✓] Android Studio (version 3.5)[!] IntelliJ IDEA Community Edition (version 2019.2.3) ✗ Flutter plugin not installed; this adds Flutter specific functionality. ✗ Dart plugin not installed; this adds Dart specific functionality.[✓] VS Code (version 1.38.1)[✓] Connected device (1 available)! Doctor found issues in 2 categories. 我的电脑运行之后会出现两个错误，因为Flutter doctor会自动检查电脑中所有能运行Flutter的编辑器或者IDE，然后判断他们配没配置Flutter。我的电脑是因为没有安装Xcode以及我没有在IDEA中配置Flutter，所以我这两项出错。 其实你只要保证除了IDE之外的项目都是正常的就行了，如果有错的话直接把报错信息放到百度里面进行搜索就可以了。至于IDE项目，如果你是iOS开发者，则保证Xcode或者是AppCode啥的前面是✔️就行了的，至于你电脑上的其它例如IDEA或者vscode啥的可以不用管；如果你是Android开发者，则保证你常用的IDE如Android Studio前面是✔️就行了的，至于你电脑上的其它例如IDEA或者vscode啥的可以不用管。 总而言之，确保除了IDE之外的其它项前面是对勾，然后确定一个你常用的写代码的工具前面有对勾就行了，如果你除了IDE之外的其它项有问题，就把错误信息直接百度；如果是你常用的IDE前面没对勾，那就百度你常用的IDE+Flutter来参考别人的配置教程。 由于我没有用过xcode所以就不讲xcode如何配置Flutter了，就分别讲如何在AndroidStudio和vscode配置Flutter。 Android Studio配置Flutter 打开你Android Studio的设置/首选项/Preferences，然后选择Plugins，在Marketplace里面搜索Flutter： 接着点击INSTALL安装就行了，并且安装Flutter插件会自动顺带安装Dart插件，如果没有安装Dart插件，你就一样的搜索Dart然后安装即可； 安装完成并重启Android Studio之后，仍然打开设置/首选项/Preferences，选择Languages &amp; Frameworks-&gt;Flutter，在最上面的SDK中的Flutter SDK path选择你第三步Flutter SDK解压缩的路径，不出意外的话下面Version会自动显示你Flutter SDK的版本，并且Languages &amp; Frameworks-&gt;Dart里面的Dart SDK path也会自动出现。 接着和之前一样运行flutter doctor,看看Android Studio前面有没有✔️，正常情况下是会有的。 vscode 配置Flutter 在vscode拓展里面搜索Flutter和Dart，安装； 接着和之前一样运行flutter doctor,看看vscode前面有没有✔️，正常情况下是会有的。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统6--死锁]]></title>
    <url>%2Fposts%2F68dc89d4.html</url>
    <content type="text"><![CDATA[6.1 死锁的引入在之前我们或多或少都涉及到了死锁，最直接的例子就是哲学家就餐筷子，如果每一个哲学家都拿起了他的右手的筷子，现在都在等左边的筷子。这样一直绕下去，从而产生了死锁。 6.1.1 资源问题在系统中存在着很多不同类型的资源，其中可以引起的死锁的主要是需要采用互斥访问方法的、不可以被抢占的资源、 6.1.1.1 可重用性资源和消耗性资源可重用性资源可重用性资源是一种可供用户重复使用多次的资源，它具有以下性质： 每一个可重用性资源中的单位只能分配给一个进程使用，不允许多个进程共享 进程在使用可重用性资源时，须按照这样的顺序：请求资源 -&gt; 使用资源 -&gt; 释放资源 系统中每一类可重用性资源中的单元数目是相对固定的，进程在运行期间既不能创建也不能删除它 可消耗性资源可消耗性资源又称为临时性资源，它是在进程运行期间，由进程动态的创建和消耗的，它具有以下性质： 每一类可消耗性资源的单元数目在进程运行期间是可以不断变化的，有时它可以有很多，有时可能为0 进程在运行过程中，可以不断地创造可消耗性资源的单元，将它们放入该资源类的缓冲区中，以增加该资源类的单元数目 进程在运行过程中，可以请求若干个可消耗性资源单元，用于进程自己的消耗，不再将它们返回给该资源类中 6.1.1.2 可抢占性资源和不可抢占性资源可抢占性资源可把系统中的资源分为两类，一类是可抢占性资源，是指某进程在获得这类资源后，该资源可以再被其它进程或系统抢占 不可抢占性资源另一类资源是不可抢占资源，一旦系统把某资源分配给该进程之后，就不能将它强行回收，只能在进程用完后自行释放 6.1.2 死锁的起因6.1.2.1 竞争不可抢占性资源引起的死锁通常系统中所拥有的不可抢占性资源其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局。 一个很简单的例子，进程$P_1$和$P_2$在并发执行，他们都要写两个文件$F_1$和$F_2$。其中$P_1$和$P_2$的代码分别为：123456789 P1 ....Open(f1, w);Open(f2, w); P2 ....Open(f2, w);Open(f1, w); 如果这两个进程在并发执行的时候，如果$P_1$先打开$F_1$和$F_2$，然后$P_2$才去打开$F_1$(或$F_2$)，由于文件$F_1$(或$F_2$)已经被打开，因此$P_2$会被阻塞。当$P_1$使用完$F_1$(或$F_2$)，这时$P_2$才可以去打开$F_1$(或$F_2$)，这样程序继续运行下去。 但是如果在$P_1$打开$F_1$的同时，$P_2$去打开$F_2$，每个进程都占有一个打开的文件，此时就可能出现问题。因为当$P_1$试图去打开$F_2$,而$F_2$试图去打开$F_1$时，这两个进程都会因文件已被打开而阻塞，因此这两个进程将会无限期地等待下去，从而形成死锁。 6.1.2.2 竞争可消耗资源引起的死锁如图所示，$m_1$、$m_3$、$m_3$是可消耗资源。进程$P_1$一方面产生消息$m_1$，利用send(p2,m1)将它发送给$P_2$，另一方面，有要求从$P_3$接受消息$m_2$；而$P_2$、$P_3$依次类推。 如果三个进程按以下顺序进行：123P1: ...send(p2, m1); receive(p3, m3);...P2: ...send(p3, m2); receive(p1, m1);...P3: ...send(p1, m3); receive(p2, m2);... 这三个进程都可以先将消息发送给下一个进程，相应地他们也都能都接收到从上一个进程发来的消息，因此三个进程都可以顺利的进行下去，不会发生死锁。 但是如果三个进程都先执行receive，在执行send，按下面的顺序运行：123P1: ...receive(p3, m3); send(p2, m1);...P2: ...receive(p1, m1); send(p3, m2);...P3: ...receive(p2, m2); send(p1, m3);... 那么这三个进程就会永远阻塞在它们的receive操作上，就会产生死锁。 6.2 死锁的定义、必要条件和处理方法6.2.1 死锁的定义如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的。 6.2.2 产生死锁的必要条件产生死锁必须同时具备下面四个必要条件，只要其中任一个条件不成立，死锁就不会发生： 互斥条件。进程对所分配的资源进行排他性使用。即该资源只允许一个进程使用，其他进程如果请求该资源只能等待。 请求和保持条件。进程已经保持一至少一个资源，但又提出了新的资源请求，而新资源已被其他进程占有，导致进程被阻塞。 不可抢占条件。 进程已获得的资源在为使用完之前不能被抢占，只有进程在使用完之后才能释放。 循环等待条件。发生死锁时，必然存在一个进程资源循环链，即进程集合$[P_0, P_1, P_2, ···, P_n]$中$P_0$正在等待一个$P_1$占用的资源，$P_1$正在等待一个$P_2$占用的资源，……，$P_n$正在等待一个$P_0$占用的资源 6.2.3 处理死锁的办法目前处理死锁的方法可归结为四种： 预防死锁。通过设置某些限制，去破坏产生死锁四个必要条件中的一个或几个来预防死锁。 避免死锁。在资源的动态分配过程中，用某种方法阻止系统进入不安全状态，从而避免发生死锁。 检测死锁。该方法允许进程在运行过程中发生死锁，但可通过检测机构及时地检测出死锁的发生，然后采取适当措施，把进城从死锁中解脱出来。 解除死锁。当检测到系统中已发生死锁时，就采取相应措施，将进程从死锁状态中解脱出来。 6.3 预防死锁预防死锁时通过破坏产生死锁四个必要条件中的一个或几个，以避免发生死锁。 6.3.1 破坏“请求和保持”条件当一个进程在请求资源时，他不能持有不可抢占资源。可通过一下两种不同的协议实现： 6.3.1.1 第一种协议所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源。此时若系统中有足够的资源分配给某进程，便可把其需要的所有资源分配给它。这样，该进程在整个运行期间，便不会再提出资源要求，从而破坏了“请求”条件。系统在分配资源时，只要有一种资源不能满足进程的要求，即使其所需的其他资源都空闲也不分配给它，而让该进程等待。由于该进程在等待期间未占有任何资源，于是破坏了“保持”条件，从而可以预防死锁的发生。 这种协议的优点是简单、易行且安全。但是缺点也极其明显： 资源被严重浪费，严重的恶化了资源的利用率。 使进程经常的发生饥饿现象。 6.3.1.2 第二种协议该协议是对第一种协议的改进，它允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行的过程中再逐步释放已分配给自己的、且已用毕的全部资源，然后再请求新的所需资源。 6.3.2 破坏“不可抢占”条件为了能破坏“不可抢占”条件，协议中规定，当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，他必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着进程已占有的资源会被暂时地释放，或者说是被抢占了，从而破坏了“不可抢占”条件。 6.3.3 破坏“循环等待”条件一个能保证“循环等待”条件不成立的方法是，对系统所有资源类型进行线性排序，并赋予不同的序号。排序后，便可以采用这样的预防协议：规定每个进程必须按照序号的地址顺序来请求资源。一个进程在开始时，可以请求资源$R_i$的单元，以后，当且仅当$F(R_j)&gt;F(R_i)$，进程才可以请求资源$R_j$。如果需要多个同类资源单元，则必须一起请求。 优点：资源利用率和系统吞吐量都有比较明显的改善。 缺点： 系统中各类资源所规定的序号必须稳定，这就限制了新类型设备的增加 可能会发生作业使用各类资源的顺序与系统规定的不同，造成资源的浪费。 这种按照规定次序申请资源的方法会限制用户简单，自主的编程。 6.4 避免死锁6.4.1 系统安全状态在死锁避免方法中，把系统的状态分为安全状态和不安全状态。当系统处于安全状态时，可避免发生死锁。反之，当系统处于不安全状态时，则可能进入到死锁状态。 在该方法中，允许进程动态的申请资源吗，但系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，才可将资源分配给进程，否则，另进程等待。 安全状态是指系统能按某种进程推进顺序为每个进程分配其所需资源，直至满足每个进程对资源的最大需求。如果无法找到这样一个序列，则称系统处于不安全状态。 6.4.2 利用银行家算法避免死锁为实现银行家算法，每一个新进程在进入系统时，他必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给进程。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不会，才分配资源。 6.4.2.1 银行家算法中的数据结构 可利用资源向量Available。代表系统中目前已有的可分配的该种资源的最大数。 最大需求矩阵Max。代表该进程对该资源的最大需求数。 分配矩阵Allocation。代表目前已经分配给该进程的该资源的数目。 需求矩阵Need。代表该进程还需要该资源的数目。 6.4.2.2 银行家算法设$Request_i$是进程$P_i$的请求向量，如果$Request_i[j]=K$，表示进程$P_i$需要$K$个$R_j$类型的资源。当$P_i$发出资源请求后，系统按下述步骤进行检查： 如果$Request_i[j] \le Need[i, j]$，便转向步骤2；否则任务出错，因为它所需要的资源数已超过它所宣布的最大值。 如果$Request_i[j] \le Available[j]$，便转向步骤3；否则，表示尚无足够资源，$P_i$需等待。 系统试探着把资源分配给进程$P_i$，并修改下面数据结构中的数值： $Available[j] = Available[j] - Request_i[j]$ $Allocation[i,j] = Allocation[i,j] + Request_i[j]$ $Need[i,j] = Need[i,j] - Request_i[j]$ 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程$P_i$，已完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程$P_i$等待。 6.4.2.3 安全性算法 设置两个向量：①工作向量Work，他表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，$Word = Available$；②FInish：他表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做$Finish[i] = false$；当有足够资源分配给进程时，再令$Finish[i] = true$。 从进程集合中找到一个能满足下述条件的进程：①$Finish[i]=false$；②$Need[i,j] \le Work[j]$；若找到则执行步骤3，否则执行步骤4. 若进程$P_i$获得资源后，可顺利执行，直至完成，并释放出分配给他的资源，故应执行： $Word[j] = Work[j] + Allocation[i,j];$ $Finish[i]=true;$ go to step 2; 如果所有进程的$Finish[i]=true$都满足，则表示系统处于安全状态；否则，系统处于不安全状态。 6.4.2.4 银行家算法例子题目假定系统中有五个进程${P_0, P_1, P_2, P_3, P_4}$和三类资源${A, B, C}$，各种资源的数量分别为10、5、7，在$T_0$时刻的资源分配情况如图所示： 在$T_0$时刻的安全性利用安全性算法对$T_0$时刻的资源分配情况进行分析可知，在$T_0$时刻存在着一个安全序列${P_1,P_3,P_4,P_2,P_0}$，故系统是安全的。 $P_1$请求资源$P_1$发出请求向量$Request_1(1,0,2)$，系统按银行家算法进行检查：①$Request_1(1,0,2) \le Need_1(1,2,2)$；②$Request_1(1,0,2) \le Available_1(3,3,2)$；③系统先假定可为$P_1$分配资源，并修改$Avaliable$，$Allocation_1$和$Need_1$向量，由此形成的资源变化情况如1图中的圆括号所示；④再利用安全性算法检查此时系统是否安全，如图所示 有所进行的安全性检查得知，可以找到一个安全序列${P_1,P_3,P_4,P_2,P_0}$。因此，系统是安全的，可以立即将$P_1$所申请的资源分配给它。 $P_4$请求资源$P_4$发出请求向量$Request_4(3,3,0)$，系统按银行家算法进行检查：①$Request_4(3,3,0) \le Need_4(4,3,1)$；②$Request_4(3,3,0) \ge Available(2,3,0)$，让$P_4$等待。 $P_0$请求资源$P_0$发出请求向量$Request_0(0,2,0)$，系统按银行家算法进行检查：①$Request_0(0,2,0) \le Need_0(7,4,3)$；②$Request_0(0,2,0) \le Available(2,3,0)$；③系统暂时先假定可为$P_0$分配资源，并修改有关数据，如图所示。 进入安全性检查可用资源$Available(2,1,0)$已不能满足任何进程的需要，故系统进入不安全状态，此时系统不分配资源。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统5--处理机调度]]></title>
    <url>%2Fposts%2F8b4e2673.html</url>
    <content type="text"><![CDATA[大家可以看下我使用幕布软件画的思维导图，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员https://mubu.com/inv/477598 在多道程序中，调度的实质是一种资源分配，处理机调度是对处理机资源进行分配。 5.1 处理机调度的层次和调度算法的目标在多道批处理系统中，一个作业从提交到获得处理机执行，直至作业运行完成，可能需要经历多次处理机调度。 5.1.1 处理机调度的层次 高级调度 高级调度又称为长程调度或作业调度，他的调度对象是作业。主要功能是根据某种算法，决定将外存上处于后备队列中的哪几个作业调入内存、为他们创建进程，分配必要的资源，并将他们放入就绪队列。 低级调度 低级调度又称为短程调度或作业调度，他的调度对象是进程。主要功能是根据某种算法，决定就绪队列中哪个进程应获得处理机，并由分派程序将处理机分配给被选中的进程。 中级调度 中级调度又称为内存调度。主要功能是将那些暂时不能运行的进程，调至外存等待，当他们具备运行条件且内存又稍有空闲时再调入内存。 5.1.2 处理机调度算法的目标5.1.2.1 处理机调度算法的共同目标 资源利用率 系统中的处理机和其它所有资源应尽可能保持忙碌状态，其中最重要的处理机利用率可用以下方式计算：CPU的利用率=\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间} 公平性 系统中的所有的进程都应该获得合理的CPU时间，不会发生进程饥饿现象。，对同类型的进程获得相同的服务；不同类型的进程，由于紧急程度不同或者重要性不同，应提供不同的服务。 平衡性 系统中可能具有多种类型的进程，有的是计算型作业，有的是I/O型作业。为了使CPU和资源尽可能的处于忙碌状态，调度算法应尽可能的保持系统资源使用的平衡性。 策略强制执行 对所定制的策略，只要需要，就必须准确的执行。 5.1.2.2 批处理系统的目标 平均周转时间段 周转时间，是指从作业被提交给系统，直到作业执行完毕所花费的时间。 对于每个用户来言，都希望自己的周转时间最短；但是对于系统来言，他要求的是平均周转时间最短，这不仅可以提高系统资源的利用率，而且还可使大多数用户都感到满意。 可把周转时间描述为：T=\frac{1}{n}[\sum_{i=1}^{n}{T_i}] 为了进一步反应调度的性能，更清楚的描述各进程在其周转时间中，等待和执行时间的具体分配情况，往往使用带权周转时间，即作业周转时间T与系统为他提供的时间Ts之比，即$ W=\frac{T}{T_s} $，平均带权周转时间可表示为：W = \frac{1}{n}\sum_{i=1}^{n}\frac{T_i}{T_s} 系统吞吐量高 处理机利用率高 5.1.2.3 分时系统的目标 相应事时间快 响应时间是指从用户通过键盘提交一个请求开始，直到屏幕上显示出处理结果为之的一段时间间隔，它包括三部分时间：一是请求信息从键盘输入开始，直至将其传送到处理机的时间；二是处理机对请求信息进行处理的时间；三是将所形成的的响应信息回送到终端显示器的时间。 均衡性 用户对响应时间的要求并非完全相同。通常，用户对于复杂的的作业，响应时间允许较长；对于简单的作业，响应时间则要短。 5.1.2.4 实时系统的目标 截止时间的保证 截止时间是指某任务必须开始执行的最迟时间，或者必须完成的最迟时间。 可预测性 5.2 作业与作业调度我们前面讲到过，在多道批处理系统中，作业由用户提交给系统操作员，再由系统操作员把作业输入给相应的输入设备，并保存在一个后备队列中，然后就由作业调度程序将其从外存调入内存再来进行处理。 5.2.1 作业5.2.1.1 作业和作业步 作业 作业一般包括程序还数据，还应配有一份作业说明书，系统根据该说明书来对程序的运行进行控制。 作业步 在作业运行期间，每个作业都必须经过若干个相对独立，又相互关联的顺序加工步骤才能得到结果。我们把其中的每一个加工步骤称为一个作业步。 5.2.1.2 作业控制块JCB为了管理和调度作业，在多道批处理系统中，为每个作业设置了一个作业控制块JCB，她是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。通常内容有作业标识、用户名称、用户账号、作业类型、作业状态、调度信息、资源需求、资源使用情况等。 5.2.1.3 作业运行的三个阶段和三种状态 收容阶段 操作员把用户提交的作业通过某种输入方式或SPOOLing系统输入到硬盘上，再为改作业建立PCB，并把它放入作业后备队列中。作业此时的状态为后备状态 运行阶段 当作业被作业调度选中后，变为它分配必要的资源和建立进程，并将它放入就绪队列。一个作业从第一次进入就绪状态开始，知道他运行结束前，都处于运行状态 完成阶段 当作业运行完成，或者发生异常情况提前结束时，作业便进入完成阶段，相应的作业状态为“完成状态”。 5.2.2 作业调度的主要任务作业调度的主要任务就是根据JCB中的内容，检查系统中的资源能否满足作业对资源的需求，以及按照一定的调度算法，从外存的后备队列中选取某些作业调入内存。并为它们创建进程、分配必要的资源。然后再将新创建的进程排在就绪队列上等待调度。因此，也把作业调度称为接纳调度。在每次执行作业调度时，都需要做出以下两个决定： 接纳多少个作业 在每一次作业调度时，应当从后备队列中选取多少作业调入内存，取决于多道程序度，即允许多少个作业同时在内存中运行。 接纳哪些作业 选择哪些作业取决于，作业调度采用哪种算法。 5.3 作业调度算法5.3.1 先来先服务（FCFS）算法算法对于这个算法，八个字——简单粗暴，没啥可讲。你来的早我就先服务你，其他人不管再牛逼你来晚了你就是弟弟，你得等我先把前面这位服务好了再来服务你。 5.3.2 短作业优先（SJF）调度算法对于这个算法，他也是基于先来先服务，只是多了个考虑范围，就是原则上还是先到先服务，但是当服务完一个之后并且还有很多个再等着被服务时，就从中找一个需要服务时间最短的先来服务，服务完他了，在从剩下的找一个最短的来服务。这个算法有几个缺点： 必须预知作业的运行时间 对长作业很不利 人机无法交互 没有考虑作业执行的紧迫感，对急需服务的作业不管 5.3.3 优先级调度算法（PSA）在优先级算法中，基于作业的紧迫程度，外部会赋予进程的优先级，然后优先级算法就根据算法的优先级，进行调度。算法实质上类似于短作业优先，你甚至可以把短作业优先级算法也看做是优先级算法，只不过他的优先级是作业长短，而优先级调度算法的优先级是进程的紧迫程度。 5.3.4 高响应比优先调度算法（HRRN）FCFS算法是考虑了作业的等待时间，却忽略的作业的运行时间；而SJF算法是只考虑了作业的运行时间，却忽略了作业的等待时间。高响应比算法是又考虑运行时间又考虑等待时间，因此既能照顾短作业，又不致使长作业的等待时间过长。 他为每个作业引入了一个动态优先级，即优先级是可以改变的，它随着等待时间的延长而增加，这使得长作业的优先级在等待期间不断地增加，等到足够的时间后，必然有机会获得处理机。这个变化规律可描述为： 优先级=\frac{等待时间+要求服务时间}{要求服务时间}由于等待时间与服务时间之和就是系统对该作业的响应时间，故该优先级又相当于响应比$R_p$。所以，优先级又可表示为：R_p=\frac{等待时间+要求服务时间}{要求服务时间}=\frac{响应时间}{要求服务时间} 从上面可以看出 如果作业的等待时间相同，则要求服务的时间越短，优先级越高 当要求服务时间相同时，作业的优先级决定于其等待时间 对于长作业的优先级，可以随等待时间的增加而提高 5.4 进程调度5.4.1 进程调度的任务、机制和方式5.4.1.1 进程调度的任务 保存处理机的现场信息 在进行调度时首先需要保存当前进程处理机的现场信息。 按某种算法选取进程 调度程序按某种算法从就绪队列中选取一个进程，将其状态改为运行状态，并准备把处理机分配给他。 把处理机分配给进程 由分派程序把处理器分配给该进程，此时需要将选中进程的进程控制块内有关处理机现场的信息装入处理器相应的各个寄存器中，把处理器的控制权交予该进程，让它从上次的断点处恢复运行。 5.4.1.2 进程调度机制为了实现进程调度，在进程调度机制中，应具有如下三个基本部分： 排队器为了提高进程调度的效率，应事先将系统中的所有就绪进程按照一定的策略排成一个或多个队列，以便调度程序能最快的找到它。 分派器分派器依据进程调度程序所选定的进程，将其从就绪队列中取出，然后进行从分派器到新选出进程间的上下文切换，将处理机分配给新选出的进程。 上下文切换器在对处理机进行切换时，会发生两对上下文的切换操作 对上下文切换时，OS将保存当前进程的上下文，即把当前进程的处理机寄存器的内容保存到该进程的进程控制块中的相应单元，再装入分派程序的上下文，以便分派程序运行 对上下文切换是移除分派程序的上下文，而把新选进程的CPU现场信息装入到处理机的各个相应寄存器中，以便新选进程运行 5.4.1.3 进程调度方式 非抢占方式 在这种方式下，一旦处理机分派给一个进程后，就一次性一直处理下去，直到该进程被处理完。 抢占方式 这种调度方式允许调度程序根据某种原则，去暂停某个正在执行的程序，将已分配给该进程的处理机重新分配给另一进程。 它遵循的主要原则有： 优先权原则，优先级高的新到进程抢占正在运行的优先级低的进程 短进程优先原则，需要运行时间更短的新到进程抢占正在运行的需要运行时间更长的进程 时间片原则，各进程按时间片轮转运行，当正在执行的进程的一个时间片用完后，便停止该进程的执行而重新进行调度 5.4.2 轮转调度算法在分时系统中，最常用也是最简单的就是基于时间片的轮转调度算法。该算法采取了非常公平的处理机分配方式，即让就绪队列上每个进程每次仅运行一个时间片。n个进程每个都运行$\frac{1}{n}$的处理机时间。 5.4.2.1 基本原理在RR算法中，系统根据FCFS策略，将所有的就绪进程排成一个就绪队列，并可设置每隔一定时间间隔即产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，令其执行。 5.4.2.2 进程切换时机 如果一个时间片尚未用完但是正在运行的进程已经完成，此时可以切换 在一个时间片用完，正在执行的进程还未执行完成，这时也可以切换 5.4.2.3 时间片大小的确定在RR算法中，时间片的大小对系统性能有很大的影响。如果选择很小的时间片，有利于短作业，因为他能在该时间片内完成，但时间片小，意味着会频繁调度，这无疑会增加系统开销。 如果时间片选择太长，这样的话RR可能会退化成FCFS，无法满足短作业和交互式用户的需求。 5.4.3 优先级调度算法在RR算法中，我们假设了所有进程的紧迫性是相同的，但是实际情况并非如此。我们为了满足实际情况，在进程调度算法中引入了优先级，而形成的优先级调度算法。 5.4.3.1 优先级调度算法的类型 非抢占式优先级调度算法 抢占式优先级调度算法 这块和前面调度算法方式一样，在此就不多说。 5.4.3.2 优先级类型5.4.3.2.1 静态优先级静态优先级是在创建进程时确定的，在进程的整个运行期间保持不变。优先级是利用某一范围内的一个整数来表示的。确定进程优先级大小的依据有如下三个： 进程类型，通常系统进程的优先级一般高于用户进程。 进程对资源的需求，对资源要求较少的进程应赋予较高的优先级。 用户要求，根据进程的紧迫程度及用户所付费用的多少确定优先级。 静态优先级法简单易行，系统开销小，但是不够精确，可能会出现优先级低的进程长期没有被调度的情况。 5.4.3.2.2 动态优先级动态优先级是指进程创建之初，先赋予一个优先级，然后根据进程的推进或等待时间的增加而改变，以便获得更好的调度性能。 5.4.4 多队列调度算法之前所述的各种调度算法，在应用于进程调度时，由于系统中仅设置一个进程的就绪队列，即低级调度的算法是单一的，固定的，无法满足系统中不同用户对进程调度策略的不同要求，在多处理机系统中，这种单一调度策略实现机制缺点更加明显。因此多级队列算法能够在一定程度上弥补这一缺点。 多级队列算法将进程就绪队列拆分成若干个，不同的就绪队列采用不同的调度算算法，所以可以很好的满足不同用户对进程调度策略的不同需求，同时也可以满足多处理机系统的需求。 5.4.5 多级反馈队列调度算法前面的算法都有一定的局限性，如果未指明进程长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而下述的多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，还可以很好地满足各种类型进程的需要，因而他是目前公认的一种较好的进程调度算法。 5.4.5.1 调度机制 设置多个就绪队列。在系统中设置多个就绪队列，并未每个队列赋予不同的优先级。第一个队列的优先级最高，第二次之，其余队列的优先级逐个降低。该算法为不同队列中的进程所赋予的执行时间片的大小也不同，在优先级越高的队列中时间片越小。 每个队列都采用FCFS算法。当新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则等待调度。当轮到该进程时，如他能在时间片内完成，便可撤离系统，否则，他在一个时间片结束还未完成时，转入第二队列末尾等待，依次类推。 按队列优先级调度，首先调度最高优先级队列中的诸进程运行，仅当第一队列空闲时才调度第二队列。 5.4.5.2 调度算法的性能在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互系统所需处理时间时，便能较好的满足各种类型用户的需要。 5.4.6 基于公平原则的调度算法5.4.6.1 保证调度算法保证调度算法是另一种类型的调度算法，它想用户所作出的保证并不是优先运行，而是明确的性能保证，该算法可以做到调度的公平性。一种比较容易的性能保证是处理机的公平性，如果在系统中有n个类型相同的进程同时运行，为了公平期间，每个进程都获得相同的处理机时间$\frac{1}{n}$。 在实施保证调度算法时，系统必须具备这样一些功能： 跟踪计算每个进程自创建以来已经执行的处理时间。 计算每个进程应获得的处理机时间，即自创建以来的时间除以n。 计算进程获得处理机时间的比率，即进程实际执行的处理时间和应获得的处理机时间之比。 比较各进程获得处理机时间的比率。如进程A的比率最低，为0.5，而进程B的比率为0.8，进程C的比率为1.2等。 调度程序应选择比率最小的进程将处理机分配给它，并让该进程一直运行，直到超过最接近它的进程比率为止。 5.4.6.2 公平分享调度算法分配给每个进程相同的处理机时间，显然，这对诸进程而言，是体现了一定程度的公平，但如果各个用户所拥有的进程数不同，就会发生对用户的不公平问题。 在该算法中，调度的公平性是体针对于用户而言。使所有的用户获得相同的处理机时间，或要求的时间比例。 5.5 实时调度5.5.1 实现实时调度的基本条件 提供必要的信息 就绪时间，是指某任务称为就绪状态的时间，在周期任务的情况下，她是实现预知的一串时间序列。 开始截止时间和完成截止时间，对于典型的实时应用，只需知道开始截止时间或者完成截止时间 处理时间，一个任务从开始执行，直至完成时所需的时间 资源要求，任务执行时所需要的一组资源 优先级，如果某任务的开始截止时间错过，势必引起故障，则应为该任务赋予“绝对”优先级；如果其开始截止时间的错过，对任务的继续运行无重大影响，则可为其赋予“相对优先级”，供调度程序参考 系统处理能力强 在实时系统中，若处理机的处理能力不够强，则有可能因处理机忙不过，而致使某些实时任务不能得到及时处理，从而导致发生难以预料的后果。 假定系统中有m个周期性的硬实时任务HRT，他们的处理时间可表示为$Ci$，周期时间表示为$P_i$，则在单处理机情况下，必须满足下面的限制条件系统才是可调度的：$$ \sum{i=1}^{m}\frac{Ci}{P_i}\le1 提高系统处理能力的途径有二：一是采用单处理机系统，但须增强其处理能力，以显著地减少对每一个任务的处理时间；二是采用多处理机系统。假定系统中的处理机数为N，则应将上述的限制条件改为： \sum{i=1}^{m}\frac{C_i}{P_i}\le N $$ 采用抢占式调度机制 在含有HRT任务的实时系统中，广泛采用抢占机制。这样便可满足HRT任务对截止时间的要求。但这种调度机制比较复杂。 对于一些小的实时系统，如果能够预知任务法开始截止时间，则对于实时任务的调度可以采用非抢占式调度。 具有快速切换机制 为保证硬实时任务能及时运行，在系统中还应具有快速切换机制，使之能进行任务的快速切换。该机制应具有如下两方面的能力： 对中断的快速响应能力。对紧迫的外部事件请求中断能及时响应，要求系统具有快速硬件中断机构，还应使禁止中断的时间间隔尽量短，以免耽误时机(其它紧迫任务)。 快速的任务分派能力。为了提高分派程序进行任务切换时的速度，应使系统中的每个运行功能单位适当的小，以减少任务切换的时间开销。 5.5.2 实时调度算法的分类5.5.2.1 非抢占式调度算法 非抢占式轮转调度算法 由一台计算机控制若干个相同的对象，为每个被控对象建立一个实时任务。并将他们排成一个轮转队列。调度程序每次选择队列中的第一个任务投入运行，当该任务完成后，便把它挂在轮转队列的末尾等待，调度程序再选择下一个队首任务运行。 非抢占式优先调度算法 如果在系统中还含有少数具有一定要求的实时任务，则可采用非抢占式优先调度算法，系统为这些任务赋予了较高的优先级。当这些实时任务到达时，把它们安排在就绪队列的队首，等待当前任务自我终止或运行完成后，便可去调度执行队首的高优先级进程。 5.5.2.2 抢占式调度算法 基于时钟中断的抢占式优先级调度算法。 在某实时任务到达后，如果他的优先级高于当前任务的优先级，这是并不立即抢占当前任务的处理机，而是等到时钟中断发生时，调度程序才剥夺大年任务的执行，把处理机分配给新到的高优先级的任务。 立即抢占的优先级调度算法。 在这种调度策略中，要求操作系统具有快速响应外部事件中断的能力，一旦出现外部中断，只要当前任务未处于临界区，便能立即剥夺当前任务的执行，把处理机分配给请求中断的紧迫任务。 5.5.3 最早截止时间优先该算法是根据任务截止时间确定任务的优先级，任务的截止时间越早，其优先级越高，具有最早截止时间的任务排在队首。 5.5.3.1 非抢占式调度方式用于非周期实时任务 5.5.3.2 抢占式调度方式用于非周期实时任务 5.5.4 最低松弛度优先LLF算法该算法在确定任务的优先级时，根据的是任务的紧急(或松弛)程度。任务紧急程度愈高，赋予该任务的优先级就愈高，以使之优先执行。 该方式主要用可抢占式调度。 假如在一个实时系统中有两个周期性实时任务A和B，任务A要求每20 ms执行一次，执行时间为10 ms，任务B要求每50 ms执行一次，执行时间为25 ms。由此可知，任务A和B每次必须完成的时间分别为：A1、A2、A3、…和B1、B2、B3、…，如下图 利用ELLF算法进行调度的情况：]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android网络请求1--HttpClient与HttpURLConnection]]></title>
    <url>%2Fposts%2Feb898689.html</url>
    <content type="text"><![CDATA[在早期的时候，Android上还没有像Volley、OkHttp、Retrofit这些优秀的开源库，如果想要使用网络请求的话，就只能自己封装HttpClient和HttpURLConnection。现在我们就来看下Apache的这两个类。 1. HttpClient2.1 导入HttpClient由于从Android 6.0 开始，谷歌就将HttpClient从Android中删除了，所以若现在想使用他，还得导入依赖：在项目的build.gradle的Android代码块下加入依赖，示例：1234android &#123; useLibrary 'org.apache.http.legacy' ...&#125; 2.2 HttpClient的Get首先通过DefaultHttpClient来实例化一个HttpClient，并配置好参数：123456789101112131415 //创建HttpClientprivate HttpClient createHttpClient() &#123; HttpParams mDefaultHttpParams = new BasicHttpParams(); //设置连接超时 HttpConnectionParams.setConnectionTimeout(mDefaultHttpParams, 15000); //设置请求超时 HttpConnectionParams.setSoTimeout(mDefaultHttpParams, 15000); HttpConnectionParams.setTcpNoDelay(mDefaultHttpParams, true); HttpProtocolParams.setVersion(mDefaultHttpParams, HttpVersion.HTTP_1_1); HttpProtocolParams.setContentCharset(mDefaultHttpParams, HTTP.UTF_8); //持续握手 HttpProtocolParams.setUseExpectContinue(mDefaultHttpParams, true); HttpClient mHttpClient = new DefaultHttpClient(mDefaultHttpParams); return mHttpClient;&#125; 接着创建HttpGet和HttpClient，请求网络并得到HttpResponse，并对HttpResponse进行处理：123456789101112131415161718private void useHttpClientGet(String url) &#123; HttpGet mHttpGet = new HttpGet(url); mHttpGet.addHeader("Connection", "Keep-Alive"); try &#123; HttpClient mHttpClient = createHttpClient(); HttpResponse mHttpResponse = mHttpClient.execute(mHttpGet); HttpEntity mHttpEntity = mHttpResponse.getEntity(); int code = mHttpResponse.getStatusLine().getStatusCode(); if (null != mHttpEntity) &#123; InputStream mInputStream = mHttpEntity.getContent(); String respose = converStreamToString(mInputStream); Log.i("wangshu", "请求状态码:" + code + "\n请求结果:\n" + respose); mInputStream.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; converStreamToString()方法将请求结果转换成String类型：12345678910private String converStreamToString(InputStream is) throws IOException &#123; BufferedReader reader = new BufferedReader(new InputStreamReader(is)); StringBuffer sb = new StringBuffer(); String line = null; while ((line = reader.readLine()) != null) &#123; sb.append(line + "\n"); &#125; String respose = sb.toString(); return respose;&#125; 最后开启线程访问:123456new Thread(new Runnable() &#123; @Override public void run() &#123; useHttpClientGet("http://www.baidu.com"); &#125;&#125;).start(); 1.3 HttpClient的POST和GET差不多，只需要修改传递的参数：1234567891011121314151617181920212223private void useHttpClientPost(String url) &#123; HttpPost mHttpPost = new HttpPost(url); mHttpPost.addHeader("Connection", "Keep-Alive"); try &#123; HttpClient mHttpClient = createHttpClient(); List&lt;NameValuePair&gt; postParams = new ArrayList&lt;&gt;(); //要传递的参数 postParams.add(new BasicNameValuePair("username", "moon")); postParams.add(new BasicNameValuePair("password", "123")); mHttpPost.setEntity(new UrlEncodedFormEntity(postParams)); HttpResponse mHttpResponse = mHttpClient.execute(mHttpPost); HttpEntity mHttpEntity = mHttpResponse.getEntity(); int code = mHttpResponse.getStatusLine().getStatusCode(); if (null != mHttpEntity) &#123; InputStream mInputStream = mHttpEntity.getContent(); String respose = converStreamToString(mInputStream); Log.i("wangshu", "请求状态码:" + code + "\n请求结果:\n" + respose); mInputStream.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 2. HttpURLConnectionHttpURLConnection较HttpClient来说更轻量，而且他API也比HttpClient简单。特别是Android 6.0将HttpClient移除之后，现在只能使用HttpURLConnection。 2.1 HttpURLConnection的POST请求首先我们创建一个UrlConnManager类，然后里面提供getHttpURLConnection()方法用于配置默认的参数并返回HttpURLConnection：12345678910111213141516171819202122public static HttpURLConnection getHttpURLConnection(String url)&#123; HttpURLConnection mHttpURLConnection=null; try &#123; URL mUrl=new URL(url); mHttpURLConnection=(HttpURLConnection)mUrl.openConnection(); //设置链接超时时间 mHttpURLConnection.setConnectTimeout(15000); //设置读取超时时间 mHttpURLConnection.setReadTimeout(15000); //设置请求参数 mHttpURLConnection.setRequestMethod("POST"); //添加Header mHttpURLConnection.setRequestProperty("Connection","Keep-Alive"); //接收输入流 mHttpURLConnection.setDoInput(true); //传递参数时需要开启 mHttpURLConnection.setDoOutput(true); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return mHttpURLConnection ;&#125; 因为我们要发送POST请求，所以在UrlConnManager类中再写一个postParams()方法用来组织一下请求参数并将请求参数写入到输出流中：123456789101112131415public static void postParams(OutputStream output,List&lt;NameValuePair&gt;paramsList) throws IOException&#123; StringBuilder mStringBuilder=new StringBuilder(); for (NameValuePair pair:paramsList)&#123; if(!TextUtils.isEmpty(mStringBuilder))&#123; mStringBuilder.append("&amp;"); &#125; mStringBuilder.append(URLEncoder.encode(pair.getName(),"UTF-8")); mStringBuilder.append("="); mStringBuilder.append(URLEncoder.encode(pair.getValue(),"UTF-8")); &#125; BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(output,"UTF-8")); writer.write(mStringBuilder.toString()); writer.flush(); writer.close();&#125; 接下来我们添加请求参数，调用postParams()方法将请求的参数组织好传给HttpURLConnection的输出流，请求连接并处理返回的结果：12345678910111213141516171819private void useHttpUrlConnectionPost(String url) &#123; InputStream mInputStream = null; HttpURLConnection mHttpURLConnection = UrlConnManager.getHttpURLConnection(url); try &#123; List&lt;NameValuePair&gt; postParams = new ArrayList&lt;&gt;(); //要传递的参数 postParams.add(new BasicNameValuePair("username", "moon")); postParams.add(new BasicNameValuePair("password", "123")); UrlConnManager.postParams(mHttpURLConnection.getOutputStream(), postParams); mHttpURLConnection.connect(); mInputStream = mHttpURLConnection.getInputStream(); int code = mHttpURLConnection.getResponseCode(); String respose = converStreamToString(mInputStream); Log.i("wangshu", "请求状态码:" + code + "\n请求结果:\n" + respose); mInputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 最后开启线程请求网络：12345678private void useHttpUrlConnectionGetThread() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; useHttpUrlConnectionPost("http://www.baidu.com"); &#125; &#125;).start();&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码</tag>
        <tag>kotlin</tag>
        <tag>Volley</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ijkPlayer编译-Android]]></title>
    <url>%2Fposts%2Fd61d5542.html</url>
    <content type="text"><![CDATA[1. 简介ijkplayer是哔哩哔哩的一个开源视频播放框架，支持Android、iOS。底层是ffplay。 Github地址：bilibili/ijkplayer 2. 编译方法由于通过Gradle编译起来很慢而且一旦失败又得重头来，所以这块就使用AndroidNDK的方式来编译。 2.1 编译之前首先你得配置好等会编译需要的东西。这块我们都会使用Homebrew来安装git和yasm。Homebrew类似于Ubuntu的dpkg、RedHat和centOS的yum，他是macOS上的一个软件包管理器。但是后来出了Linux版。由于ijkplayer官方说用的它，那咱们就用它吧。 Ubuntu1. 先把目前已有的包更新12345678// 从镜像站下载软件列表，并检查有没有需要更新的包sudo apt update// 更新需要更新的包sudo apt upgrade// 自动卸载掉当初为了安装其他软件或其他原因而安装但是目前已经没用的包sudo apt autoremove 2. 安装Homebrew1234567891. 首先确定是否安装ruby apt install ruby' 2. 然后通过ruby安装Homebrew ruby -c "$(curl -fsSL https://raw.githubusercontent.com/Linuxbrew/install/master/install.sh)" 3. 再通过Homebrew安装git和yasm brew install git brew install yasm 3. 配置Android SDK和NDK Android SDK 你可以打开你的AndroidStudio，进入Preferences -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; Android SDK。这块就会显示你SDK安装目录。 然后在终端中输入vim ~/.bash_profile。然后输入以下内容： 123export ANDROID_SDK_HOME=AndroidSDK的目录/android-sdk-linuxexport PATH=$PATH:$&#123;ANDROID_SDK_HOME&#125;/toolsexport PATH=$PATH:$&#123;ANDROID_SDK_HOME&#125;/platform-tools 保存，然后再在终端输入source ~/.bash_profile，就可以了。 Android NDK 首先你得到官网下载NDK：NDK 归档。而且你只能下载r10e版本的，下载其它版本编译会报错。 下载下来解压后，同样和上面一样得配置环境变量： 12export ANDROID_NDK_HOME=NDK目录export PATH=$PATH:$&#123;ANDROID_SDK_HOME&#125; 保存，然后再在终端输入source ~/.bash_profile，就可以了。 macOS安装Homebrew，由于macOS自带ruby，所以我们直接可以开始安装Homebrew。123ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"brew install gitbrew install yasm 然后就是配置你的Android SDK和Android NDK：和上面Ubuntu下一样。 2.2 编译Android12345678910111213git clone https://github.com/Bilibili/ijkplayer.git ijkplayer-androidcd ijkplayer-androidgit checkout -B latest k0.8.8./init-android.shcd android/contrib./compile-ffmpeg.sh clean// 这步特慢，耗时很长./compile-ffmpeg.sh allcd .../compile-ijk.sh all 上面这些执行完就可以了。然后你就能在你的/ijkplayer-android/android/ijkplayer路径下就能看到编译后的项目了，其中每个module的/src/mian/libs里面就是so文件。 3. 最后你可以直接通过AndroidStudio打开/ijkplayer-android/android/ijkplayer，然后在里面的/ijkplayer-example下谢你自己的代码就可以了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ijkplayer</tag>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android网络请求4--解析Retrofit源码]]></title>
    <url>%2Fposts%2Fa2a8de56.html</url>
    <content type="text"><![CDATA[1. Retrofit简介 Retrofit - github Retrofit - Doc Retrofit是Square公司的又一力作，针对Android网络请求的框架，遵循Restful设计风格，底层基于OkHttp。 他对比其他框架 性能最好 封装程度高，拓展性差 简介易用，代码简单 解耦彻底 可以非常方便的与RxJava连用 2. Retrofit用法（异步）2.1 添加依赖可以在Retrofit Github库页面里面找到最新版本号，我写这篇博客时最新版导入方式 在你项目的app的build.gradle里面添加implementation &#39;com.squareup.retrofit2:retrofit:2.6.1&#39; 同时，如果你需要配套的数据转换器还需要导入以下的依赖 Gson: com.squareup.retrofit2:converter-gson Jackson: com.squareup.retrofit2:converter-jackson Moshi: com.squareup.retrofit2:converter-moshi Protobuf: com.squareup.retrofit2:converter-protobuf Wire: com.squareup.retrofit2:converter-wire Simple XML: com.squareup.retrofit2:converter-simplexml Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars 2.2 添加网络权限在你APP的AndroidManifest.xml里添加&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 2.3 创建 接收服务器返回数据 的类Reception.java1234puublic class Reception &#123; // 根据返回数据的格式和数据解析方式定义 ...&#125; 2.4 创建 用于描述网络请求 的接口GetRequest_Interface.interface123456789public interface GetRequest_Interface &#123; @GET("openapi.do?keyfrom=Yanzhikai&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car") Call&lt;Translation&gt; getCall(); // @GET注解的作用:采用Get方法发送网络请求 // getCall() = 接收网络请求数据的方法 // 其中返回类型为Call&lt;*&gt;，*是接收数据的类（即上面定义的Translation类） // 如果想直接获得Responsebody中的内容，可以定义网络请求返回值为Call&lt;ResponseBody&gt;&#125; 2.5 创建Retrofit实例12345Retrofit retrofit = new Retrofit.Builder() .baseUrl("http://fanyi.youdao.com/") // 设置网络请求的Url地址 .addConverterFactory(GsonConverterFactory.create()) // 设置数据解析器 .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) // 支持RxJava平台 .build(); 2.6 创建网络请求接口实例12345// 创建 网络请求接口 的实例GetRequest_Interface request = retrofit.create(GetRequest_Interface.class);//对 发送请求 进行封装Call&lt;Reception&gt; call = request.getCall(); 2.7 发送网络请求123456789101112131415//发送网络请求(异步)call.enqueue(new Callback&lt;Translation&gt;() &#123; //请求成功时回调 @Override public void onResponse(Call&lt;Translation&gt; call, Response&lt;Translation&gt; response) &#123; //请求处理,输出结果 response.body().show(); &#125; //请求失败时候的回调 @Override public void onFailure(Call&lt;Translation&gt; call, Throwable throwable) &#123; System.out.println("连接失败"); &#125;&#125;); 2.8 处理返回数据123456789101112131415//发送网络请求(异步)call.enqueue(new Callback&lt;Translation&gt;() &#123; //请求成功时回调 @Override public void onResponse(Call&lt;Translation&gt; call, Response&lt;Translation&gt; response) &#123; // 对返回数据进行处理 response.body().show(); &#125; //请求失败时候的回调 @Override public void onFailure(Call&lt;Translation&gt; call, Throwable throwable) &#123; System.out.println("连接失败"); &#125;&#125;); 由于本文的核心不是讲用法，所以关于用法这块，我并没有多讲，大家若想多了解，可以看此博客：这是一份很详细的 Retrofit 2.0 使用教程（含实例讲解） 3. Retrofit源码3.1 Retrofit对象构造源码应对一个框架的源码首先从使用它的地方开始，我们先来看Retrofit的创建代码：1234Retrofit retrofit = new Retrofit.Builder() .baseUrl("http://fanyi.youdao.com/") .addConverterFactory(GsonConverterFactory.create()) .build(); 我们可以把它分为5个部分来分析源码： 我们首先来看第一步 3.1.1 步骤1：Retrofit类12345678910111213141516171819202122232425262728public final class Retrofit &#123; private final Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;(); // 网络请求工厂 final okhttp3.Call.Factory callFactory; // 请求的Url地址 final HttpUrl baseUrl; // 数据转换器工厂的集合 final List&lt;Converter.Factory&gt; converterFactories; // 网络请求适配器工厂的集合 final List&lt;CallAdapter.Factory&gt; callAdapterFactories; // 回调 final @Nullable Executor callbackExecutor; // 是否提前对业务接口中的注解进行验证转换的标志位 final boolean validateEagerly; Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl, List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; callAdapterFactories, @Nullable Executor callbackExecutor, boolean validateEagerly) &#123; this.callFactory = callFactory; this.baseUrl = baseUrl; this.converterFactories = converterFactories; // Copy+unmodifiable at call site. this.callAdapterFactories = callAdapterFactories; // Copy+unmodifiable at call site. this.callbackExecutor = callbackExecutor; this.validateEagerly = validateEagerly; &#125; ...// 省略后面的代码&#125; 可以看到，Retrofit的构造方法需要一次性把需要的数据全部准备好。而且这块有特别多的工厂，使用了工厂模式。这个我们之后再讲，接下来看步骤2： 3.1.2 步骤2：Builder()方法我们先来看下Builder()方法的源码：123public Builder() &#123; this(Platform.get());&#125; 这里调用了Rlatform.get()方法：123static Platform get() &#123; return PLATFORM;&#125; PLATFORM的定义就在上面：1private static final Platform PLATFORM = findPlatform(); 我们再来看下findPlatform()方法：12345678910private static Platform findPlatform() &#123; try &#123; Class.forName("android.os.Build"); if (Build.VERSION.SDK_INT != 0) &#123; return new Android(); &#125; &#125; catch (ClassNotFoundException ignored) &#123; &#125; return new Platform(true);&#125; 这块创建了一个Android对象，接着返回了传入true创建的Platform对象。我们再来看下Android类：12345678910111213141516171819202122static final class Android extends Platform &#123; Android() &#123; super(Build.VERSION.SDK_INT &gt;= 24); &#125; @Override public Executor defaultCallbackExecutor() &#123; // 返回一个默认的回调方法执行器 // 该执行器作用：切换线程（子-&gt;&gt;主线程），并在主线程（UI线程）中执行回调方法 return new MainThreadExecutor(); &#125; static class MainThreadExecutor implements Executor &#123; // 获取与Android 主线程绑定的Handler private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) &#123; // 该Handler是上面获取的与Android 主线程绑定的Handler // 在UI线程进行对网络请求返回数据处理等操作。 handler.post(r); &#125; &#125;&#125; 3.1.3 步骤3：baseUrl()方法1234public Builder baseUrl(String baseUrl) &#123; Objects.requireNonNull(baseUrl, "baseUrl == null"); return baseUrl(HttpUrl.get(baseUrl));&#125; 最后还是调用了一个baseUrl()方法，我们来看看这个baseUrl()方法：1234567891011public Builder baseUrl(HttpUrl baseUrl) &#123; Objects.requireNonNull(baseUrl, "baseUrl == null"); // 把URL参数分割成几个路径碎片 List&lt;String&gt; pathSegments = baseUrl.pathSegments(); // 检测最后一个碎片来检查URL参数是不是以"/"结尾,不是就抛出异常 if (!"".equals(pathSegments.get(pathSegments.size() - 1))) &#123; throw new IllegalArgumentException("baseUrl must end in /: " + baseUrl); &#125; this.baseUrl = baseUrl; return this;&#125; 步骤3用于设置网络请求的Url 3.1.4 步骤4：addConverterFactory()方法我们先来看看GsonConverterFactory.create()方法：123public static GsonConverterFactory create() &#123; return create(new Gson());&#125; 又调用了另一个create()方法：1234public static GsonConverterFactory create(Gson gson) &#123; if (gson == null) throw new NullPointerException("gson == null"); return new GsonConverterFactory(gson);&#125; 如果传入的gson为空就报异常，不为空就调用GsonConverterFactory的构造方法：123private GsonConverterFactory(Gson gson) &#123; this.gson = gson;&#125; 所以这个方法本质就是返回了一个gson对象给了addConverterFactory()方法，那我们再来看看这个方法：12345/** 为对象的序列化和反序列化添加转换器工厂。 */public Builder addConverterFactory(Converter.Factory factory) &#123; converterFactories.add(Objects.requireNonNull(factory, "factory == null")); return this;&#125; 步骤4创建了一个含有Gson实例的GsonConverterFactory对象，并放入了ConverterFactory。 3.1.5 步骤5：build()方法1234567891011121314151617181920212223242526272829303132public Retrofit build() &#123; if (baseUrl == null) &#123; throw new IllegalStateException("Base URL required."); &#125; // 配置网络请求执行器 okhttp3.Call.Factory callFactory = this.callFactory; // 如果没有指定callFactory，则创建OkHttpClient if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; // 配置回调执行器 Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor(); &#125; // 配置网络请求适配器工厂 List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories); callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor)); // 配置数据转换器工厂 List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;( 1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize()); // 首先添加内置转换器工厂。这可以防止重写它的行为，但也可以确保在使用使用使用所有类型的转换器时正确的行为。 converterFactories.add(new BuiltInConverters()); converterFactories.addAll(this.converterFactories); converterFactories.addAll(platform.defaultConverterFactories()); return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories), unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);&#125; 按前面配置的变量，将Retrofit所有的变量都配置好，最后完成创建Retrofit实例。 到这Retrofit的创建部分就完了。Retrofit通过建造者模式创建了一个Retrofit实例： 请求工厂callFactory：默认是OkHttpClient 数据转换器工厂converterFactories 网络请求适配器工厂callAdapterFactories：默认是ExecutorCallAdapterFactory 回调执行器callbackExecutor 3.2 创建网络请求接口的实例大致创建方法如下：12345678910111213141516171819202122&lt;!-- Reception.java --&gt;puublic class Reception &#123; // 根据返回数据的格式和数据解析方式定义 ...&#125;&lt;!-- GetRequest_Interface.interface --&gt;public interface GetRequest_Interface &#123; @GET("openapi.do?keyfrom=Yanzhikai&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car") Call&lt;Translation&gt; getCall(); // @GET注解的作用:采用Get方法发送网络请求 // getCall() = 接收网络请求数据的方法 // 其中返回类型为Call&lt;*&gt;，*是接收数据的类（即上面定义的Translation类） // 如果想直接获得Responsebody中的内容，可以定义网络请求返回值为Call&lt;ResponseBody&gt;&#125;&lt;!-- MainActivity.java --&gt;// 创建 网络请求接口 的实例GetRequest_Interface request = retrofit.create(GetRequest_Interface.class);//对 发送请求 进行封装Call&lt;Reception&gt; call = request.getCall(); 我们先看看retrofit.create()干了啥：1234567891011121314151617181920public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; validateServiceInterface(service); return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); private final Object[] emptyArgs = new Object[0]; @Override public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; // 如果该方法是来自对象的方法，则推迟到正常调用。 if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; return loadServiceMethod(method).invoke(args != null ? args : emptyArgs); &#125; &#125;);&#125; 首先调用了validateServiceInterface()这个方法，我们来看看这个方法：1234567891011121314151617181920212223242526272829303132333435private void validateServiceInterface(Class&lt;?&gt; service) &#123; // 如果不是接口就抛异常 if (!service.isInterface()) &#123; throw new IllegalArgumentException("API declarations must be interfaces."); &#125; // 构造了一个容量下限为1的空双向队列来存储数据 Deque&lt;Class&lt;?&gt;&gt; check = new ArrayDeque&lt;&gt;(1); // 添加到队列 check.add(service); while (!check.isEmpty()) &#123; // 将队列的正向第一个元素移除 Class&lt;?&gt; candidate = check.removeFirst(); // getTypeParameters()的作用是得到泛型类型，如果泛型的数量不为0的话进入 if (candidate.getTypeParameters().length != 0) &#123; StringBuilder message = new StringBuilder("Type parameters are unsupported on ") .append(candidate.getName()); if (candidate != service) &#123; message.append(" which is an interface of ") .append(service.getName()); &#125; throw new IllegalArgumentException(message.toString()); &#125; Collections.addAll(check, candidate.getInterfaces()); &#125; if (validateEagerly) &#123; Platform platform = Platform.get(); for (Method method : service.getDeclaredMethods()) &#123; if (!platform.isDefaultMethod(method) &amp;&amp; !Modifier.isStatic(method.getModifiers())) &#123; loadServiceMethod(method); &#125; &#125; &#125;&#125; 获取到Platform（平台），然后再遍历接口中的方法，调用loadServiceMethod()方法：12345678910111213ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123; ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method); if (result != null) return result; synchronized (serviceMethodCache) &#123; result = serviceMethodCache.get(method); if (result == null) &#123; result = ServiceMethod.parseAnnotations(this, method); serviceMethodCache.put(method, result); &#125; &#125; return result;&#125; 这个方法主要就是通过serviceMethodCache来存储转换为ServiceMethod类型的Method。 那我们在回过去看InvocationHandler的invoke()方法。12345678910111213141516new InvocationHandler() &#123; private final Platform platform = Platform.get(); private final Object[] emptyArgs = new Object[0]; @Override public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; // 如果该方法是来自对象的方法，则推迟到正常调用。 if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; return loadServiceMethod(method).invoke(args != null ? args : emptyArgs); &#125;&#125;); 两个if先不管，先看最后的return，可以看到他调用了一个loadServiceMethod()方法，而这个方法在前面就说过，主要就返回了一个ServiceMethod。那我们接着来看invoke()方法：按住command+鼠标左键进入后，显示的是：123456789101112131415161718abstract class ServiceMethod&lt;T&gt; &#123; static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) &#123; RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method); Type returnType = method.getGenericReturnType(); if (Utils.hasUnresolvableType(returnType)) &#123; throw methodError(method, "Method return type must not include a type variable or wildcard: %s", returnType); &#125; if (returnType == void.class) &#123; throw methodError(method, "Service methods cannot return void."); &#125; return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory); &#125; abstract @Nullable T invoke(Object[] args);&#125; 这个invoke()根本就是个抽象方法啊，然后我又回去找看看有没有说是哪个继承自ServiceMethod的类实现了这个方法，结果也没找到，最后想到了AndroidStudio可以command+左键找实现了这个类的地方啊。于是我就点了下这个类，结果成功找到了HttpServiceMethod这个类，他是ServiceMethod的子类中唯一一个实现了invoke()方法的：1234@Override final @Nullable ReturnT invoke(Object[] args) &#123; Call&lt;ResponseT&gt; call = new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter); return adapt(call, args);&#125; 可以看到这块他创建了一个OkHttpCall对象，此处不做详解，可以看我关于OkHttp的一篇博客：Android网络请求3—解析OkHttp源码。然后调用了adapt方法，我们来看看这个方法:1protected abstract @Nullable ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args); 这又是一个抽象方法。只不过好的是，这个方法下面我们就找到了他的实现：1234567891011121314static final class CallAdapted&lt;ResponseT, ReturnT&gt; extends HttpServiceMethod&lt;ResponseT, ReturnT&gt; &#123; private final CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter; CallAdapted(RequestFactory requestFactory, okhttp3.Call.Factory callFactory, Converter&lt;ResponseBody, ResponseT&gt; responseConverter, CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter) &#123; super(requestFactory, callFactory, responseConverter); this.callAdapter = callAdapter; &#125; @Override protected ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args) &#123; return callAdapter.adapt(call); &#125;&#125; 可是他又返回给了一个CallAdapter接口的实现类的adapt()方法。。。。艹 所以，这块我就不懂了，我不知道他到底咋实现这个的这个方法的，我看了《Android进阶之光》和其它很多博客，他们都是老版本的Retrofit，create()方法不同，而且调用的adapt()方法也不同。。。 3.3 网络请求网络请求这块Retrofit实际上就是用OkHttp实现的，所以这块我就不在这多说了，大家要了解的可以看我之前写的博客：Android网络请求3—解析OkHttp源码。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码</tag>
        <tag>kotlin</tag>
        <tag>OkHttp</tag>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统4--进程的通信和线程]]></title>
    <url>%2Fposts%2F30b7e738.html</url>
    <content type="text"><![CDATA[大家可以看下我使用幕布软件画的思维导图，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员https://mubu.com/inv/477598 4.1 进程通信进程通信就是指进程之间的信息交换。 早期的时候，由于技术不发达，以及由于进程的同步和互斥需要在进程间交换一定的数据，所以不少人也将他们称为进程通信，但是实质上他们只能被成为低级的进程通信。以信号量为例，他 效率低 生产者或消费者每次只能向缓冲区投放一个产品或者取出一个产品。 通信对用户不透明 而关于进程间通信所需的数据结构的设置和数据的传送、进程的同步和互斥，都需要程序员去完成，显然是非常不方便的。 所以高级进程通信必须满足如下特点： 使用方便。 OS隐藏了实现进程通信的具体细节，向用户提供了一组用于实现高级通信的命令，用户可以方便地直接利用它实现进程之间的通信。 高效的传送数据。 用户可以直接利用高级通信命令高效的传送大量的数据。 进程通信主要有共享存储器系统、管道通信系统、消息传递系统以及客户机-服务器系统。 4.1.1 共享存储器系统共享存储器系统又分为了两种： 基于共享数据结构的通信方式 在这种通信方式下，要求进程公用某些数据结构，借以实现诸进程间的信息交换。这种方式仅适用于传递相对少量的数据，通信效率低下，属于低级通信。 基于共享存储区的通信方式 为了传输大量数据，就在内存中划出了一块共享存储区域，诸进程可通过对该共享区的读或写交换数据，实现通信，数据的形式和位置甚至访问控制都是由进程负责，而不是OS。 4.1.2 管道通信系统所谓管道，是指用于连接一个读进程和一个写进程以实现他们之间通信的一块共享存储文件，又叫pipe文件。向管道提供输入的发送进程以字符流形式将达量的数据送入管道，而接收管道输出的接收进程则从管道中接收数据。这种方式是UNIX系统IPC最古老的形式。 为了协调双方的通信，他必须提供一下三个功能的协调能力： 互斥 同步 确定对方是否存在 4.1.3 消息传递系统在这种方式下，集成不再借助任何共享存储区或数据结构，而是以格式化的消息(Message)为单位，将通信的数据封装在消息中，并利用操作系统提供的一组通信命令，在进程间进行消息传递，完成进程间的数据交换。 该方式隐藏了通信实现细节，使通信过程对用户透明化，降低了通信程序设计的复杂性和错误率，成为当前应用最为广泛的一类进程间的通信机制. 4.1.4 客户机-服务器系统前面的几种通信系统，虽然也可以用于实现不同计算机间进程的双向通信，但是客户机-服务器系统的通信机制，在网络环境的各种应用领域已成为当前主流的通信实现机制，主要分为三类：套接字、远程过程调用和远程方法调用。在这就不多赘述了。 4.2 线程4.2.1 为什么要引入线程我们都知道，进程有两个基本属性：①进程是一个可拥有资源的独立单位，一个进程要能独立运行，他必须拥有一定的数据结构。②进程同时又是一个可独立调度和分派的基本单位。 为了程序能并发执行，系统必须能进行创建进程、撤销进程和切换进程操作。但是由于进程是资源的拥有者，所以在上述这些操作中，系统必须为之付出较大的时空开销。这就限制了系统中所设置进程的数目，而且进程切换也不宜过于频繁，从而限制了并发程度的进一步提高。 4.2.2 线程的概念在上述原因下，引入了线程的概念。学者们将进程的两个属性分开，让作为调度和分派的基本单位不拥有资源，让拥有资源的基本单倍不被频繁的调度。这样的话，就形成了线程的概念。 下面我们从6个方面来比较下进和线程： 调度的基本单位 传统OS中，进程是作为独立调度的基本单位，每次调度时，都需要上下文切换，开销大。在引入了线程的OS中，线程是作为独立调度的基本单位，线程切换时只需要保存和设置少量的寄存器内容，切换代价远小于进程。 并发性 在引入线程的OS中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可以并发执行，甚至还允许在一个进程中的所有线程都能并发执行。 拥有资源 进程可以拥有资源，而且还是系统中拥有资源的一个基本单位。但是线程本身并不拥有资源，而是仅有一点必不可少的、能保证独立运行的资源。 独立性 同一进程中的线程之间的独立性比不同进程间的独立性低得多。 系统开销 进程切换需要大量的系统开销，而线程间则需要的很少 支持多处理机系统 在多处理机系统中，对于传统进程，不管有多少处理机，该进程只能运行在一个处理机上。但是对于多线程进程，可以将一个进程中的多个线程分配到多个处理机上。 4.2.3 线程的状态和线程控制块与进程一样，线程也拥有三个状态和线程控制块。 4.2.3.1 线程运行的三个状态线程的三个状态和进程类似。 运行状态，表示线程已获得处理机而正在运行。 就绪状态，表示线程已具备各种执行条件，只须再获得CPU便可立即执行。 阻塞状态，只线程在执行中因某事件受阻而处于暂停状态。 4.2.3.2 线程控制块TCB线程控制块用来纪录用于控制和管理线程的信息。线程控制块中通常由这几项： 线程标识符，为每个线程设置唯一地标识符。 一组寄存器，包括程序计数器PC、状态寄存器和通用寄存器的内容。 线程运行状态，用于描述线程正处于何种运行状态。 优先级，描述线程执行的优先程度。 线程专有存储区，用于线程切换时存放现场保护信息，和与该线程相关的统计信息等。 信号屏蔽，即对某些信号加以屏蔽。 堆栈指针。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uCrop框架用法和源码解析]]></title>
    <url>%2Fposts%2F4e4b8b52.html</url>
    <content type="text"><![CDATA[本人能力不足，在看到源码最后一部分的时候大量抄袭可能是最详细的UCrop源码解析 1. uCrop简介uCrop是目前较火的图片裁剪框架，开发者宣称他会比目前市面上所有的图片裁剪方案都要更流畅。外加他封装程度较高，可自定义，而且颜值很高（似乎这个才是重点），现在越来越多APP选择使用它。github 2. 使用方法得益于uCrop优秀的封装，uCrop的使用方法特简单。 2.1 导入依赖 先在项目的build.gradle中添加 123456allprojects &#123; repositories &#123; jcenter() maven &#123; url "https://jitpack.io" &#125; &#125;&#125; 并在module的build.gradle中添加 implementation &#39;com.github.yalantis:ucrop:2.2.3&#39; - 轻量级框架 implementation &#39;com.github.yalantis:ucrop:2.2.3-native&#39; - 获得框架全部强大的功能以及图片的高质量(最终可能会导致apk的大小增加1.5MB以上) 由于框架的本质是调用到另一个Activity去处理图片，所以需要在AndroidManifest.xml中将UCropActivity添加进去 1234&lt;activity android:name="com.yalantis.ucrop.UCropActivity" android:screenOrientation="portrait" android:theme="@style/Theme.AppCompat.Light.NoActionBar"/&gt; 到这你就能把cUrop全部导入到你的项目里面了，接下来咱们就拉将如何调用 2.2 开始基本的调用调用起来很简单：12UCrop.of(sourceUri, destinationUri) .start(context); 其中sourceUri是输入图片的Uri，destinationUri是输出图片的Uri。然后他就会由Intent的调动跳到UCropActivity，用户就在UCropActivity里面进行图片裁剪操作，然后最后由UCropActivity发起一个Intent回到你的Activity。 2.3 处理回来的数据由于是从UCropAcitivity传回数据，所以你需要在你的Activity里面的onActivityResult方法处理uCrop返回的信息：12345678@Overridepublic void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (resultCode == RESULT_OK &amp;&amp; requestCode == UCrop.REQUEST_CROP) &#123; final Uri resultUri = UCrop.getOutput(data); &#125; else if (resultCode == UCrop.RESULT_ERROR) &#123; final Throwable cropError = UCrop.getError(data); &#125;&#125; 到这，基本用法就完了，你就可以尽情的使用uCrop。但是我前面说过，uCrop封装程度好，这点很多图片处理框架都可以做到，基本上都是把需要的数据传到自己的Activity之后由自己的Activity处理，所以很多框架看起来都有优秀的封装，那uCrop相比其他又有啥好呢，答案就是自定义灵活： 2.4 uCrop高阶用法2.4.1 配置uCrop12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 启动裁剪 * @param activity 上下文 * @param sourceFilePath 需要裁剪图片的绝对路径 * @param requestCode 比如：UCrop.REQUEST_CROP * @param aspectRatioX 裁剪图片宽高比 * @param aspectRatioY 裁剪图片宽高比 * @return */public static String startUCrop(Activity activity, String sourceFilePath, int requestCode, float aspectRatioX, float aspectRatioY) &#123; Uri sourceUri = Uri.fromFile(new File(sourceFilePath)); File outDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES); if (!outDir.exists()) &#123; outDir.mkdirs(); &#125; File outFile = new File(outDir, System.currentTimeMillis() + ".jpg"); //裁剪后图片的绝对路径 String cameraScalePath = outFile.getAbsolutePath(); Uri destinationUri = Uri.fromFile(outFile); //初始化，第一个参数：需要裁剪的图片；第二个参数：裁剪后图片 UCrop uCrop = UCrop.of(sourceUri, destinationUri); //初始化UCrop配置 UCrop.Options options = new UCrop.Options(); //设置裁剪图片可操作的手势 options.setAllowedGestures(UCropActivity.SCALE, UCropActivity.ROTATE, UCropActivity.ALL); //是否隐藏底部容器，默认显示 options.setHideBottomControls(true); //设置toolbar颜色 options.setToolbarColor(ActivityCompat.getColor(activity, R.color.colorPrimary)); //设置状态栏颜色 options.setStatusBarColor(ActivityCompat.getColor(activity, R.color.colorPrimary)); //是否能调整裁剪框 options.setFreeStyleCropEnabled(true); //UCrop配置 uCrop.withOptions(options); //设置裁剪图片的宽高比，比如16：9 uCrop.withAspectRatio(aspectRatioX, aspectRatioY); //uCrop.useSourceImageAspectRatio(); //跳转裁剪页面 uCrop.start(activity, requestCode); return cameraScalePath;&#125; 2.4.2 其他配置1234567891011121314151617181920212223242526//设置Toolbar标题void setToolbarTitle(@Nullable String text)//设置裁剪的图片格式void setCompressionFormat(@NonNull Bitmap.CompressFormat format)//设置裁剪的图片质量，取值0-100void setCompressionQuality(@IntRange(from = 0) int compressQuality)//设置最多缩放的比例尺void setMaxScaleMultiplier(@FloatRange(from = 1.0, fromInclusive = false) float maxScaleMultiplier)//动画时间void setImageToCropBoundsAnimDuration(@IntRange(from = 100) int durationMillis)//设置图片压缩最大值void setMaxBitmapSize(@IntRange(from = 100) int maxBitmapSize)//是否显示椭圆裁剪框阴影void setOvalDimmedLayer(boolean isOval) //设置椭圆裁剪框阴影颜色void setDimmedLayerColor(@ColorInt int color)//是否显示裁剪框void setShowCropFrame(boolean show)//设置裁剪框边的宽度void setCropFrameStrokeWidth(@IntRange(from = 0) int width)//是否显示裁剪框网格void setShowCropGrid(boolean show) //设置裁剪框网格颜色void setCropGridColor(@ColorInt int color)//设置裁剪框网格宽void setCropGridStrokeWidth(@IntRange(from = 0) int width) 3. 源码解析 在我开始说源码之前，我建议大家可以先看下我下面的连接，因为本框架的作者真的是个好人，他不仅为我们贡献了这么好的一个框架，还把自己写这个框架的思路都写了出来，大家可以看看英文原版国内网友翻译版百度网页翻译机翻版其实我个人感觉百度机翻没有谷歌翻译的好，大家有条件的可以使用谷歌翻译浏览器插件翻译整个网页（谷歌翻译好像国内可以直接访问） 代码结构大致分为三个部分: 3.1 第一部分：UCropActivity（整个框架的外在，用户操作图片的地方）他的功能就是项目主要的界面，以及实现一些基本的初始化。你跳转到uCrop看到的那个操作图片的界面就是它。 这块看源码的时候代码居多，但是，说实话，就像刚刚说的一样，他除了初始化还是初始化。初始化完Toolbar接着初始化ViewGroup，初始化完ViewGroup接着初始化Image数据等等。所以这块我就没咋细看（其实是因为代码太长了，逃） 3.2 第二部分：OverlayView（绘制裁剪框）这一块主要就是来画你所看到的图片中的裁剪的辅助线。 在构造方法里面就调用了一个方法，就是init()，而init()方法也就干了一件事——判断。当系统小于JELLY_BEA_MR2也就是Android4.3时，启动了硬件加速，至于为什么setLayerType(LAYER_TYPE_SOFTWARE, null);这个看着就像启动硬件加速的方法，甚至参数里面还有软件这个单词的方法能启动硬件加速，请大家移步HenCoder Android 自定义 View 1-8 硬件加速（进去直接搜索这个方法即可，就能找到解释的地方），我再次不做解释。 这个类主要有两个方法 drawDimmedLayer()绘制裁剪框之外的灰色部分 drawCropGrid()绘制裁剪框 那我们分别来看下这两个方法： 3.2.1 drawDimmedLayer()123456789101112131415161718192021protected void drawDimmedLayer(@NonNull Canvas canvas) &#123; //先保存当前当前画布 canvas.save(); //判断是否显示圆框 if (mCircleDimmedLayer) &#123; //按Path路径裁剪 canvas.clipPath(mCircularPath, Region.Op.DIFFERENCE); &#125; else &#123; //裁剪矩形 canvas.clipRect(mCropViewRect, Region.Op.DIFFERENCE); &#125; //着色 canvas.drawColor(mDimmedColor); //恢复之前保存的Canvas的状态 canvas.restore(); if (mCircleDimmedLayer) &#123; // 绘制1px笔划以修复反锯齿 canvas.drawCircle(mCropViewRect.centerX(), mCropViewRect.centerY(), Math.min(mCropViewRect.width(), mCropViewRect.height()) / 2.f, mDimmedStrokePaint); &#125;&#125; 首先就是一个mCircleDimmedLayer，这个我真的很迷，因为我不知道她是咋来的，于是我就看OverlayView有没有对这个变量的赋值，于是整个类我就找到了一个setCircleDimmedLayer()方法，于是我看这个方法是在哪被调用了的，然后我就找到他分别被UCropActivity和UCropFragment两个类调用到，而且一个是intent.getBooleanExtra()方法一个是bundle.getBoolean()方法，看到这个我相信大家都有点数了，这明显就是其他类传过来的啊，我发现他两的key的值都是UCrop.Options.EXTRA_CIRCLE_DIMMED_LAYER，那我就懂了，找整个框架里面哪儿提到过这个值不就得了，于是我就发现除了上面两个方法以及他的初始化以外，我发现了第4个调用的地方，也是唯一一个调用的地方——Ucrop.setCircleDimmedLayer()：1234567/** * @param isCircle - set it to true if you want dimmed layer to have an circle inside * iscircle-如果希望暗显层中有一个圆，请将其设置为true。 */public void setCircleDimmedLayer(boolean isCircle) &#123; mOptionBundle.putBoolean(EXTRA_CIRCLE_DIMMED_LAYER, isCircle);&#125; 注释上面是原话，下面是我百度机翻的翻译。看了就懂了吧，反正我没懂，我也完全没有见到哪调用过这个方法，我更不懂啥叫希望暗显层有个圆，啥玩意？充满线条的黑？？？直到我将UCrop的调用方法修改了并运行之后我才懂了：12345val options = UCrop.Options()options.setCircleDimmedLayer(true)UCrop.of(uri, destinationUri) .withOptions(options) .start(this) 结果是： 然后就懂了，应该是能截一个圆形的图案吧，然后我点下了✔️，然后…… 无话可说，作者牛逼！！！ 回去回去，刚刚说到drawDimmedLayer()，可以看到，如果mCircleDimmedLayer为true就调用clipPath()跟着路径裁切一个矩形加原，不然的话就调用clipRect()裁切一个矩形。然后加入颜色，然后完了 3.2.2 drawCropGrid()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950protected void drawCropGrid(@NonNull Canvas canvas) &#123; // 判断是否显示剪裁框 if (mShowCropGrid) &#123; // 判断矩形数据是否为空，mGridPoints 如果等于空的话进入填充数据 if (mGridPoints == null &amp;&amp; !mCropViewRect.isEmpty()) &#123; // 该数组为 canvas.drawLines 的第一个参数，该参数要求其元素个数为 4 的倍数 mGridPoints = new float[(mCropGridRowCount) * 4 + (mCropGridColumnCount) * 4]; int index = 0; // 组装数据，数据为每一组线段的坐标点 for (int i = 0; i &lt; mCropGridRowCount; i++) &#123; mGridPoints[index++] = mCropViewRect.left; mGridPoints[index++] = (mCropViewRect.height() * (((float) i + 1.0f) / (float) (mCropGridRowCount + 1))) + mCropViewRect.top; mGridPoints[index++] = mCropViewRect.right; mGridPoints[index++] = (mCropViewRect.height() * (((float) i + 1.0f) / (float) (mCropGridRowCount + 1))) + mCropViewRect.top; &#125; for (int i = 0; i &lt; mCropGridColumnCount; i++) &#123; mGridPoints[index++] = (mCropViewRect.width() * (((float) i + 1.0f) / (float) (mCropGridColumnCount + 1))) + mCropViewRect.left; mGridPoints[index++] = mCropViewRect.top; mGridPoints[index++] = (mCropViewRect.width() * (((float) i + 1.0f) / (float) (mCropGridColumnCount + 1))) + mCropViewRect.left; mGridPoints[index++] = mCropViewRect.bottom; &#125; &#125; //绘制线段 if (mGridPoints != null) &#123; canvas.drawLines(mGridPoints, mCropGridPaint); &#125; &#125; //绘制矩形包裹线段 if (mShowCropFrame) &#123; canvas.drawRect(mCropViewRect, mCropFramePaint); &#125; //绘制边角包裹,mFreestyleCropMode此参数如果等于1的话 剪裁框为可移动状态，一般不用 if (mFreestyleCropMode != FREESTYLE_CROP_MODE_DISABLE) &#123; canvas.save(); mTempRect.set(mCropViewRect); mTempRect.inset(mCropRectCornerTouchAreaLineLength, -mCropRectCornerTouchAreaLineLength); canvas.clipRect(mTempRect, Region.Op.DIFFERENCE); mTempRect.set(mCropViewRect); mTempRect.inset(-mCropRectCornerTouchAreaLineLength, mCropRectCornerTouchAreaLineLength); canvas.clipRect(mTempRect, Region.Op.DIFFERENCE); canvas.drawRect(mCropViewRect, mCropFrameCornersPaint); canvas.restore(); &#125;&#125; 一开头又是一个和上面类似的变量mShowCropGrid，这下我就不说我找的具体步骤，他的功能就是如果他是true就会在裁剪框中显示9宫格线，为false就没有。接着就是画线部分，我觉得这个我不用讲啥，也没啥讲的，唯一就是为什么mGridPoints这个数组的大小是4的倍数，大家可以看下这个博客Android Canvas DrawLines中第一个参数的解释 3.3 第三部分：GestureCropImageView（正在框架的内在，代码操作操作图片的地方）这个是整个项目最核心的地方。前面的两部分都是UI的，而这个才是真正的对图片进行处理的部分，也是我最想知道了解的部分。这部分作者也在他的博客里面说的最多最清楚。作者把这部分的逻辑分为了三个部分 TransformImageView extends ImageView 他处理了 从源拿到图片 将图片进变换（平移、缩放、旋转），并应用到当前图片上 CropImageView extends TransformImageView 他处理了 绘制裁剪边框和网格 为裁剪区域设置一张图片（如果用户对图片操作导致裁剪区域出现了空白，那么图片应自动移动到边界填充空白区域） 继承父类方法，使用更精准的规则来操作矩阵（限制最大和最小缩放比） 添加方法和缩小的方法 裁剪图片 GestureCropImageView extends CropImageView 他处理了 监听用户手势，并调用对应的正确的方法 3.3.1 TransformImageView作者说这是最容易的部分。在看这个类之前我们先来看看BitmapLoadTask类，这个类是一切图像处理的基础，这个类负责了Uri解码bitmap，并处理分辨率：首先根据拿到的Uri解析位图：12345678910111213final ParcelFileDescriptor parcelFileDescriptor;try &#123; parcelFileDescriptor = mContext.getContentResolver().openFileDescriptor(mInputUri, "r");&#125; catch (FileNotFoundException e) &#123; return new BitmapWorkerResult(e);&#125;final FileDescriptor fileDescriptor;if (parcelFileDescriptor != null) &#123; fileDescriptor = parcelFileDescriptor.getFileDescriptor();&#125; else &#123; return new BitmapWorkerResult(new NullPointerException("ParcelFileDescriptor was null for given Uri: [" + mInputUri + "]"));&#125; 现在，可以使用BitmapFactory方法解码FileDescriptor。 但在解码位图之前，有必要知道它的大小，因为如果分辨率太高，位图将被二次采样。123456789101112131415161718192021222324252627282930313233final BitmapFactory.Options options = new BitmapFactory.Options();options.inJustDecodeBounds = true;BitmapFactory.decodeFileDescriptor(fileDescriptor, null, options);options.inSampleSize = calculateInSampleSize(options, requiredWidth, requiredHeight);options.inJustDecodeBounds = false;Bitmap decodeSampledBitmap = BitmapFactory.decodeFileDescriptor(fileDescriptor, null, options);close(parcelFileDescriptor);ExifInterface exif = getExif(uri);if (exif != null) &#123; int exifOrientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL); return rotateBitmap(decodeSampledBitmap, exifToDegrees(exifOrientation));&#125; else &#123; return decodeSampledBitmap;&#125; 这样就拿到了bitmap实例了，就可以去TansformImageView去对图片进行调整了。其实这个类我也不知道说啥😂，我觉得这个类也就是把Matrix的postTranslate()、postRotate()和postScale()方法给封装了下。关于Matrix的知识大家可以参考这篇博客：安卓自定义View进阶-Matrix原理 3.3.2 CropImageView这一层是最复杂的一层，作者的操作大致可以分为3步：图片裁剪框偏移计算、图片归为动画处理、裁剪图片 第一步：图片裁剪框偏移计算当用户手指移开时，要确保图片处于裁剪区域中，如果不处于，需要通过平移把它移过来： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public void setImageToWrapCropBounds(boolean animate) &#123; //如果图片加载完毕并且图片不处于剪裁区域 if (mBitmapLaidOut &amp;&amp; !isImageWrapCropBounds()) &#123; //获取中心点X,Y坐标 float currentX = mCurrentImageCenter[0]; float currentY = mCurrentImageCenter[1]; //获取缩放比例 float currentScale = getCurrentScale(); //获取偏移距离 float deltaX = mCropRect.centerX() - currentX; float deltaY = mCropRect.centerY() - currentY; float deltaScale = 0; mTempMatrix.reset(); mTempMatrix.setTranslate(deltaX, deltaY); final float[] tempCurrentImageCorners = Arrays.copyOf(mCurrentImageCorners, mCurrentImageCorners.length); mTempMatrix.mapPoints(tempCurrentImageCorners); //判断图片是否包含在剪裁区域 boolean willImageWrapCropBoundsAfterTranslate = isImageWrapCropBounds(tempCurrentImageCorners); //如果包含在剪裁区域 if (willImageWrapCropBoundsAfterTranslate) &#123; //获取偏移的距离 final float[] imageIndents = calculateImageIndents(); //偏移的距离，横坐标加横坐标 纵坐标加纵坐标 deltaX = -(imageIndents[0] + imageIndents[2]); deltaY = -(imageIndents[1] + imageIndents[3]); &#125; else &#123; //如果不包含在剪裁区域，创建临时矩形 RectF tempCropRect = new RectF(mCropRect); mTempMatrix.reset(); //设置偏移角度 mTempMatrix.setRotate(getCurrentAngle()); mTempMatrix.mapRect(tempCropRect); //获得矩形的边长坐标 final float[] currentImageSides = RectUtils.getRectSidesFromCorners(mCurrentImageCorners); //获取放大比例 deltaScale = Math.max(tempCropRect.width() / currentImageSides[0], tempCropRect.height() / currentImageSides[1]); deltaScale = deltaScale * currentScale - currentScale; &#125; //如果需要动画 if (animate) &#123; post(mWrapCropBoundsRunnable = new WrapCropBoundsRunnable( CropImageView.this, mImageToWrapCropBoundsAnimDuration, currentX, currentY, deltaX, deltaY, currentScale, deltaScale, willImageWrapCropBoundsAfterTranslate)); &#125; else &#123; //不需要动画，直接移动到目标位置 postTranslate(deltaX, deltaY); if (!willImageWrapCropBoundsAfterTranslate) &#123; zoomInImage(currentScale + deltaScale, mCropRect.centerX(), mCropRect.centerY()); &#125; &#125; &#125;&#125; 第二步：处理平移通过一个Runnable线程来处理平移，并且通过时间差值的计算来移动动画，使动画看起来更真实：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 此可运行文件用于动画图像，使其完全填充裁剪边界。 * 给定值在动画期间内插。 * runnable可以终止于vie&#123;@link #cancelAllAnimations()&#125;方法， * 也可以在触发&#123;@link WrapCropBoundsRunnable#run()&#125;方法内的某些条件时终止。 */private static class WrapCropBoundsRunnable implements Runnable &#123; private final WeakReference&lt;CropImageView&gt; mCropImageView; private final long mDurationMs, mStartTime; private final float mOldX, mOldY; private final float mCenterDiffX, mCenterDiffY; private final float mOldScale; private final float mDeltaScale; private final boolean mWillBeImageInBoundsAfterTranslate; public WrapCropBoundsRunnable(CropImageView cropImageView, long durationMs, float oldX, float oldY, float centerDiffX, float centerDiffY, float oldScale, float deltaScale, boolean willBeImageInBoundsAfterTranslate) &#123; mCropImageView = new WeakReference&lt;&gt;(cropImageView); mDurationMs = durationMs; mStartTime = System.currentTimeMillis(); mOldX = oldX; mOldY = oldY; mCenterDiffX = centerDiffX; mCenterDiffY = centerDiffY; mOldScale = oldScale; mDeltaScale = deltaScale; mWillBeImageInBoundsAfterTranslate = willBeImageInBoundsAfterTranslate; &#125; @Override public void run() &#123; CropImageView cropImageView = mCropImageView.get(); if (cropImageView == null) &#123; return; &#125; long now = System.currentTimeMillis(); float currentMs = Math.min(mDurationMs, now - mStartTime); float newX = CubicEasing.easeOut(currentMs, 0, mCenterDiffX, mDurationMs); float newY = CubicEasing.easeOut(currentMs, 0, mCenterDiffY, mDurationMs); float newScale = CubicEasing.easeInOut(currentMs, 0, mDeltaScale, mDurationMs); if (currentMs &lt; mDurationMs) &#123; cropImageView.postTranslate(newX - (cropImageView.mCurrentImageCenter[0] - mOldX), newY - (cropImageView.mCurrentImageCenter[1] - mOldY)); if (!mWillBeImageInBoundsAfterTranslate) &#123; cropImageView.zoomInImage(mOldScale + newScale, cropImageView.mCropRect.centerX(), cropImageView.mCropRect.centerY()); &#125; if (!cropImageView.isImageWrapCropBounds()) &#123; cropImageView.post(this); &#125; &#125; &#125;&#125; 下面还有另一个线程，用于双击放大: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 此可运行项用于设置图像缩放的动画。 * 给定值在动画期间内插。 * runnable可以终止vie &#123;@link #cancelAllAnimations()&#125;方法， * 也可以在触发&#123;@link ZoomImageToPosition#run()&#125;方法内的某些条件时终止。 */private static class ZoomImageToPosition implements Runnable &#123; private final WeakReference&lt;CropImageView&gt; mCropImageView; private final long mDurationMs, mStartTime; private final float mOldScale; private final float mDeltaScale; private final float mDestX; private final float mDestY; public ZoomImageToPosition(CropImageView cropImageView, long durationMs, float oldScale, float deltaScale, float destX, float destY) &#123; mCropImageView = new WeakReference&lt;&gt;(cropImageView); mStartTime = System.currentTimeMillis(); mDurationMs = durationMs; mOldScale = oldScale; mDeltaScale = deltaScale; mDestX = destX; mDestY = destY; &#125; @Override public void run() &#123; CropImageView cropImageView = mCropImageView.get(); if (cropImageView == null) &#123; return; &#125; long now = System.currentTimeMillis(); float currentMs = Math.min(mDurationMs, now - mStartTime); float newScale = CubicEasing.easeInOut(currentMs, 0, mDeltaScale, mDurationMs); if (currentMs &lt; mDurationMs) &#123; cropImageView.zoomInImage(mOldScale + newScale, mDestX, mDestY); cropImageView.post(this); &#125; else &#123; cropImageView.setImageToWrapCropBounds(); &#125; &#125;&#125; 第三步：裁剪图片 12345678910111213141516171819202122232425/** * 取消所有当前动画并设置图像以填充裁剪区域（不带动画）。 * 然后用适当的参数创建并执行&#123;@link BitmapCropTask&#125;。 */public void cropAndSaveImage(@NonNull Bitmap.CompressFormat compressFormat, int compressQuality, @Nullable BitmapCropCallback cropCallback) &#123; //结束子线程 cancelAllAnimations(); //设置要剪裁的图片，不需要位移动画 setImageToWrapCropBounds(false); //存储图片信息，四个参数分别为：mCropRect要剪裁的图片矩阵，当前图片要剪裁的矩阵，当前放大的值，当前旋转的角度 final ImageState imageState = new ImageState( mCropRect, RectUtils.trapToRect(mCurrentImageCorners), getCurrentScale(), getCurrentAngle()); //剪裁参数，mMaxResultImageSizeX，mMaxResultImageSizeY：剪裁图片的最大宽度、高度。 final CropParameters cropParameters = new CropParameters( mMaxResultImageSizeX, mMaxResultImageSizeY, compressFormat, compressQuality, getImageInputPath(), getImageOutputPath(), getExifInfo()); //剪裁操作放到AsyncTask中执行 new BitmapCropTask(getViewBitmap(), imageState, cropParameters, cropCallback).execute();&#125; 这块核心方法还是在BitmapCropTask中：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//调整剪裁大小，如果有设置最大剪裁大小也会在这里做调整到设置范围private float resize() &#123; final BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeFile(mImageInputPath, options); boolean swapSides = mExifInfo.getExifDegrees() == 90 || mExifInfo.getExifDegrees() == 270; float scaleX = (swapSides ? options.outHeight : options.outWidth) / (float) mViewBitmap.getWidth(); float scaleY = (swapSides ? options.outWidth : options.outHeight) / (float) mViewBitmap.getHeight(); float resizeScale = Math.min(scaleX, scaleY); mCurrentScale /= resizeScale; resizeScale = 1; if (mMaxResultImageSizeX &gt; 0 &amp;&amp; mMaxResultImageSizeY &gt; 0) &#123; float cropWidth = mCropRect.width() / mCurrentScale; float cropHeight = mCropRect.height() / mCurrentScale; if (cropWidth &gt; mMaxResultImageSizeX || cropHeight &gt; mMaxResultImageSizeY) &#123; scaleX = mMaxResultImageSizeX / cropWidth; scaleY = mMaxResultImageSizeY / cropHeight; resizeScale = Math.min(scaleX, scaleY); mCurrentScale /= resizeScale; &#125; &#125; return resizeScale;&#125;// 剪裁图片private boolean crop(float resizeScale) throws IOException &#123; ExifInterface originalExif = new ExifInterface(mImageInputPath); //四舍五入取整 cropOffsetX = Math.round((mCropRect.left - mCurrentImageRect.left) / mCurrentScale); cropOffsetY = Math.round((mCropRect.top - mCurrentImageRect.top) / mCurrentScale); mCroppedImageWidth = Math.round(mCropRect.width() / mCurrentScale); mCroppedImageHeight = Math.round(mCropRect.height() / mCurrentScale); //计算出图片是否需要被剪裁 boolean shouldCrop = shouldCrop(mCroppedImageWidth, mCroppedImageHeight); Log.i(TAG, "Should crop: " + shouldCrop); if (shouldCrop) &#123; //调用C++方法剪裁 boolean cropped = cropCImg(mImageInputPath, mImageOutputPath, cropOffsetX, cropOffsetY, mCroppedImageWidth, mCroppedImageHeight, mCurrentAngle, resizeScale, mCompressFormat.ordinal(), mCompressQuality, mExifInfo.getExifDegrees(), mExifInfo.getExifTranslation()); //剪裁成功复制图片EXIF信息 if (cropped &amp;&amp; mCompressFormat.equals(Bitmap.CompressFormat.JPEG)) &#123; ImageHeaderParser.copyExif(originalExif, mCroppedImageWidth, mCroppedImageHeight, mImageOutputPath); &#125; return cropped; &#125; else &#123; //直接复制图片到目标文件夹 FileUtils.copyFile(mImageInputPath, mImageOutputPath); return false; &#125;&#125; 3.3.3 GestureCropImageView这个类主要就是对手势的监听，所以我们简单粗暴，直接找他的onTouchEvent方法：123456789101112131415161718192021222324252627282930313233343536/** * 如果是ACTION_DOWN event，用户触摸屏幕，必须取消所有当前动画。 * 如果是ACTION_UP event，用户从屏幕上取下所有手指，必须纠正当前图像位置。 * 如果有两个以上的手指-更新焦点坐标。 * 如果已启用，则将事件传递给手势检测器。 */@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; if ((event.getAction() &amp; MotionEvent.ACTION_MASK) == MotionEvent.ACTION_DOWN) &#123; cancelAllAnimations(); &#125; if (event.getPointerCount() &gt; 1) &#123; mMidPntX = (event.getX(0) + event.getX(1)) / 2; mMidPntY = (event.getY(0) + event.getY(1)) / 2; &#125; //双击监听和拖动监听 mGestureDetector.onTouchEvent(event); //两指缩放监听 if (mIsScaleEnabled) &#123; mScaleDetector.onTouchEvent(event); &#125; //旋转监听 if (mIsRotateEnabled) &#123; mRotateDetector.onTouchEvent(event); &#125; if ((event.getAction() &amp; MotionEvent.ACTION_MASK) == MotionEvent.ACTION_UP) &#123; //最后一指抬起时判断图片是否填充剪裁框 setImageToWrapCropBounds(); &#125; return true;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码</tag>
        <tag>uCrop</tag>
        <tag>图片处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Aria2macOS安装]]></title>
    <url>%2Fposts%2F4f46fdbb.html</url>
    <content type="text"><![CDATA[对不起大家，在我配置好这个软件之后，我兴冲冲的打开了github想下载下ssr4.0forWindows，迫不及待想感受下aria2的快感，结果发现我错了。下载速度就才几十k/s，那一瞬间，我感触很多，我突然想到我昨晚的迅雷下载同样的资源同样的网同样的vpn下大几百k/s 的速度，然后又看到了此时我给予希望的aria，我陷入了沉思，或许这就是人生吧。突然觉得macOS迅雷，也还挺好看的，也挺好用的，完全没有广告，要下载打开，下载完了就退出，唯一问题就是Chrome的迅雷拓展似乎太灵敏了点，我啥都没点就莫名其妙弹出下载页面，除了这个，似乎非常完美。所以，在我配置好aria2并写下这篇博客后的不到1个小时时间，我卸载了aira2，并重新用上了迅雷。所以，我最后只想说一句，财大nb！财大nb！财大nb！对不起，走错片场了，重来，IDM牛逼！IDM牛逼！IDM牛逼！如果哪位牛逼的大哥看到了这篇博客，记得帮我给IDM说声，一个Windows的IDM正版用户急需IDM macOS版！！！ 下载Aira2通过github安装 打开github主页 aria2/aria2-Release 找到对应的系统下载安装即可 通过Homebrew安装终端输入命令brew install aria2安装即可。没有安装Homebrew的同学可以搜索安装Homebrew即可。 这个软件是没有图形界面的，所以安装好之后在启动台里面是找不到Aria2的图标的 配置Aira2先创建Aria2的配置文件Aria2提供了两种工作模式： 直接命令行模式下载 不太推荐这种，因为命令行下下载比较繁琐，而且也不太好操作 RPC模式 在这种方式，Aria2启动之后就会以后台的方式运行，你就可以通过WebUI或者安装客户端的方式来使用图形界面控制Aria2.但是这种方式下需要配置文件，现在就告诉大家如何配置：首先创建文件 1234cd ~mkdir /.aria2cd /.aria2touch aria2.conf 然后打开Finder，使用快捷键Shift+Cmd+G弹出路径输入框，接着复制粘贴~/.aria2/回车就进入了.aria2文件夹，你就会看到里面的aria2.conf文件，接着用文本编辑器打开，复制粘贴以下内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#用户名#rpc-user=user#密码#rpc-passwd=passwd#上面的认证方式不建议使用,建议使用下面的token方式#设置加密的密钥#rpc-secret=token#允许rpcenable-rpc=true#允许所有来源, web界面跨域权限需要rpc-allow-origin-all=true#允许外部访问，false的话只监听本地端口rpc-listen-all=true#RPC端口, 仅当默认端口被占用时修改#rpc-listen-port=6800#最大同时下载数(任务数), 路由建议值: 3max-concurrent-downloads=5#断点续传continue=true#同服务器连接数max-connection-per-server=5#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要min-split-size=10M#单文件最大线程数, 路由建议值: 5split=10#下载速度限制max-overall-download-limit=0#单文件速度限制max-download-limit=0#上传速度限制max-overall-upload-limit=0#单文件速度限制max-upload-limit=0#断开速度过慢的连接#lowest-speed-limit=0#验证用，需要1.16.1之后的release版本#referer=*#文件保存路径, 默认为当前启动位置dir=/Users/xxx/Downloads#文件缓存, 使用内置的文件缓存, 如果你不相信Linux内核文件缓存和磁盘内置缓存时使用, 需要1.16及以上版本#disk-cache=0#另一种Linux文件缓存方式, 使用前确保您使用的内核支持此选项, 需要1.15及以上版本(?)#enable-mmap=true#文件预分配, 能有效降低文件碎片, 提高磁盘性能. 缺点是预分配时间较长#所需时间 none &lt; falloc ? trunc « prealloc, falloc和trunc需要文件系统和内核支持file-allocation=prealloc#开启BT下载enable-dht=truebt-enable-lpd=trueenable-peer-exchange=true# bt-tracker 更新，解决Aria2 BT下载速度慢没速度的问题udp://tracker.coppersurfer.tk:6969/announce,http://tracker.internetwarriors.net:1337/announce,udp://tracker.opentrackr.org:1337/announce,udp://9.rarbg.to:2710/announce,udp://9.rarbg.me:2710/announce,udp://tracker.openbittorrent.com:80/announce,http://tracker3.itzmx.com:6961/announce,http://tracker1.itzmx.com:8080/announce,udp://exodus.desync.com:6969/announce,udp://retracker.lanta-net.ru:2710/announce,udp://tracker.torrent.eu.org:451/announce,udp://tracker.tiny-vps.com:6969/announce,udp://bt.xxx-tracker.com:2710/announce,udp://tracker2.itzmx.com:6961/announce,udp://tracker.cyberia.is:6969/announce,udp://open.demonii.si:1337/announce,udp://explodie.org:6969/announce,udp://denis.stalker.upeer.me:6969/announce,udp://open.stealth.si:80/announce,http://tracker4.itzmx.com:2710/announce 不用更改啥，也不建议更改啥，大家可以看一下上面的配置内容，至少记得每一项大致是个啥，因为等会配置图形界面需要这些信息。 最后面的BT下载的bt-tracker大家配置记得到这个页面更新：https://raw.githubusercontent.com/ngosang/trackerslist/master/trackers_best.txt 然后再把内容复制粘贴过去。 下载路径你可以自己选择，可以就把/Users/xxx/Downloads中的xxx换成你自己的macOS用户名即可。 启动Aria2 RPC模式终端输入aria2c --conf-path=&quot;/Users/xxx/.aria2/aria2.conf&quot; -D就可以启动了。一样的，xxx是你的用户名。 进入图形界面Aria2有很多第三方图形界面，客户端有，但是我没用过所以我不做介绍，在这主要介绍WebUI。 YAAW插件 在chrome的拓展中心搜索YAAW，然后安装即可，接着就会出现YAAM的插件 点击打开它，就会进入YAAW的WebUI。 点击右上角的🔧图标，进入设置界面 如果你上面的aria2.conf是直接复制粘贴的我的话，照着我图中的填写就可以了，然后就可以使用了。找到需要下载的资源右键然后选择YAAW就会自动开始下载。 AriaNg WebUI这个比上面那个好看点，缺点是没有插件，你只能复制下载链接手动新建下载任务 在浏览器中输入网址 http://ariang.mayswind.net/latest/#!/downloading 点击AriaNg设置 一样，如果你上面的aria2.conf是直接复制粘贴的我的话，照着我图中的填写就可以了，然后就可以使用了。 你可以点击Aria2状态，看看是不是已连接，如果不是就看看有没有哪儿和aria2.conf设置的不一样。 关闭Aria2这个好像官方没有方法关闭，于是我们就用最简单粗暴的方法。 终端输入ps aux|grep aria2得到Aria2的进程号 然后输入kill number调用系统命令直接杀死这个进程，number改为上面的到的进程号即可。 配置自启动创建sh文件进入到希望保存的目录下，新建一个文件aria2.sh：1touch aria2.sh 然后输入下面的代码并保存：12345#!/bin/bashecho &quot;start aria2 server&quot;aria2c --conf-path=&quot;/Users/xxx/.aria2/aria2.conf&quot; -Decho &quot;exiting&quot;exit 修改文件权限 给aria2.sh文件执行权限：chmod +x aria2.sh 让aria2.sh默认用自己常用的terminal工具打开。右键文件 －&gt; 显示简介：设置“打开方式-&gt;所有应用程序”为自己的terminal即可。 添加到开机启动项 在Mac桌面顶部菜单中，点击苹果图标，在弹出的菜单中，点击进入系统偏好设置。 在打开系统偏好设置后，然后点击进入用户与群组设置选项。 然后在用户与群组设置界面，先在左侧选择登陆用户-当前用户，然后在右侧切换到登录项 然后点下面的+进行添加，选择刚才我们创建的文件aria2.sh，并勾选隐藏。这样 aria2 就可以在每次开机的时候自启动了。 最后，Aria2卸载方式终端下执行sudo pkgutil --forget aria2以及sudo pkgutil --forget aria2.path，然后上面创建的.aria2文件夹]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Aria2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统3--进程的同步]]></title>
    <url>%2Fposts%2F362e394f.html</url>
    <content type="text"><![CDATA[大家可以看下我使用幕布软件画的思维导图，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员https://mubu.com/inv/477598 3.1 进程同步3.1.1 同步概念3.1.1.1 进程同步的概念进程同步机制的主要任务就是对多个相关进程在执行次序上进行协调，使并发执行的进程之间能按照一定的规则共享系统资源，并能很好的配合工作，从而使程序的执行具有可再现性。 3.1.1.2 制约关系对于处于同一个系统中的多个进程，由于他们共享着系统的资源，或者为了完成同一个任务而相互合作，所以他们之间可能存在下面两种制约关系： 间接相互制约关系 系统中的进程难免会调用像打印机、CPU等这样的临界资源。如果想这些资源正常调用，必须保证多个进程之间互斥地访问这些资源，进而就在这些进程间形成了间接相互制约关系。 为了保证这些进程能有序的进行，对于系统中的这类资源，必须由系统实施统一分配，即用户在使用之前必须先提出申请，绝不允许用户直接使用。 直接相互制约关系 在系统中也会存在一些进程，他们为了完成同一个目标而相互配合合作工作，这种就是直接互相制约关系。 进程间的直接制约关系就是源于他们之间的相互合作。 3.1.1.3 临界资源虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。此外，如果变量、数据等都可以被若干进程共享，也属于临界资源。 3.1.1.4 临界区人们把在每个进程中访问临界资源的那段代码称为临界区。若能保证诸进程互斥地进入自己的临界区，便可实现诸进程对临界资源的互斥访问。为此，每个进程在进入临界区之前，应先对要访问的临界区进程检查：如果临界区正在被访问，则进程不能进入临界区；如果临界区没有被访问，那进程就可进入临界区，并将临界区正在被访问的标志置为正被访问。所以，我们可以将访问临界资源的线程的循环代码分为如下部分： 访问临界区之前用于上述判断的代码区称为进入区 在访问完临界区之后用于将临界区正被访问的标志恢复为未被访问的标志的代码区称为退出区 除了进入去、临界区、退出区代码之外的其它代码称为剩余区 123456while (true) &#123; 进入区 临界区 退出区 剩余区&#125; 3.1.1.5 同步机制应遵循的规则 空闲让进：当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效的利用临界资源 忙则等待：当已有进程进入临界区，表明临界资源正在被访问，因而其它视图进入临界区的进程必须等待，以保证对临界资源的互斥访问 有限等待：对要求访问临界资源的进程，应保证在有限的时间内能进入自己的临界区，以免陷入“死等”状态 让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态 3.1.2 同步机制3.2.2.1 信号量机制1. 什么是信号量信号量的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程，值则与相应的资源的使用情况有关： 当他的值大于0时，表示当前可用资源的数量 当他的值小于0时，其绝对值表示等待使用该资源的进程个数 2. 什么是信号量机制信号量机制即利用pv操作对信号量进行处理。而且信号量只能由pv操作进程处理。当S&gt;0时，S表示可用资源的数量。执行一次P操作意味着分配一个单位资源，因此S值减1；当S0，表示有某些资源正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去。 3.2.2.2 PV操作1. P操作申请一个单位资源，进程进入临界区1234wait (S) &#123; while (s &lt;= 0) ;// 如果没有资源则循环等待 S--;&#125; 将信号量S的值减1，即S=S-1； 如果S&lt;=0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。 2. V操作释放一个单位资源，进程从临界区出来123signal (S) &#123; S++;&#125; 将信号量S的值加1，即S=S+1； 如果S&gt;0，则该进程继续执行；否则释放队列中第一个等待信号量的进程。 3. PV操作的意义用PV操作来实现进程的同步和互斥 3.2.3 管程机制尽管信号量机制很方又高效，但是每个要访问临界资源的进程都必须必备同步操作，这就使得大量的同步操作分散在各个进程中。这不仅给系统的管理带来麻烦，还会因同步操作不当而产生死锁。为了解决上述问题，变产生了一种新的同步工具——管程。 1. 管程的定义系统中各种硬件资源和软件资源均可用数据结构抽象地描述其资源特征，即用少量信息和对该资源所执行的操作来表征该资源。所以就出现了管程。管程可以看成一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。在管程入口处的等待队列称为入口等待队列，由于进程会执行唤醒操作，因此可能有多个等待使用管程的队列，这样的队列称为紧急队列，它的优先级高于等待队列。 2. 管程的特征 模块化 管程是一个基本的软件模块，可以单独编译 抽象数据类型 管程中封装了数据及对于数据的操作 信息隐藏 管程外的进程或其他软件模块只能通过管程对外的接口来访问管程提供的操作，管程内部的实现细节对外界是透明的 使用的互斥性 任何一个时刻，管程只能由一个进程使用。进入管程时的互斥由编译器负责完成 3. 条件变量一个进程被阻塞或挂起的条件（原因）有多个，因此在管程中设置了多个条件变量，对这些条件变量的访问只能在管程中进行。管程中每个条件变量都需予以说明，形式为：condition x。对其的操作只有wait和signal，其含义是： x.wait：正在调用管程的进程因x条件需要被阻塞或挂起，则调用x.wait将自己插入到x条件的等待队列上，并释放管程，知道x条件发生变化。此时其它进程可以使用该管程。 x.signal： 正在调用管程的进程发现x条件发生了变化，则调用x.signal，重新启动一个因x条件而阻塞或挂起的进程，如果存在多个这样的进程，则选择其中的一个，如果没有，继续执行原进程，不产生任何结果。（与信号量的signal不同，没有s=s+1的操作） 3.2 进程同步的经典问题3.2.1 生产者-消费者问题1. 问题描述有一群生产者进程在生产产品，并将这些产品提供给消费者进程去消费。为使生产者进程与消费者进程能并发执行，在两者之间设置了一个大小为n的缓冲区，生产者进程将其所产生的产品放入缓冲区中；消费者可从缓冲区中取走产品去消费。他们之间必须保持同步，也就是既不允许消费者进程到一个空缓冲区去取产品，也不允许生产者进程向一个已装满产品且尚未被取走的缓冲区中投放产品。 2. 问题分析需要注意的几点： 在缓冲区为空时，消费者不能再进行消费 在缓冲区已满时，生产者不能再进行生产 当一个线程进行生产或消费时，其余线程不能再进行生产或消费 3. 伪代码12345678910111213141516171819202122232425262728293031var items = 0, space = 10, mutex = 1;var in = 0, out = 0;item buf[10] = &#123; NULL &#125;;producer &#123; while( true ) &#123; wait( space ); // 等待缓冲区有空闲位置， 在使用PV操作时，条件变量需要在互斥锁之前 wait( mutex ); // 保证在product时不会有其他线程访问缓冲区 // product buf.push( item, in ); // 将新资源放到buf[in]位置 in = ( in + 1 ) % 10; signal( mutex ); // 唤醒的顺序可以不同 signal( items ); // 通知consumer缓冲区有资源可以取走 &#125;&#125;consumer &#123; while( true ) &#123; wait( items ); // 等待缓冲区有资源可以使用 wait( mutex ); // 保证在consume时不会有其他线程访问缓冲区 // consume buf.pop( out ); // 将buf[out]位置的的资源取走 out = ( out + 1 ) % 10; signal( mutex ); // 唤醒的顺序可以不同 signal( space ); // 通知缓冲区有空闲位置 &#125;&#125; 不能将线程里两个wait的顺序调换否则会出现死锁。例如(调换后)，将consumer的两个wait调换，在producer发出signal信号后，如果producer线程此时再次获得运行机会，执行完了wait(space)，此时，另一个consumer线程获得运行机会，执行了wait(mutex)，如果此时缓冲区为空，那么consumer将会阻塞在wait(items)，而producer也会因为无法获得锁的所有权所以阻塞在wait(mutex)，这样两个线程都在阻塞，也就造成了死锁。 3.2.2 哲学家进餐问题1. 问题描述有五位哲学家共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五支筷子。他们的生活的方式是交替的进行思考和进餐：平时，一个哲学家进行思考，饥饿时便视图取其左右离他最近的筷子，只有在他拿到两只筷子时才能进餐，进餐完毕，放下筷子继续思考。 2. 问题分析 只有拿到两只筷子时，哲学家才能吃饭。 如果筷子已被别人拿走，则必须等别人吃完之后才能拿到筷子。 任一哲学家在自己未拿到两只筷子吃完饭前，不会放下手中已经拿到的筷子 3. 伪代码至多只允许四个哲学家同时进餐，以保证至少有一个哲学家能够进餐，最终总会释放出他所使用过的两支筷子，从而可使更多的哲学家进餐。定义信号量count，只允许4个哲学家同时进餐，这样就能保证至少有一个哲学家可以就餐。 12345678910111213141516semaphore chopstick[5]=&#123;1,1,1,1,1&#125;;semaphore count=4; // 设置一个count，最多有四个哲学家可以进来void philosopher(int i)&#123; while(true) &#123; think(); wait(count); //请求进入房间进餐 当count为0时 不能允许哲学家再进来了 wait(chopstick[i]); //请求左手边的筷子 wait(chopstick[(i+1)%5]); //请求右手边的筷子 eat(); signal(chopstick[i]); //释放左手边的筷子 signal(chopstick[(i+1)%5]); //释放右手边的筷子 signal(count); //离开饭桌释放信号量 &#125;&#125; 3.2.3 读者-写者问题1. 问题描述一个数据文件或记录可被多个进程共享，我们把只要求读该文件的进程称为“Reader进程”，其它进程则称为“Writer进程”。允许多个进程同时读一个共享对象，因为读操作不会使数据文件混乱。但不允许一个Writer进程和其它Reader进程或Writer进程同时访问共享对象，这样很有可能造成共享数据混乱。 2. 问题分析 允许多个Reader进程同时操作一个共享对象 不允许Writer进程和其它进程同时操作一个共享对象 3. 伪代码12345678910111213141516171819202122232425semaphore rmutex = 1,wmutex = 1;int readcount = 0;void reader()&#123; do&#123; wait(rmutex); if(readcount==0) wait(wmutex); readcount++; signal(rmutex); ··· perform read operation; ··· wait（rmutex）； if(readcount==0) signal(wmutex); readcount--; signal(rmutex); &#125;while(TRUE);&#125;void writer()&#123; do&#123; wait(wmutex); perfrom write operation; signal(wmutex); &#125;while(TRUE);&#125;]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android网络请求3--解析OkHttp源码]]></title>
    <url>%2Fposts%2F151ac78a.html</url>
    <content type="text"><![CDATA[1. OkHttp简介okhttp是一个第三方类库，用于android中请求网络。 这是一个开源项目,是安卓端最火热的轻量级框架,由移动支付Square公司贡献。用于替代因移除了HttpClient而导致没用的Volley。 目前更多人选择了Retrofit。 2. 源码解析 本文对OkHttp的探讨全部基于目前的最新版OkHttp:4.0.1，而这个版本作者已经使用kotlin对源码进行了重写，所以有些小伙伴可能阅读稍微有点问题，但是别担心，本文中所涉及的源码阅读起来基本上和Java一样，所以请不会kotlin的小伙伴还是耐心看下去，不太懂的语法就百度下，同时我也会对某些语法作注释 2.1 OkHttp请求流程2.1.1 从请求处理开始分析我们无论在使用OkHttp进行什么请求的时候都会创建OkHttpClient对象并调用他的newCall()方法，那我们就从这个方法看起： 123override fun newCall(request: Request): Call &#123;return RealCall.newRealCall(this, request, forWebSocket = false)&#125; 可以看到返回了一个RealCall对象，所以也就意味着我们使用OkHttpClient对象调用的execute()操作实际上是RealCall的execute()操作，那我们就来看RealCall的execute()方法：123456789101112131415161718192021override fun execute(): Response &#123; // 添加同步锁 synchronized(this) &#123; // check()是kotlin特有的一个方法，他本质上就是一个if， // 但是当他的判断语句是false的话， // 他就会抛出一个IllegalStateException异常，异常的内容就是后面的语句 check(!executed) &#123; "Already Executed" &#125; executed = true // executed是一个布尔值，他的作用就是判断是不是执行过了， // 如果执行过了还执行了这个方法的话就抛异常 &#125; // transmitter用于连接OKHTTP的应用程序和网络层，不用多管 transmitter.timeoutEnter() transmitter.callStart() try &#123; client.dispatcher.executed(this) return getResponseWithInterceptorChain() &#125; finally &#123; client.dispatcher.finished(this) &#125;&#125; 这块又调用了client.dispatcher，然后找回去找到OkHttpClient的dispatcher对象，发现他就是Dispatcher类的一个对象，接着我们继续看Dispatcher类。 2.1.2 Dispatcher任务调度进入Dispatcher类，我们可以看到如下成员变量定义: 注：kotlin中一个成员变量的@get和@set分别对应了Java中get和set方法，所以这块我没有完完全全复制粘贴到这，我只取了定义部分 123456789101112// 最大并发请求数var maxRequests = 64// 每个主机的最大请求数var maxRequestsPerHost = 5// 消费者线程val executorService: ExecutorService// 将要运行的异步请求队列private val readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()// 正在运行的异步请求队队列private val runningAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()// 正在运行的同步请求队列private val runningSyncCalls = ArrayDeque&lt;RealCall&gt;() 接下来我们看看Dispatcher的构造方法123456// 主构造方法，没写具体实现class Dispatcher constructor() &#123;&#125; constructor(executorService: ExecutorService) : this() &#123; this.executorServiceOrNull = executorService&#125; 我们可以看到他将传进来的executorService传给了executorServiceOrNull，那我们来看看executorServiceOrNull的定义：123456789101112// executorServiceOrNull这个应该是因为kotlin的空安全检查特性而定义的，本质上就是executorServiceprivate var executorServiceOrNull: ExecutorService? = null@get:Synchronized@get:JvmName("executorService") val executorService: ExecutorService get() &#123; if (executorServiceOrNull == null) &#123; executorServiceOrNull = ThreadPoolExecutor(0, Int.MAX_VALUE, 60, TimeUnit.SECONDS, SynchronousQueue(), threadFactory("OkHttp Dispatcher", false)) &#125; return executorServiceOrNull!! &#125; 我们可以看到executorService的set方法，就是创建了一个线程池。再结合他有两个构造器就知道：如果没有给Dispatcher传入一个线程池他就会自己创建一个线程池。这个线程池适合执行大量且耗时较少的任务。 构造器我们看完了，我们就来看他的enqueue()方法：12345678910111213internal fun enqueue(call: AsyncCall) &#123; synchronized(this) &#123; readyAsyncCalls.add(call) // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to // the same host. if (!call.get().forWebSocket) &#123; val existingCall = findExistingCallWithHost(call.host()) if (existingCall != null)call.reuseCallsPerHostFrom(existingCall) &#125; &#125; promoteAndExecute()&#125; 来一个请求就把他添加到就绪请求队列中去，然后就来判断forWebSocket这个属性。看到这个属性我还迷了下，有点搞不懂她是干嘛的，然后经过我的一番搜索后，发现原来OkHttp还可以进行WebSocket通信，而这个属性就是为WebSocket通信准备的。于是我就到RealCall里面找在哪儿定义了这个属性了，然后我就发现了在RealCall的newRealCall()方法这块，这个方法传入的参数中有一个Boolean值名字就叫forWebSocket。123456789101112companion object &#123; fun newRealCall( client: OkHttpClient, originalRequest: Request, forWebSocket: Boolean ): RealCall &#123; // Safely publish the Call instance to the EventListener. return RealCall(client, originalRequest, forWebSocket).apply &#123; transmitter = Transmitter(client, this) &#125; &#125;&#125; 不知道大家有没有印象，咱们在上面说过，执行OkHttpClient.newCall()方法实际上是返回了一个RealCall对象，于是在那找到了这个的答案，forWebSocket=false所以说这个if咱们不用管，直接看promoteAndExecute()方法：12345678910111213141516171819202122232425262728293031private fun promoteAndExecute(): Boolean &#123; // 不知道大家还记不记得咱们之前说的kotlin里面的check()语法， // 这个和check也一样，只不过抛出的是AssertionError异常 assert(!Thread.holdsLock(this)) // mutableListOf是kotlin里面的可变list集合 val executableCalls = mutableListOf&lt;AsyncCall&gt;() val isRunning: Boolean synchronized(this) &#123; val i = readyAsyncCalls.iterator() while (i.hasNext()) &#123; val asyncCall = i.next() if (runningAsyncCalls.size &gt;= this.maxRequests) break // 最大容量 if (asyncCall.callsPerHost().get() &gt;= this.maxRequestsPerHost) continue // 主机最大容量 i.remove() asyncCall.callsPerHost().incrementAndGet() executableCalls.add(asyncCall) runningAsyncCalls.add(asyncCall) &#125; isRunning = runningCallsCount() &gt; 0 &#125; for (i in 0 until executableCalls.size) &#123; val asyncCall = executableCalls[i] asyncCall.executeOn(executorService) &#125; return isRunning&#125; 首先将已就绪队列遍历一遍，判断正在运行的数量是不是大于定义的最大请求数，如果大于的话直接退出循环；如果不大于则在判断这个请求的主机请求数是不是大于定义的每个主机最大请求数，如果大于就跳过这个请求换下一个请求；不大于就把它调入正在运行的请求队列里面，直到遍历完成。然后判断还有没有正在运行的请求，如果有就isRunning置true。接着再取出executableCalls里的每一个元素，然后执行executteOn()方法。我们继续来看AsyncCall的executeOn()方法：1234567891011121314151617fun executeOn(executorService: ExecutorService) &#123; assert(!Thread.holdsLock(client.dispatcher)) var success = false try &#123; executorService.execute(this) success = true &#125; catch (e: RejectedExecutionException) &#123; val ioException = InterruptedIOException("executor rejected") ioException.initCause(e) transmitter.noMoreExchanges(ioException) responseCallback.onFailure(this@RealCall, ioException) &#125; finally &#123; if (!success) &#123; client.dispatcher.finished(this) // This call is no longer running! &#125; &#125;&#125; 这段代码就是在执行线程池中的线程，如果成功执行就将success置true，如果不成功，则抛异常并返回给responseCallback的onFailure()方法。并且如果没有成功执行也就是success为false，那么在finally中就会执行client.dispatcher.finished()方法:1234internal fun finished(call: AsyncCall) &#123; call.callsPerHost().decrementAndGet() finished(runningAsyncCalls, call) &#125; 这个方法先将传入的AsyncCall的callsPerHost给减1，然后再调用了finished()方法，我们再来看这个finished()方法： 12345678910111213private fun &lt;T&gt; finished(calls: Deque&lt;T&gt;, call: T) &#123; val idleCallback: Runnable? synchronized(this) &#123; if (!calls.remove(call)) throw AssertionError("Call wasn't in-flight!") idleCallback = this.idleCallback &#125; val isRunning = promoteAndExecute() if (!isRunning &amp;&amp; idleCallback != null) &#123; idleCallback.run() &#125;&#125; 他讲此次请求从runningAsyncCalls中移除，然后执行了promoteAndExecute()方法，咱们在上面说过这个方法，他的返回值就是判断当前这个运行队列中还有没有请求，如果还有就返回true，没有就false。接着一个if，判断isRunning和idleCallback的，那么如果当前这个请求还没有执行的话，就调用run()方法执行当前请求。这样每个请求都执行完毕了。那我们再来看看他的run()方法：1234567891011121314151617181920override fun run() &#123; threadName("OkHttp $&#123;redactedUrl()&#125;") &#123; var signalledCallback = false transmitter.timeoutEnter() try &#123; val response = getResponseWithInterceptorChain() signalledCallback = true responseCallback.onResponse(this@RealCall, response) &#125; catch (e: IOException) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, "Callback failure for $&#123;toLoggableString()&#125;", e) &#125; else &#123; responseCallback.onFailure(this@RealCall, e) &#125; &#125; finally &#123; client.dispatcher.finished(this) &#125; &#125;&#125; 这块调用了一个getResponseWithInterceptorChain()方法，并返回了response，并将它返回给了responseCallback.onResponse()方法。如果失败了就将结果返回给responseCallback.onFailure()方法。最后调用client.dispatcher.finished()方法。 2.1.3 Interceptor拦截器2.1.3.1 getResponseWithInterceptorChain()方法首先我们看看getResponseWithInterceptorChain()方法：12345678910111213141516171819202122232425262728293031323334@Throws(IOException::class)fun getResponseWithInterceptorChain(): Response &#123; // Build a full stack of interceptors. val interceptors = mutableListOf&lt;Interceptor&gt;() interceptors += client.interceptors interceptors += RetryAndFollowUpInterceptor(client) interceptors += BridgeInterceptor(client.cookieJar) interceptors += CacheInterceptor(client.cache) interceptors += ConnectInterceptor if (!forWebSocket) &#123; interceptors += client.networkInterceptors &#125; interceptors += CallServerInterceptor(forWebSocket) val chain = RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this, client.connectTimeoutMillis, client.readTimeoutMillis, client.writeTimeoutMillis) var calledNoMoreExchanges = false try &#123; val response = chain.proceed(originalRequest) if (transmitter.isCanceled) &#123; response.closeQuietly() throw IOException("Canceled") &#125; return response &#125; catch (e: IOException) &#123; calledNoMoreExchanges = true throw transmitter.noMoreExchanges(e) as Throwable &#125; finally &#123; if (!calledNoMoreExchanges) &#123; transmitter.noMoreExchanges(null) &#125; &#125;&#125; 首先就创建了一大堆的连接器并添加到interceptors集合中。然后创建了一个RealInterceptorChain对象，并调用了他的proceed()方法，接着主要目的就是讲proceed()返回的response给返回去。那我们就来看看RealInterceptorChain的proceed()方法： 1234567891011121314151617181920212223242526272829303132333435363738override fun proceed(request: Request): Response &#123; return proceed(request, transmitter, exchange)&#125; @Throws(IOException::class)fun proceed(request: Request, transmitter: Transmitter, exchange: Exchange?): Response &#123; if (index &gt;= interceptors.size) throw AssertionError() calls++ // If we already have a stream, confirm that the incoming request will use it. check(this.exchange == null || this.exchange.connection()!!.supportsUrl(request.url)) &#123; "network interceptor $&#123;interceptors[index - 1]&#125; must retain the same host and port" &#125; // If we already have a stream, confirm that this is the only call to chain.proceed(). check(this.exchange == null || calls &lt;= 1) &#123; "network interceptor $&#123;interceptors[index - 1]&#125; must call proceed() exactly once" &#125; // Call the next interceptor in the chain. val next = RealInterceptorChain(interceptors, transmitter, exchange, index + 1, request, call, connectTimeout, readTimeout, writeTimeout) val interceptor = interceptors[index] @Suppress("USELESS_ELVIS") val response = interceptor.intercept(next) ?: throw NullPointerException( "interceptor $interceptor returned null") // Confirm that the next interceptor made its required call to chain.proceed(). check(exchange == null || index + 1 &gt;= interceptors.size || next.calls == 1) &#123; "network interceptor $interceptor must call proceed() exactly once" &#125; check(response.body != null) &#123; "interceptor $interceptor returned a response with no body" &#125; return response &#125; 首先就是一个index，index是RealInterceptorChain构造器中传入的参数，她是第四个参数，所以我们看getResponseWithInterceptorChain()方法中创建RealInterceptorChain对象时构造器的第四个传入的值为0。然后判断index的值是不是大于interceptors的大小，如果大于就抛异常，否则就继续一顿检查！！！然后再创建RealInterceptorChain对象，此时创建的对象传入的index为此时的index+1，然后再调用interceptor的intercept()方法，并返回response。interceptor的intercept()作用是当存在多个拦截器时都会在上面代码注释1处阻塞，并等待下一个拦截器的调用返回。 2.1.3.2 Interceptor源码那现在我们再来讲几个重要的拦截器吧。OkHttp中Interceptor的实现类有： ConnectInterceptor：连接拦截器。 CallServerInterceptor：请求服务器拦截器 CacheInterceptor：缓存拦截器 BridgeInterceptor：桥梁拦截器。 其中较为重要的就是ConnectInterceptor和CallServerInterceptor，那我们来看看这两个。 2.1.3.2.1 ConnectInterceptor这个类主要用来实现网络请求连接。我们来看下他的intercept方法：123456789101112@Throws(IOException::class)override fun intercept(chain: Interceptor.Chain): Response &#123; val realChain = chain as RealInterceptorChain val request = realChain.request() val transmitter = realChain.transmitter() // We need the network to satisfy this request. Possibly for validating a conditional GET. val doExtensiveHealthChecks = request.method != "GET" val exchange = transmitter.newExchange(chain, doExtensiveHealthChecks) return realChain.proceed(request, transmitter, exchange)&#125; 这个方法先将传入的chain对象造型成了RealInterceptorChain的对象，这个类我们在上面提到过，然后调用他的response()和transmitter()方法，分别得到当前chain的response和transmitter。然后执行了request的method()方法，判断request的类型是不是GET，如果是doExtensiveHealthChecks就为false，否则为true，接着把doExtensiveHealthChecks传入transmitter的newExchange()方法中去，这个方法我们等会再说，然后再调用了proceed()方法，这个方法我们在上面说过。 2.1.3.2.2 CallServerInterceptor这个类是网络请求的本质。它的intercept方法源码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103@Throws(IOException::class) override fun intercept(chain: Interceptor.Chain): Response &#123; val realChain = chain as RealInterceptorChain val exchange = realChain.exchange() val request = realChain.request() val requestBody = request.body val sentRequestMillis = System.currentTimeMillis() // 写入请求头 exchange.writeRequestHeaders(request) var responseHeadersStarted = false var responseBuilder: Response.Builder? = null // 写入请求体信息 if (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody != null) &#123; // 如果请求上有“expect:100 continue”头 // 请等待“http/1.1 100 continue”响应，然后再传输请求主体. // 如果我们没有得到，返回我们得到的（例如4xx响应），而不传输请求体。 if ("100-continue".equals(request.header("Expect"), ignoreCase = true)) &#123; exchange.flushRequest() responseHeadersStarted = true exchange.responseHeadersStart() responseBuilder = exchange.readResponseHeaders(true) &#125; if (responseBuilder == null) &#123; if (requestBody.isDuplex()) &#123; // 准备一个双工主体，以便应用程序稍后可以发送请求主体。 exchange.flushRequest() val bufferedRequestBody = exchange.createRequestBody(request, true).buffer() requestBody.writeTo(bufferedRequestBody) &#125; else &#123; // 如果满足“expect:100 continue”预期，则编写请求正文。 val bufferedRequestBody = exchange.createRequestBody(request, false).buffer() requestBody.writeTo(bufferedRequestBody) bufferedRequestBody.close() &#125; &#125; else &#123; exchange.noRequestBody() if (!exchange.connection()!!.isMultiplexed) &#123; // 如果不满足“expect:100 continue”的要求，请防止重用HTTP/1连接。 // 否则，我们仍然有义务传输请求主体以使连接保持一致状态。 exchange.noNewExchangesOnConnection() &#125; &#125; &#125; else &#123; exchange.noRequestBody() &#125; // 结束请求 if (requestBody == null || !requestBody.isDuplex()) &#123; exchange.finishRequest() &#125; if (!responseHeadersStarted) &#123; exchange.responseHeadersStart() &#125; if (responseBuilder == null) &#123; responseBuilder = exchange.readResponseHeaders(false)!! &#125; // 读取响应头信息 var response = responseBuilder .request(request) .handshake(exchange.connection()!!.handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build() var code = response.code if (code == 100) &#123; // 服务器发送了一个100继续，即使我们没有请求。 // 再次尝试读取实际响应 response = exchange.readResponseHeaders(false)!! .request(request) .handshake(exchange.connection()!!.handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build() code = response.code &#125; exchange.responseHeadersEnd(response) // openResponseBody 获取响应体信息 response = if (forWebSocket &amp;&amp; code == 101) &#123; // 连接正在升级，但我们需要确保拦截器看到非空的响应主体。 response.newBuilder() .body(EMPTY_RESPONSE) .build() &#125; else &#123; response.newBuilder() .body(exchange.openResponseBody(response)) .build() &#125; if ("close".equals(response.request.header("Connection"), ignoreCase = true) || "close".equals(response.header("Connection"), ignoreCase = true)) &#123; exchange.noNewExchangesOnConnection() &#125; if ((code == 204 || code == 205) &amp;&amp; response.body?.contentLength() ?: -1L &gt; 0L) &#123; throw ProtocolException( "HTTP $code had non-zero Content-Length: $&#123;response.body?.contentLength()&#125;") &#125; //返回一个响应 return response&#125; 具体过程可以看代码中的注释，它主要是向服务器发送请求数据和接受服务器返回的数据。 2.1.4 TransmiterTransmitter类是OkHttp的应用层和网络层的一个桥梁类。 我们先来看看该类的初始化：12345678910111213class Transmitter( private val client: OkHttpClient, private val call: Call) &#123; private val connectionPool: RealConnectionPool = client.connectionPool.delegate private val eventListener: EventListener = client.eventListenerFactory.create(call) private val timeout = object : AsyncTimeout() &#123; override fun timedOut() &#123; cancel() &#125; &#125;.apply &#123; timeout(client.callTimeoutMillis.toLong(), MILLISECONDS) &#125; Transmitter主要的一些成员变量就这些，首先构造器中传入了两个参数，一个OkHttpClient，一个Call。然后又创建了一个连接池connectionPool，还有一个监听器，我们可以通过扩展这个类来监听程序的HTTP的调用数量、大小和持续时间。 2.1.5 RealConnection我们先看看他的一些属性：12345678910111213141516171819202122232425262728293031323334353637383940414243444546class RealConnection( val connectionPool: RealConnectionPool, private val route: Route) : Http2Connection.Listener(), Connection &#123; // 以下字段由connect（）初始化，从不重新分配。 // 底层socket private var rawSocket: Socket? = null /** * 应用层套接字。如果此连接不使用SSL，则可以是[sslsocket]分层在[rawsocket]上，也可以是[rawsocket]本身。 */ // 应用层socket private var socket: Socket? = null // 握手 private var handshake: Handshake? = null // 协议 private var protocol: Protocol? = null // http2的连接 private var http2Connection: Http2Connection? = null // 与服务器交互的输入输出流 private var source: BufferedSource? = null private var sink: BufferedSink? = null // 跟踪连接状态下的字段由连接池保护。 /** * 如果为true，则不能在此连接上创建新的交换。一旦是true的，这总是true的。 * 由[ConnectionPool]监视。 */ var noNewExchanges = false /** * 建立可能由于所选路由而导致的流时出现问题的次数。由[ConnectionPool]保护。 */ internal var routeFailureCount = 0 internal var successCount = 0 private var refusedStreamCount = 0 /** * 此连接可以承载的最大并发流数。 * 如果“allocations.size（）&lt;allocationlimit”，则可以在此连接上创建新流。 */ private var allocationLimit = 1 接下来我们看看他的connect()方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788fun connect( connectTimeout: Int, readTimeout: Int, writeTimeout: Int, pingIntervalMillis: Int, connectionRetryEnabled: Boolean, call: Call, eventListener: EventListener) &#123; check(protocol == null) &#123; "already connected" &#125; // 线路的选择 var routeException: RouteException? = null val connectionSpecs = route.address.connectionSpecs val connectionSpecSelector = ConnectionSpecSelector(connectionSpecs) if (route.address.sslSocketFactory == null) &#123; if (ConnectionSpec.CLEARTEXT !in connectionSpecs) &#123; throw RouteException(UnknownServiceException( "CLEARTEXT communication not enabled for client")) &#125; val host = route.address.url.host if (!Platform.get().isCleartextTrafficPermitted(host)) &#123; throw RouteException(UnknownServiceException( "CLEARTEXT communication to $host not permitted by network security policy")) &#125; &#125; else &#123; if (Protocol.H2_PRIOR_KNOWLEDGE in route.address.protocols) &#123; throw RouteException(UnknownServiceException( "H2_PRIOR_KNOWLEDGE cannot be used with HTTPS")) &#125; &#125; // 连接开始 while (true) &#123; try &#123; // 如果要求隧道模式，建立通道连接，通常不是这种 if (route.requiresTunnel()) &#123; connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener) if (rawSocket == null) &#123; // 我们无法连接隧道，但适当关闭了我们的资源。 break &#125; &#125; else &#123; // 一般都走这条逻辑了，实际上很简单就是socket的连接 connectSocket(connectTimeout, readTimeout, call, eventListener) &#125; // https的建立 establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener) eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol) break &#125; catch (e: IOException) &#123; socket?.closeQuietly() rawSocket?.closeQuietly() socket = null rawSocket = null source = null sink = null handshake = null protocol = null http2Connection = null eventListener.connectFailed(call, route.socketAddress, route.proxy, null, e) if (routeException == null) &#123; routeException = RouteException(e) &#125; else &#123; routeException.addConnectException(e) &#125; if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) &#123; throw routeException &#125; &#125; &#125; if (route.requiresTunnel() &amp;&amp; rawSocket == null) &#123; throw RouteException(ProtocolException( "Too many tunnel connections attempted: $MAX_TUNNEL_ATTEMPTS")) &#125; val http2Connection = this.http2Connection if (http2Connection != null) &#123; synchronized(connectionPool) &#123; allocationLimit = http2Connection.maxConcurrentStreams() &#125; &#125;&#125; 首先检查是否已经建立连接，如果已经建立就抛异常，没有的话就继续。接着就得到了ConnectionSpecs，然后根据他建立了一个connectionSpecSelector集合。接着判断是不是安全连接，也就是ssl连接，如果不是的话就判断了一些属性，先确定是不是明文然后再确定主机能不能接受明文操作。接着就开始连接，判断是不是要进行隧道通信，如果是就调用connectTunnel()建立隧道通信，如果不是就调用connectSocket()建立普通的通信。然后通过establishProtocol()建立协议。如果是HTTP/2就设置相关属性。 然后我们就来看看他具体如何实现的，先看看connectSocket()方法：12345678910111213141516171819202122232425262728293031323334353637383940414243@Throws(IOException::class)private fun connectSocket( connectTimeout: Int, readTimeout: Int, call: Call, eventListener: EventListener) &#123; val proxy = route.proxy val address = route.address // 根据代理类型选择socket类型是代理还是直连 val rawSocket = when (proxy.type()) &#123; Proxy.Type.DIRECT, Proxy.Type.HTTP -&gt; address.socketFactory.createSocket()!! else -&gt; Socket(proxy) &#125; this.rawSocket = rawSocket eventListener.connectStart(call, route.socketAddress, proxy) rawSocket.soTimeout = readTimeout try &#123; // 连接socket，之所以这样写是因为支持不同的平台 // 里面实际上是 socket.connect(address, connectTimeout); Platform.get().connectSocket(rawSocket, route.socketAddress, connectTimeout) &#125; catch (e: ConnectException) &#123; throw ConnectException("Failed to connect to $&#123;route.socketAddress&#125;").apply &#123; initCause(e) &#125; &#125; // 下面的Try/Catch块是一种避免Android 7.0崩溃的伪黑客方法 // More details: // https://github.com/square/okhttp/issues/3245 // https://android-review.googlesource.com/#/c/271775/ try &#123; // 得到输入／输出流 source = rawSocket.source().buffer() sink = rawSocket.sink().buffer() &#125; catch (npe: NullPointerException) &#123; if (npe.message == NPE_THROW_WITH_NULL) &#123; throw IOException(npe) &#125; &#125;&#125; 首先先判断连接类型，如果是直连或者HTTP连接就直连，否则的话走Socket代理，然后通过eventListener.connectStart()方法创建连接，再设定超时-&gt;完成连接-&gt;创建用于I/O的source和sink。 我们接着再来看connectTunnel()方法：123456789101112131415161718192021222324@Throws(IOException::class)private fun connectTunnel( connectTimeout: Int, readTimeout: Int, writeTimeout: Int, call: Call, eventListener: EventListener) &#123; var tunnelRequest: Request = createTunnelRequest() val url = tunnelRequest.url for (i in 0 until MAX_TUNNEL_ATTEMPTS) &#123; connectSocket(connectTimeout, readTimeout, call, eventListener) tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url) ?: break // 已成功创建隧道。 // 代理决定在身份验证质询后关闭连接。 // 我们需要创建一个新的连接，但这次需要使用身份验证凭据。 rawSocket?.closeQuietly() rawSocket = null sink = null source = null eventListener.connectEnd(call, route.socketAddress, route.proxy, null) &#125;&#125; 大体就是先创建隧道请求，然后建立socket连接，再发送请求建立隧道。 3. 请求流程图那我们最后来总结下 3.1 同步请求是如何操作的？ 3.2 异步请求是如何操作的？]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码</tag>
        <tag>kotlin</tag>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android网络请求2--解析Volley源码]]></title>
    <url>%2Fposts%2Fdf8fd75e.html</url>
    <content type="text"><![CDATA[本文大篇幅参考此篇文章，大家可以结合两篇文章看一下 1. Volley简介在很早以前，如果Android开发者想使用网络请求的话，必须自己通过HttpClient或者HttpURLConnection编写代码来访问。但是他两的用法还是很复杂的，如果不适当的封装的话，就会有很多多余代码甚至效率降低。所以当时出现了很多第三方网络通信框架，但是都是第三方的，而谷歌官方一直没有作为。最终在2013年，谷歌终于意识到了问题，于是他们推出了一个官方的全新的网络框架——Volley。Volley它又能非常简单的进行HTTP通信，又能轻松加载网络上的图片。他的设计目的就是应对数据量不大但是频发的网络操作，但是对于下载等需要大数据量的网络操作，他就不太适合。 2. 源码解析2.1 从RequestQueue入手如果你使用Volley的话，就会发现Volley不管进行什么操作，首先第一步就是先创建RequestQueue对象。所以我们就可以认定他为Volley的入口。创建RequestQueue的方法是RequestQueue mQueue = Volley.newRequestQueue(getApplicationContext());,我们就看看newRequestQueue干了什么：1234567891011121314151617181920212223242526272829public static RequestQueue newRequestQueue(Context context, BaseHttpStack stack) &#123; BasicNetwork network; if (stack == null) &#123; if (Build.VERSION.SDK_INT &gt;= 9) &#123; network = new BasicNetwork(new HurlStack()); &#125; else &#123; // 在Android 2.3之前，HttpURLConnection是不可靠的。 // 请参阅：http://android-developers.blogspot.com/2011/09/androids-http-clients.html // 在将来的某个时候，我们将把minsdkversion移到Android 2.2之上， // 并可以删除这个回退（连同所有ApacheHTTP代码）。 String userAgent = "volley/0"; try &#123; String packageName = context.getPackageName(); PackageInfo info = context.getPackageManager().getPackageInfo(packageName, /* flags= */ 0); userAgent = packageName + "/" + info.versionCode; &#125; catch (NameNotFoundException e) &#123; &#125; network = new BasicNetwork( new HttpClientStack(AndroidHttpClient.newInstance(userAgent))); &#125; &#125; else &#123; network = new BasicNetwork(stack); &#125; return newRequestQueue(context, network);&#125; 调用方法后，先查看Android版本是否大于等于2.3，如果大于则调用基于HttpURLConnection的HurlStack，否则调用基于HttpClient的HttpClientStack。接下来创建BasicNetwork并调用newRequestQueue(context, network)方，我们再来看看这个newRequestQueue()方法：1234567891011121314151617181920private static RequestQueue newRequestQueue(Context context, Network network) &#123; final Context appContext = context.getApplicationContext(); // 对缓存目录使用惰性供应商，以便可以在主线程上调用newRequestQueue（）， // 而不会导致严格的模式冲突。 DiskBasedCache.FileSupplier cacheSupplier = new DiskBasedCache.FileSupplier() &#123; private File cacheDir = null; @Override public File get() &#123; if (cacheDir == null) &#123; cacheDir = new File(appContext.getCacheDir(), DEFAULT_CACHE_DIR); &#125; return cacheDir; &#125; &#125;; RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheSupplier), network); queue.start(); return queue;&#125; 可以看到，这个方法主要为Volley创建了一个硬盘缓存DiskBasedCache，然后通过这个磁盘缓存和Network创建了一个RequestQueue对象，并调用了start()方法，接下来我们看下start()方法:123456789101112131415public void start() &#123; stop(); // 确保当前运行的所有调度程序都已停止。 // 创建缓存调度器并开始它。 mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery); mCacheDispatcher.start(); // 创建达到池大小的网络调度程序（和相应的线程）。 for (int i = 0; i &lt; mDispatchers.length; i++) &#123; NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery); mDispatchers[i] = networkDispatcher; networkDispatcher.start(); &#125;&#125; CacheDispatcher是一个缓存调度线程，并调用了start()方法。在循环中调用NetworkDispatcher的start()方法。NetworkDispatcher是网络调度线程，默认情况下mDispatchers.length为4，默认开启了4个调度线程，外加1个缓存调度线程，总共5个线程。接下来Volley会创建各种Request，并调用RequestQueue的add()方法：123456789101112131415161718192021public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) &#123; // 将请求标记为属于此队列，并将其添加到当前请求集。 request.setRequestQueue(this); synchronized (mCurrentRequests) &#123; //mCurrentRequests是一个HashSet mCurrentRequests.add(request); &#125; // 按添加的顺序处理请求。 request.setSequence(getSequenceNumber()); request.addMarker("add-to-queue"); sendRequestEvent(request, RequestEvent.REQUEST_QUEUED); // 如果请求是不可执行的，跳过缓存队列，然后直接进入网络。 if (!request.shouldCache()) &#123; mNetworkQueue.add(request); return request; &#125; mCacheQueue.add(request); return request;&#125; 这块地方的代码就很简单了，就是根据request的shouldCache()方法来返回request的mShouldCache属性来判断是否可以缓存，默认是可以的。如果能缓存，将此请求加入mCacheQueue队列，不再重复请求；不可以的话就将请求加入网络请求队列mNetworkQueue。 2.2 CacheDispatcher缓存调度线程RequestQueue的add()方法并没有请求网络或者对缓存进行操作。当将请求添加到网络请求队 列或者缓存队列时，在后台的网络调度线程和缓存调度线程轮询各自的请求队列，若发现有请求任务则开 始执行。下面先看看缓存调度线程。 首先先来看看CacheDispatcher的add()方法：123456789101112131415161718192021222324252627@Overridepublic void run() &#123; if (DEBUG) VolleyLog.v("start new dispatcher"); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); // Process.THREAD_PRIORITY_BACKGROUND默认值为10 // 进行阻塞调用以初始化缓存。 mCache.initialize(); while (true) &#123; try &#123; processRequest(); &#125; catch (InterruptedException e) &#123; // 可能被打断了，因为是时候要退出了。 if (mQuit) &#123; Thread.currentThread().interrupt(); return; &#125; VolleyLog.e( "Ignoring spurious interrupt of CacheDispatcher thread; " + "use quit() to terminate it"); // 忽略cachedispatcher线程的假中断； // 使用quit（）终止它 &#125; &#125;&#125; 这块可以看出主要就是初始化了缓存队列，然后开了个死循环，一直调用processRequest()，我们来看看这个方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182private void processRequest() throws InterruptedException &#123; // 从CacheQueue中取出一个可用的request final Request&lt;?&gt; request = mCacheQueue.take(); processRequest(request);&#125;@VisibleForTestingvoid processRequest(final Request&lt;?&gt; request) throws InterruptedException &#123; request.addMarker("cache-queue-take"); request.sendEvent(RequestQueue.RequestEvent.REQUEST_CACHE_LOOKUP_STARTED); try &#123; //request如果被取消了，就直接返回 if (request.isCanceled()) &#123; request.finish("cache-discard-canceled"); return; &#125; Cache.Entry entry = mCache.get(request.getCacheKey()); // 没有缓存就把request添加到NetworkQueue中 if (entry == null) &#123; request.addMarker("cache-miss"); // 没有缓存，并且等待队列中也没有此request，那么就直接加入到NetworkQueue中 if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123; mNetworkQueue.put(request); &#125; return; &#125; // 如果缓存过期了，也是一样把request添加到NetworkQueue中 if (entry.isExpired()) &#123; request.addMarker("cache-hit-expired"); request.setCacheEntry(entry); if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123; mNetworkQueue.put(request); &#125; return; &#125; // 有缓存并且没有过期 request.addMarker("cache-hit"); // 根据缓存的内容解析 Response&lt;?&gt; response = request.parseNetworkResponse( new NetworkResponse(entry.data, entry.responseHeaders)); request.addMarker("cache-hit-parsed"); // 是否需要更新 if (!entry.refreshNeeded()) &#123; // 不需要更新，直接将结果调度到主线程 mDelivery.postResponse(request, response); &#125; else &#123; request.addMarker("cache-hit-refresh-needed"); request.setCacheEntry(entry); response.intermediate = true; // 判断是否有相同缓存键的任务在执行 if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123; // 需要更新结果，先将结果调度到主线程，然后执行new runnable()&#123;&#125; // runnable中就是将request添加到NetworkQueue中，更新一下内容 mDelivery.postResponse( request, response, new Runnable() &#123; @Override public void run() &#123; try &#123; mNetworkQueue.put(request); &#125; catch (InterruptedException e) &#123; // Restore the interrupted status Thread.currentThread().interrupt(); &#125; &#125; &#125;); &#125; else &#123; // request已经加入到mWaitingRequests中 // 直接把结果调度到主线程 mDelivery.postResponse(request, response); &#125; &#125; &#125; finally &#123; request.sendEvent(RequestQueue.RequestEvent.REQUEST_CACHE_LOOKUP_FINISHED); &#125;&#125; 我们在processRequest中可以看到有一个方法经常出现，那就是mWaitingRequestManager.maybeAddToWaitingRequests(request)，它的作用是判断当前这个request是否有存在相同缓存键的请求已经处于运行状态，如果有，那么就将这个request加入到一个等待队列中，等到相同缓存键的请求完成。 总结一下CacheDispatcher主要步骤： 从CacheQueue中循环取出request； 如果缓存丢失，加入到NetworkQueue中； 如果缓存过期，加入到NetworkQueue中； 将缓存中的数据解析成Response对象； 如果不需要更新，直接将结果回调到主线程，回调操作等介绍完NetworkDispatcher之后一起深入剖析； 如果需要更新，先将结果回调到主线程，然后再将request加入到NetworkQueue中。 下面来看看网络调度线程。 2.3 NetWorkDispatcher网络调度线程NetworkDispatcher的run方法代码如下所示:123456789101112131415161718@Overridepublic void run() &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); while (true) &#123; try &#123; processRequest(); &#125; catch (InterruptedException e) &#123; // 我们可能被打断了，因为是时候退出了。 if (mQuit) &#123; Thread.currentThread().interrupt(); return; &#125; VolleyLog.e( "Ignoring spurious interrupt of NetworkDispatcher thread; " + "use quit() to terminate it"); &#125; &#125;&#125; 由此可以看出，NetWordDispatch和CacheDispatch非常类似。他的run()方法和CacheDispatch的方法基本一样，这就不多做介绍，下面来看看他的processRequest()方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private void processRequest() throws InterruptedException &#123; // 从NetworkQueue中取出request Request&lt;?&gt; request = mQueue.take(); processRequest(request);&#125;@VisibleForTestingvoid processRequest(Request&lt;?&gt; request) &#123; long startTimeMs = SystemClock.elapsedRealtime(); request.sendEvent(RequestQueue.RequestEvent.REQUEST_NETWORK_DISPATCH_STARTED); try &#123; request.addMarker("network-queue-take"); // 如果request被取消了，那么就不执行此request if (request.isCanceled()) &#123; request.finish("network-discard-cancelled"); request.notifyListenerResponseNotUsable(); return; &#125; addTrafficStatsTag(request); // 还记得这个mNetwork么，它就是Volley.newRequestQueue()方法里的BasicNetwork对象，一会我们来看看mNetwork.performRequest()方法是如何得到NetworkResponse的 NetworkResponse networkResponse = mNetwork.performRequest(request); request.addMarker("network-http-complete"); // notModified是服务端返回304，hasHadResponseDelivered()是request已经回调过了 if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123; request.finish("not-modified"); request.notifyListenerResponseNotUsable(); return; &#125; // 将NetworkResponse解析成Response对象，在子线程中执行 Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse); request.addMarker("network-parse-complete"); // 将request写入缓存 if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123; mCache.put(request.getCacheKey(), response.cacheEntry); request.addMarker("network-cache-written"); &#125; request.markDelivered(); // 回调结果至主线程 mDelivery.postResponse(request, response); request.notifyListenerResponseReceived(response); &#125; // 以下都是处理异常错误，然后也需要回调至主线程 catch (VolleyError volleyError) &#123; volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs); parseAndDeliverNetworkError(request, volleyError); request.notifyListenerResponseNotUsable(); &#125; catch (Exception e) &#123; VolleyLog.e(e, "Unhandled exception %s", e.toString()); VolleyError volleyError = new VolleyError(e); volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs); mDelivery.postError(request, volleyError); request.notifyListenerResponseNotUsable(); &#125; finally &#123; request.sendEvent(RequestQueue.RequestEvent.REQUEST_NETWORK_DISPATCH_FINISHED); &#125;&#125; 通过NetworkDispatcher.processRequest()方法可以发现，主要分为以下几步： 通过BasicNetwork.performRequest(request)得到NetworkResponse对象； 通过request.parseNetworkResponse(networkResponse)解析得到Response对象； 通过mDelivery将成功结果或者失败结果回调到主线程。 现在我们依次来分析这三步： 请求网络，得到NetworkResponse 我们看看BasicNetwork的performRequest()方法： 123456789101112131415161718192021222324252627@Overridepublic NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123; long requestStart = SystemClock.elapsedRealtime(); while (true) &#123; HttpResponse httpResponse = null; byte[] responseContents = null; List&lt;Header&gt; responseHeaders = Collections.emptyList(); try &#123; // Gather headers. Map&lt;String, String&gt; additionalRequestHeaders = getCacheHeaders(request.getCacheEntry()); httpResponse = mBaseHttpStack.executeRequest(request, additionalRequestHeaders); int statusCode = httpResponse.getStatusCode(); responseHeaders = httpResponse.getHeaders(); // Handle cache validation. if (statusCode == HttpURLConnection.HTTP_NOT_MODIFIED) &#123; Entry entry = request.getCacheEntry(); if (entry == null) &#123; return new NetworkResponse( HttpURLConnection.HTTP_NOT_MODIFIED, /* data= */ null, /* notModified= */ true, SystemClock.elapsedRealtime() - requestStart, responseHeaders); &#125; …………省略 通过上面源码可以看出，BasicNetwork就是封装了一下NetworkResponse，并没有涉及到网络请求，我们继续深入到BaseHttpStack.executeRequest(request, additionalRequestHeaders)源码中。123public abstract HttpResponse executeRequest( Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders) throws IOException, AuthFailureError; 这时发现这个BaseHttpStack就是一个抽象类，而这个executeRequest()也就是一个抽象方法。我当时就卡在这了，调用了一个抽象类的抽象方法，这咋操作嘛。然后我就好好再看了一遍，找到BasicNetwork的构造函数中对mBaseHttpStck定义的地方，发现这个是构造函数传进来的，然后就想到了在调用Volley.newRequestQueue()时，是根据Android版本传入了不同的Stack，那我们就来看看HurlStack.executeRequest()方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overridepublic HttpResponse executeRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders) throws IOException, AuthFailureError &#123; String url = request.getUrl(); HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.putAll(additionalHeaders); // request.getheaders（）优先于给定的附加（缓存）头. map.putAll(request.getHeaders()); if (mUrlRewriter != null) &#123; String rewritten = mUrlRewriter.rewriteUrl(url); if (rewritten == null) &#123; throw new IOException("URL blocked by rewriter: " + url); &#125; url = rewritten; &#125; URL parsedUrl = new URL(url); HttpURLConnection connection = openConnection(parsedUrl, request); boolean keepConnectionOpen = false; try &#123; for (String headerName : map.keySet()) &#123; connection.setRequestProperty(headerName, map.get(headerName)); &#125; setConnectionParametersForRequest(connection, request); // 使用来自httpurlConnection的数据初始化httpResponse。 int responseCode = connection.getResponseCode(); if (responseCode == -1) &#123; // 如果无法检索响应代码，getResponseCode（）将返回-1。 // 向呼叫者发出信号，说明连接有问题。 throw new IOException("Could not retrieve response code from HttpUrlConnection."); &#125; if (!hasResponseBody(request.getMethod(), responseCode)) &#123; return new HttpResponse(responseCode, convertHeaders(connection.getHeaderFields())); &#125; // 需要保持连接打开，直到调用方使用流。包装流，以便close（）将断开连接。 keepConnectionOpen = true; return new HttpResponse( responseCode, convertHeaders(connection.getHeaderFields()), connection.getContentLength(), new UrlConnectionInputStream(connection)); &#125; finally &#123; if (!keepConnectionOpen) &#123; connection.disconnect(); &#125; &#125;&#125; 可以看到，主要就是借助了HttpURLConnection对象来请求网络，并根据不同的条件返回不同的HttpResponse对象。 解析NetworkResponse, 得到Response：解析过程是定义在Request类中，但是他是一个抽象类，不同的Request都有自己的实现，我们现在就以JsonRequest为例看看：然后发现他又是一个抽象类，那我们就看看JsonRequest其中一个实现类JsonObjectRequest的parseNetworkResponse()方法： 123456789101112131415@Overrideprotected Response&lt;JSONObject&gt; parseNetworkResponse(NetworkResponse response) &#123; try &#123; String jsonString = new String( response.data, HttpHeaderParser.parseCharset(response.headers, PROTOCOL_CHARSET)); return Response.success( new JSONObject(jsonString), HttpHeaderParser.parseCacheHeaders(response)); &#125; catch (UnsupportedEncodingException e) &#123; return Response.error(new ParseError(e)); &#125; catch (JSONException je) &#123; return Response.error(new ParseError(je)); &#125;&#125; 这个就不用多说了，根据返回来的response建了一个String然后把这个String放到Response里面去然后再返回去。 回调主线程回调主要是通过Delivery的postResponse()方法实现的，我们来看看这个方法,找过去又找到了一个ResponseDelivery抽象类，然后又得找他的实现类，这时大家应该记得RequestQueue()的时候初始化了一个Delivery： 1234567public RequestQueue(Cache cache, Network network, int threadPoolSize) &#123; this( cache, network, threadPoolSize, new ExecutorDelivery(new Handler(Looper.getMainLooper())));&#125; 他返回了一个ExecutorDelivery，我们来看看这个类，然后就惊喜的发现，我们终于找到我们需要的东西了：123456789101112131415/** * Creates a new response delivery interface. * * @param handler &#123;@link Handler&#125; to post responses on */public ExecutorDelivery(final Handler handler) &#123; // Make an Executor that just wraps the handler. mResponsePoster = new Executor() &#123; @Override public void execute(Runnable command) &#123; handler.post(command); &#125; &#125;;&#125; 知道了它的初始化，我们再来看看它是如何实现回调的： Volley中回调是通过postResponse()方法的 : 12345678910public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response) &#123; postResponse(request, response, null);&#125;@Overridepublic void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) &#123; request.markDelivered(); request.addMarker("post-response"); mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));&#125; postResponse()最终会调用mResponsePoster对象的execute()方法，传入了一个ResponseDeliveryRunnable对象，它实现了Runnable接口，execute()方法会通过Handler.post(runnable)将ResponseDeliveryRunnable放入消息队列。最后我们来看看这个ResponseDeliveryRunnable的run()方法在主线程中做了什么操作： 12345678910111213141516171819202122232425262728293031@SuppressWarnings("unchecked")@Overridepublic void run() &#123; // If this request has canceled, finish it and don't deliver. if (mRequest.isCanceled()) &#123; mRequest.finish("canceled-at-delivery"); return; &#125; if (mResponse.isSuccess()) &#123; // 执行成功的回调，在具体的Request实现类中，比如StringRequest就会调用listener.onResponse(string)回调 mRequest.deliverResponse(mResponse.result); &#125; else &#123; // 执行失败的回调，在request中，直接回调了listener.onErrorResponse(error) mRequest.deliverError(mResponse.error); &#125; // intermediate默认为false，但是在CacheDispatcher的run()中，如果需要更新缓存，那么就会置为true if (mResponse.intermediate) &#123; mRequest.addMarker("intermediate-response"); &#125; else &#123; mRequest.finish("done"); &#125; // 如果传入了runnable不为空，那就就执行runnable.run()方法 // 回忆下在CacheDispatcher的run()方法中，如果request有缓存，但是需要更新缓存的时候，mDelivery是不是调用的带runnable的方法 if (mRunnable != null) &#123; mRunnable.run(); &#125;&#125; 3 请求流程图最后附上Volley的请求流程图]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码</tag>
        <tag>kotlin</tag>
        <tag>Volley</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统2--进程的描述和控制]]></title>
    <url>%2Fposts%2F2e847144.html</url>
    <content type="text"><![CDATA[大家可以看下我使用幕布软件画的思维导图，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员https://mubu.com/inv/477598 [TOC] 2.1 进程的描述2.1.1 进程的定义和特征2.1.1.1 进程的定义为了能够使程序并发执行，并且可以对并发执行的程序加以描述和控制，人们引入了“进程”的概念。为了使参与并发执行的每个程序都能独立地运行，操作系统必须为之配置一个专门的数据结构，称为进程数据块（PCB）。他用来纪录进程的各种属性，描述进程的动态变化过程。主要包含有进程的描述信息（进程标识符，进程名，用户标识符，进程组关系等）、进程控制信息（当前状态，优先级，代码执行入口地址，保存的磁盘地址等等）、所拥有的资源和使用情况（虚拟地址空间的状态，文件打开列表等）和CPU现场信息等内容。PCB是系统感知进程存在的唯一标志。所以一般情况下，我们把进程实体就简称为进程，创建进程，实质上是创建进程实体中的PCB；撤销进程，实质上是撤销进程的PCB。对于进程的定义，比较典型的有： 进程是程序的一次执行 进程是一个程序及其数据在处理机上顺序执行时所发生的活动 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位 2.1.1.2 进程的特征 结构性进程实体是由程序段、数据段及进程控制快三部分组成。 动态性进程的实质是进程实体的执行过程，而且进程“由创建而产生，由调度而执行，由撤销而消亡”。 并发性多个进程实体同存于内存中，且能在一段时间内同时运行。 独立性进程实体是一个能独立运行、独立获得资源和独立接收调度的基本单位。 异步性进程是按异步方式运行的。 2.1.2 进程的基本状态及转换2.1.2.1 进程的三种基本状态进程主要分为三种基本状态： 运行态指进程已经获得了CPU，他正在CPU上执行。 就绪态指进程已经准备就绪，准备好了被CPU执行的状态。如果系统中有很多处于就绪态的进程，通常把他们按一定的策略排成一个队列，这个队列称为就绪队列。 等待态指正在运行的进程由于发生某事件（如I/O请求、申请缓冲区失败等问题）暂时无法继续执行时的状态。此时引起进程调度，OS把处理机分配给就绪中的进程，让受阻的进程处于阻塞状态。 2.1.2.2 三种状态的转换 2.1.2.3 创建状态和终止状态为了满足进程控制块对数据及操作的完整性要求以及增强管理的灵活性，通常在系统中又为进程引入了两种常见的状态：创建状态和终止状态。 2.1.3 进程管理中的数据结构在最开始我已经经提到了进程控制块PCB这个东西，现在我们就进一步来了解他。 2.1.3.1 进程控制块中的作用PCB的作用主要就是使一个在多道程序环境下不能独立运行的程序称为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。 作为独立运行基本单位的标志。 当一个程序配置了PCB之后，就表示他已是一个能在多道程序环境下独立运行的、合法的基本单位，也就具有取得OS服务的权利。当系统创建一个新的进程的时候，就为他创建了一个PCB，进程结束后收回PCB。 能实现间断性运行方式。 在多道程序运行环境下，由于存在时间片或者有等待I/O请求的情况，所以进程一般都是出于走走停停的状态，当一个进程被阻塞的时候，他应该有一种能保存当前运行状态的能力也就是保护现场机制，方便在此被调度执行时恢复阻塞前的状态。所以就需要在PCB里面提供一个数据结构来保存该进程被中断时的一些信息。 提供进程管理所需要的信息。 这个就不用多说吧。 提供进程调度所需要的信息。 只有处于就绪状态的进程才能被调度执行，而在PCB中就提供了进程处于何种状态的信息。 实现与其它进程的同步与通信。 2.1.3.2 进程控制块中的信息根据上面进程控制块作用的描述，对应的进程控制块中就需要包含以下信息。 进程标识符 进程标识符用于唯一地标识一个进程。一个进程通常具有两种标识符： 外部标识符 为了方便用户（进程）对进程的访问，进程需要提供一个用于用户（进程）访问的标识符。 内部标识符 为了方便系统对进程的使用，在OS中又为进程设置了内部标识符。通常是一个进程的序号。 处理机状态 处理机状态信息也称为处理机的上下文，主要是由处理机的各种寄存器中的内容组成的。这些寄存器信息包括通用寄存器、指令寄存器、程序状态字PSW和用户栈指针。 进程调度信息 在OS进行调度的时候，必须了解进程的状态及有关进程调度的信息，这些信息包括：进程状态、进程优先级、进程调度所需其他信息（与所采用的的调度算法有关）和事件（阻塞原因）。 进程控制信息 用于进程控制所必须的信息，包括：程序和数据的地址、进程同步和通信机制、资源清单和链接指针。 2.1.3.3 进程控制块的组织方式一个系统中有很多个PCB，为了对他们进行有效的管理，应该用适当的方式将这些PCB组织起来，常用的组织方式有三种 线性方式直接将所有PCB放在一张线性表中，优点是简单，开销小，但是每次查找起来很麻烦。 链接方式把具有相同状态的PCB分别通过PCB中的链接字链接成一个队列。 索引方式根据所有进程状态的不同建立几张索引表，并把个索引表在内存的首地址纪录在内存的一些专用单元中。 2.2 进程控制2.2.1 进程的层次结构在OS中，允许一个进程创建另一个进程，通常把创建进程的进程称为父进程，被创建的进程称为子进程。然后子进程可以作为父进程继续去创建子进程，进而形成一个进程家族。 2.2.2 进程的创建每当出现了创建新进程的请求后，OS便调用进程创建原语Creat按下述步骤创建新进程： 申请空白PCB，为新进程申请获得唯一的数字标识符，并从PCB集合中索取一个空白PCB。 为新进程分配其运行所需的资源，包括各种物理和逻辑资源。 初始化进程控制块PCB。 如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。 2.2.3 进程的终止 根据被终止进程的标识符，从PCB集合中检索出进程的PCB，从中读出该进程的状态。 若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志位真，用于指示该进程被终止后应重新进行调度。 若该进程还有子孙进程，还应将其所有子孙进程也都予以终止，以防它们称为不可控的进程。 将被终止进程所拥有的的全部资源或者归还给其父进程，或者归还给系统。 将被终止进程（PCB）从所在队列（或链表）中移出，等待其他程序来搜集信息。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统1--操作系统概述]]></title>
    <url>%2Fposts%2F62248b34.html</url>
    <content type="text"><![CDATA[大家可以看下我使用幕布软件画的思维导图，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员https://mubu.com/inv/477598 现如今主流的操作系统1.1.1 PC1.1.1.1 WindowsMicrosoft Windows是微软公司推出的一系列操作系统。其问世时间为1985年，起初为运行于MS-DOS之下的桌面环境，其后续版本逐渐发展成为主要为个人计算机和服务器用户设计的操作系统，并最终获得了世界个人计算机操作系统的垄断地位。此操作系统可以在几种不同类型的平台上运行，如个人计算机、移动设备、服务器和嵌入式系统等等，其中在个人计算机的领域应用内最为普遍。Windows操作系统当前最新的稳定版是于2015年7月29日发布的 Windows 10。Windows Server当前最新的稳定版是2018年10月2日发布的Windows Server 2019。Windows Phone当前最新的稳定版是Windows10 Mobile，但是已停止开发新版本，仅对现有版本进行安全补丁和维护，直到2019年12月。 1.1.1.2 macOSmacOS（2011年及之前称Mac OS X，2012年至2015年称OS X）是苹果公司推出的基于图形用户界面操作系统，为麦金塔（Macintosh）的主操作系统。StatCounter在2018年8月的数据表示，在桌面操作系统中，macOS的使用份额为12.65%，次于Windows的82.51%位居第二。macOS当前最新的稳定版是2018年9月25日发布的macOS 10.14 Mojave，2019年6月4日推出macOS 10.15 Catalina的第一个测试版本。 1.1.1.3 LinuxLinux是一种自由和开放源码的类UNIX 操作系统。该操作系统的内核由林纳斯·托瓦兹在1991年10月5日首次发布，在加上用户空间的应用程序之后，成为 Linux 操作系统。Linux也是自由软件和开放源代码软件发展中最著名的例子。只要遵循 GNU 通用公共许可证（GPL），任何个人和机构都可以自由地使用 Linux 的所有底层源代码，也可以自由地修改和再发布。大多数 Linux 系统还包括像提供 GUI 的 X Window 之类的程序。除了一部分专家之外，大多数人都是直接使用 Linux 发行版，而不是自己选择每一样组件或自行设置。 1.1.1.4 UnixUNIX操作系统（尤尼斯），是一个强大的多用户、多任务操作系统，支持多种处理器架构，按照操作系统的分类，属于分时操作系统，最早由KenThompson、Dennis Ritchie和Douglas McIlroy于1969年在AT&amp;T的贝尔实验室开发。它的商标权由国际开放标准组织所拥有，只有符合单一UNIX规范的UNIX系统才能使用UNIX这个名称，否则只能称为类UNIX（UNIX-like）。 1.1.2 移动端1.1.2.1 AndroidAndroid，常见的非官方中文名称为安卓，是一个基于Linux内核的开放源代码移动操作系统，由Google成立的Open Handset Alliance持续领导与开发，主要设计用于触摸屏移动设备如智能手机和平板电脑与其他便携式设备。Android Inc.于2003年10月由安迪·鲁宾、利奇·米纳尔、尼克·席尔斯、克里斯·怀特在加州帕罗奥图创建。Android最初由安迪·鲁宾等人开发制作，最初开发这个系统的早期方向是创建一个数字相机的先进操作系统，但是后来发现市场需求不够大，加上智能手机市场快速成长，于是Android成为一款面向智能手机的操作系统。于2005年7月11日Android Inc.被美国科技企业Google收购。2017年3月，Android全球网络流量和设备超越Microsoft Windows，正式成为全球第一大操作系统。 1.1.2.2 iOSiOS（原名为iPhone OS）是苹果公司为其移动设备所开发的专有移动操作系统，为其公司的许多移动设备提供操作界面，支持设备包括iPhone、iPad和iPod touch。iPhone OS自iOS 4起便改名为iOS，它是继Android后全球第二大最受欢迎的移动操作系统，市占率已上升至约24.5% ，但仍远低于Google开发的Android系统的72.2%。 1.2 操作系统的简介与作用1.2.1 操作系统的简介操作系统是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。主要作用是对管理好计算机硬件设备，提高他们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单接口，便于用户使用。 1.2.2 操作系统的目的 方便性 如果一个计算机没有OS，那么他会非常难用。用户不管进行啥操作都得通过机器语言编写程序然后运行，而如果有OS的话，用户就可以使用各种各样的语言编写程序，然后通过编译将高级语言编译成机器代码，方便了用户。 有效性 有效性分两层含义——提高系统资源的利用率和提高系统的吞吐量。早期没有OS的计算机中，处理机和I/O设备等经常处于空闲状态，各种资源不能得到合理利用，所以提高系统资源利用率是推动OS发展的主要动力。另一方面，OS可以通过合理组织计算机的工作流程，加速程序的运行，缩短程序的运行周期，从而提高系统的吞吐量。 可扩充性 为了适应现在越来越多的计算机硬件以及体系结构，OS必修有良好的可扩充性。 开放性 OS需要遵循世界标准规范，凡遵循国际标准所开发的硬件和软件都能彼此兼容，方便地实现互联。 1.2.3 操作系统的作用 OS作为用户与计算机硬件系统之间的接口 OS处于用户和硬件之间，方便用户通过OS使用硬件。或者说，用户在OS的帮助下能够方便、快捷、可靠地操纵计算机硬件和运行自己的程序。 OS作为计算机系统资源的管理者 计算机系统资源主要可分为处理机、存储器、I/O设备以及文件。OS主要功能也就是对这四类资源进行有效的管理。处理机管理是用于分配和控制处理机；存储器管理主要负责内存的分配与回收；I/O设备管理是负责I/O设备的分配与操纵；文件管理是用于实现对文件的存取、共享和保护。 OS实现了对计算机资源的抽象 在裸机中，用户如果想要对计算器进行操作，必须对物理接口的实现细节有充分的了解。但在操作系统中，用户并不需要关心具体的物理，而由操作系统来实现具体的操作细节，并向上讲操作设备抽象为一组数据结构以及一组操作命令。此时在用户眼里，看到的是一台比裸机功能更强，使用更方便的机器。 1.2.4 推动操作系统发展的主要动力 不断提高计算机资源利用率 方便用户 器件的不断更新换代 计算机体系结构的不断发展 不断提出新的应用需求 1.3 操作系统的发展1.3.1 单道批处理系统在说单道批处理之前现要引入一个概念——作业。作业包括用户程序、数据、作业说明书。这样每一个处理对象都是作业。 1. 处理过程每个单道批处理系统都有一个系统操作员。用户先将作业交给系统操作员，然后操作系统操作员就将一个个作业组成一批作业，输入到计算机中，在系统中形成一个自动转接的作业流，然后启动操作系统对作业自动、依次的处理，处理完成后再将处理结果返回给系统操作员，操作员在返回给用户。这样就形成了一个单道批处理过程。 2. 缺点系统资源得不到充分利用。这是因为在内存中仅有一道程序，每逢程序在运行中发出I/O请求后，CPU便处于等待状态，必须在I/O完成后才继续运行。 1.3.2 多道批处理系统1. 处理过程在该系统中，用户所提交的作业先放在外存中，并排成一个队列，称为“后备队列“。然后由作业调度程序按一定的算法，从后备队列中选择若干作业调入内存。由于同时在内存中装有若干道程序，这样便可以在运行程序A时，利用其I/O操作暂停执行时的CPU空档期，再调度另一道程序B运行。 2. 优缺点 优点 资源利用率高 系统吞吐量大 缺点 平均周转时间长 无交互能力 1.3.3 分时系统1. 运行方式 作业直接进入内存。因为作业在磁盘上不可运行，所以作业应直接进入内存 采用轮转运行方式。如果一个作业独占CPU连续运行，那么其他作业没法运行。为了避免这种情况，引入了时间片概念。一个时间片是一个很短的时间，系统规定了每个作业每次只能运行一个时间片，然后就暂停该作业的运行，并立即调度下一个作业运行。如果在不长的时间内能使所有的作业都执行一个时间片的时间，便可以使每个用户都能及时地与自己的作业进行交互，从而使用户的请求的到及时响应。 2. 特征 多路性 独立性 及时性 交互性 1.3.4 实时系统实时系统是指系统能及时响应外部事件的请求，在规定时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。实时系统主要应用于： 工业（武器）控制系统 信息查询系统 多媒体系统 嵌入式系统 1.4 操作系统的基本特征1.4.1 并发正是系统中有这一特征，才使得OS能有效地提高系统中的资源利用率，增加系统的吞吐量。 并发与并行并行是指两个或多个事件在同一时刻发生，微观上是同一时刻多个线程在CPU上运行。并发是指宏观上两个或多个事件在同一时间发生，微观上缺是某一时刻CPU上只有一个进程。 1.4.2 共享资源共享，即操作系统中的资源可供多个并发执行的进程共同使用，由于资源属性不同，多个进程对资源的共享方式也不同。可分为：互斥共享方式和同时访问方式。 1. 互斥共享方式一段时间内只允许一个进程访问该资源，如磁带机,打印机等。虽然可以供多个进程使用，但是为了打印或记录结果不造成混淆，应规定一段时间内只允许一个进程访问该资源。 2. 同时访问方式某些资源，一段时间内是可以允许多个进程“同时”同时对他们进行访问，这个同时是宏观上的，在微观上可能是分时共享。 1.4.3 虚拟在OS中，把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为”虚拟“。 1.4.4 异步在多道环境下，允许多个程序并发执行。但由于资源有限，进程的执行不是一贯到底。而是走走停停，以不可预知的速度向前推进，这就是进程的异步。 1.5 操作系统的主要功能操作系统的主要功能应分为处理机管理、存储器管理、设备管理和文件管理。此外，还应向用户提供方便的用户接口。 1.5.1 处理机管理功能1. 进程控制在多道程序环境中，为了使作业能并发执行，必须为每道作业创建一个或几个进程，并为之分配必要的资源。当进程运行结束时，应立即撤销该进程，以便能及时回收该进程所占用的各种资源，供其它进程使用。 2. 进程同步为了使多个进程能有条不紊的运行，系统中必须设置相应的进程同步机制。该机制的主要任务是为多个进程的运行进行协调。 3. 进程通信如果一组相互合作的进程去完成一个共同的任务时，在他们之间往往需要交换信息。 4. 调度在传统OS中，调度包括作业调度和进程调度。 作业调度 作业调度的基本任务就是从后备队列中按照一定的算法选择出若干个作业，为他们分配所需资源，在这些作业调入内存后，分别为他们创建进程，是他们都称为可能获得处理机的就绪进程，并将他们插入就绪队列中。 进程调度 进程调度的任务是从进程的就绪队列中按照一定的算法选出一个进程，将处理机分配给他，并为他设置运行线程，使其投入执行。 1.5.2 存储器管理功能存储器管理视为多道程序的运行提供良好的环境，提高存储器利用率，并能从逻辑上扩充内存。为此，存储器管理应具有内存分配和回收、内存保护、地址映射和内存扩充等功能。 1. 内存分配内存分配主要任务是： 为每道程序分配内存空间 提高存储器的利用率，尽量减少不可用的内存空间 允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需要。 OS在实现内存分配时，可采取静态和动态两种方式： 静态分配内存。每个作业的内存空间在作业装入时确定，确定后不再改变。 动态分配内存。每个作业所要求的的基本内存空间虽然也是在装入时确定的，但允许作业在运行过程中继续申请新的附加内存空间，以适应程序和数据的动态增长。 2. 内存保护确保每道用户程序都在自己的内存空间内运行，彼此互不干扰。决不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其他用户程序中去执行。 3. 地址映射每道程序经编译连接后所形成的的可装入程序其地址都是从0开始的，但是不可能将他们从“0”地址开始装入内存，所以物理地址和逻辑地址并不一致，这时候就需要地址映射来让程序能正常运行。 4. 内存扩充借助虚拟存储技术来实现内存扩充，主要解决： 内存和I/O之间速度不匹配的问题 如果内存空间不足的问题 1.5.3 设备管理功能主要任务： 完成用户进程提出的I/O请求，为用户进程分配所需的I/O设备，并完成指定的I/O操作 提高CPU与I/O设备的利用率，提高I/O速度，方便用户使用I/O 为了实现以上功能，应具有缓冲管理、设备分配和设备处理以及虚拟设备等功能。 1. 缓冲管理为了有效的缓和CPU与I/O设备间速度不匹配的问题，提高CPU利用率，于是引入了缓冲管理。 2. 设备分配设备分配的基本任务是根据用户进程的I/O请求、系统现有资源情况以及按照某种设备分配策略，为之分配其所需的设备。 3. 设备处理实现CPU和设备控制器之间的通信，即由CPU向设备控制器发出I/O命令，要求他完成指定的I/O操作；反之，由CPU控制从接收器发来的中断请求，并给予迅速的响应和相应的处理。 1.5.4 文件管理功能主要是对用户文件和系统文件进行管理以方便用户使用，并保证文件的安全性。为此，文件管理应具有对文件存储空间管理、目录管理、文件的读/写管理以及文件的共享与保护等功能。 1. 文件存储空间的管理为每个文件分配必要的外存空间，提高我村利用率，进而提高文件系统的存、取速度。 2. 目录管理为每个文件建立一个目录项，目录项包括文件名、文件属性、文件在磁盘上的物理位置等，并对众多的目录项加以有效的组织，以实现方便的按名字存取。 3. 文件的读/写管理和保护根据用户的请求，从外存中读取数据或将数据写入外存。并且保护文件防止其被非法盗取和破坏。 1.5.5 操作系统与用户间的接口接口主要分为两大类：用户接口和程序接口。用户接口是供用户调用，方便用户直接或间接控制自己的作业。程序接口是为用户程序在执行中访问系统资源而设定的，是用户取得操作系统服务的唯一途径。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android多线程2--Java中的线程池]]></title>
    <url>%2Fposts%2Fb39fd0ab.html</url>
    <content type="text"><![CDATA[简介我们在写项目经常要用到多线程。但是线程的创建和摧毁都是较消耗资源和性能的，如果你每需要一个任务就新建一个线程，那可能会在线程的创建和摧毁上浪费掉很多资源。那如果我们让线程执行任务后不摧毁，接着执行下一个任务，这样是不是就能避免这种情况了。Java1.5中提供了Executor框架用于把任务的提交和执行解耦，任务的执行就交给Runnable或者Callable，而Executor框架用于处理任务。Executor中最核心的成员就是ThreadPoolExecutor，他就是线程池核心实现类。 ThreadPoolExecutor我们现在先来看下这个方法。构造器：123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,markdownlint long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 我们来看下这些参数： corePoolSize：核心线程数。线程池刚创建的时候，线程数量为0，只有任务提交的时候才会创建线程。如果当前线程数量小于corePoolSize，则创建新线程；如果等于或者大于，则不再创建。 maximumPoolSize：线程池允许创建的最大线程数。当workQueue满了而且线程数小于maximumPoolSize时，线程池仍会创建新的线程。但是如果超过了maximumPoolSize时，则会抛出异常。 keepAliveTime：非核心线程闲置的超过时间。当线程池中线程数量大于workQueue，如果一个线程的空闲时间大于keepAliveTime，则该线程会被回收。如果任务很多，并且每个任务 的执行事件很短，则可以调大keepAliveTime来提高线程的利用率。另外，如果设置 allowCoreThreadTimeOut属性为true时，keepAliveTime也会应用到核心线程上。 timeUnit：keepAliveTime参数的时间单位。可选的单位有天(DAYS)、小时(HOURS)、分钟(MINUTES)、秒(SECONDS)、毫秒(MILLISECONDS)等。 workQueue：任务队列。如果当前线程数大于corePoolSize，则将任务添加到此任务队列中。该任务 队列是BlockingQueue类型的，也就是阻塞队列。 threadFactory：线程工厂。可以用线程工厂给每个创建出来的线程设置名字。一般情况下无须设置该参数。 RejectedExecutionHandler：饱和策略。这是当任务队列和线程池都满了时所采取的应对策略，默认是AbordPolicy，表示无法处理新任务，并抛出RejectedExecutionException异常。此外还有3种策略，它们分别如下: CallerRunsPolicy：用调用者所在的线程来处理任务。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。 DiscardPolicy：不能执行的任务，并将该任务删除。 DiscardOldestPolicy：丢弃队列最近的任务，并执行当前的任务。 线程池的处理流程线程池的任务处理主要分为3个步骤 提交任务后，线程池先判断线程数是否达到了核心线程数corePoolSize。如果未达到核心线程数，则创建核心线程处理任务；否则，就执行下一步操作。 接着线程池判断任务队列是否满了。如果没满，则将任务添加到任务队列中；否则，就执行下一步操作。 接着因为任务队列满了，线程池就判断线程数是否达到了最大线程数。如果未达到，则创建非核心线程处理任务；否则，就执行饱和策略，默认会抛出RejectedExecutionException异常。 如果线程池中的线程数未达到核心线程数，则创建核心线程处理任务。 如果线程数大于或者等于核心线程数，则将任务加入任务队列，线程池中的空闲线程会不断地从 任务队列中取出任务进行处理。 如果任务队列满了，并且线程数没有达到最大线程数，则创建非核心线程去处理任务。 如果线程数超过了最大线程数，则执行饱和策略。 线程池的种类CachedThreadPool：可缓存线程池 线程数无限制 有空闲线程则复用空闲线程，若无空闲线程则新建线程 一定程序减少频繁创建/销毁线程，减少系统开销 创建源码：12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; CachedThreadPool的corePoolSize为0，maximumPoolSize设置为Integer.MAX_VALUE，这意味着CachedThreadPool没有核心线程，非核心线程是无界的。keepAliveTime设置为60L，则空闲线程等待新任务 的最长时间为60s。在此用了阻塞队列SynchronousQueue，它是一个不存储元素的阻塞队列，每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都等待另一个线程的插入操作。 FixedThreadPool：定长线程池 可控制线程最大并发数（同时执行的线程数） 超出的线程会在队列中等待 创建源码：12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; FixedThreadPool的corePoolSize和maximumPoolSize都设置为创建FixedThreadPool指定的参数nThreads，也就意味着FixedThreadPool只有核心线程，并且数量是固定的，没有非核心线程。keepAliveTime设置为0L意味着多余的线程会被立即终止。因为不会产生多余的线程，所以keepAliveTime是无效的参数。另外，任务队列采用了无界的阻塞队列LinkedBlockingQueue。 ScheduledThreadPool：定长线程池支持定时及周期性任务执行。 创建源码：1234public static ScheduledExecutorService newScheduledThreadPool( int corePoolSize, ThreadFactory threadFactory) &#123; return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);&#125; 我们可以看到在创建源码中他跳转到了ScheduledThreadPoolExecutor的构造方法，我们继续看进去：123456public ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue(), threadFactory);&#125; 从上面的代码可以看出，ScheduledThreadPoolExecutor的构造方法最终调用的是ThreadPoolExecutor的构造方法。corePoolSize是传进来的固定数值，maximumPoolSize的值是Integer.MAX_VALUE。因为采用的DelayedWorkQueue是无界的，所以maximumPoolSize这个参数是无效的。 SingleThreadExecutor：单线程化的线程池 有且仅有一个工作线程执行任务 所有任务按照指定顺序执行，即遵循队列的入队出队规则 创建源码：123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; corePoolSize和maximumPoolSize都为1，意味着SingleThreadExecutor只有一个核心线程，其他的参数都和FixedThreadPool一样，这里就不赘述了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next配置备份]]></title>
    <url>%2Fposts%2F5b6e53a4.html</url>
    <content type="text"><![CDATA[Hexo配置备份 评论系统 来必力 - https://www.livere.com/ valine(在用) - https://valine.js.org/ 阅读量显示 leancloud - https://leancloud.cn/ valine(在用) - https://valine.js.org/]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android多线程1--Java中的阻塞队列]]></title>
    <url>%2Fposts%2F63ab42b7.html</url>
    <content type="text"><![CDATA[阻塞队列前言在谈论阻塞队列之前我们先看下操作系统多线程部分一个经典的例子——生产者和消费者问题： 现在有两个进程，一个是生产者一个是消费者，还有一个线程缓冲区。生产者主要作用就是向缓冲区中添加数据，消费者就是从缓冲区中取出数据。这个问题的核心就是如何确保生产者不会在缓冲区满了的时候还往其中添加元素，消费者不会在缓冲区空了的时候还要求取出数据。 关于这个问题的解决办法我们以后再说，我们现在主要讨论线程缓冲区——阻塞队列。 阻塞队列简介阻塞队列就是队列，只是在一般的队列上添加了两个条件： 当队列满了的时候不允许再添加数据 当队列空了的时候不允许从中取数据 在Java中，阻塞队列是通过BlockingQueue来实现的，BlockingQueue是Java.util.concurrent包下一个重要的数据结构。 BlockingQueue的操作方法 方法 抛异常 返回特定值 阻塞 超时 插入 add(E e) offer(E e) put(E e) offer(E e, long timeout, TimeUnit unit) 移除 remove() poll() take() poll(time, unit) 检查 element() peek() 不可用 不可用 解释： 抛异常：如果操作无法执行，则抛出一个异常 特定值：如果操作无法执行，则返回一个特定的值 阻塞： 如果操作无法执行，则方法调用被阻塞，直到可以执行 超时：如果操作无法执行，则方法调用被阻塞，直到可以执行或者超过限定的时间。返回一个特定值以告知该操作是否成功(典型的是true / false)。 Java中的各种阻塞队列Java基于BlockingQueue给开发者提供了7个阻塞队列： ArrayBlockingQueue：基于数组的有界阻塞队列。有界就意味着他有一个最大限度，所存储的线程的数量不能超过这个限定值。你也可以在对其初始化的时候给定这个限定值。但是由于它是基于数组所以他和数组一样，在初始化的时候限定了这个大小以后就不能改变。 LinkedBlockingQueue：基于链表的阻塞队列。它内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用Integer.MAX_VALUE作为上限。LinkedBlockingQueue内部以FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。由于默认是无上限的，所以在使用他的时候，如果生产者的速度大于消费者的速度，系统内存可能会被耗尽。所以使用他一定要设置初值。 PriorityBlockingQueue：支持优先级的无界队列。默认情况按照自然顺序生序排列，你可以重写compateTo()方法来制定元素按规定排序。 DelayQueue：支持延时获取元素的无界阻塞队列。队列中的元素必须实现Delayed接口。 SynchromousQueue：是一个特殊的队列。他不能存储任何元素，他的每一次插入操作必须等待另一个线程相应的删除操作，反之亦然。 LinkedTransferQueue：基于链表的无界阻塞TransferQueue队列。相对于其他队列，他多了transfer(E e)、tryTransfer(E e) 和 tryTransfer(E e, long timeout, TimeUnit unit)方法。 LinkedBlockingDeque：是一个链表结构的双向阻塞队列。可在两端入队出对。所以当多线程入队时，减少了一半的竞争。 阻塞队列实现原理下面我们以ArrayBlockingQueue源码为例，来看下阻塞队列实现原理： 定义首先就是一堆变量的定义：123456789101112131415161718192021222324252627/** The queued items */final Object[] items;/** items index for next take, poll, peek or remove */int takeIndex;/** items index for next put, offer, or add */int putIndex;/** Number of elements in the queue */int count;/* * Concurrency control uses the classic two-condition algorithm * found in any textbook. *//** Main lock guarding all access */final ReentrantLock lock;/** Condition for waiting takes */privatefinal Condition notEmpty;/** Condition for waiting puts */privatefinal Condition notFull; items是存储队列元素的数组，takeIndex和putIndex分别是取数据和存数据的索引，count是队列中元素个数，lock为看一个可重入锁，notEmpty和notFull均为等待条件，由lock创建。 构造器接下来看下它的构造器12345678public ArrayBlockingQueue(int capacity) &#123;&#125;public ArrayBlockingQueue(int capacity, boolean fair) &#123; &#125;public ArrayBlockingQueue(int capacity, boolean fair, Collection&lt;? extends E&gt; c) &#123;&#125; 构造器有三个重载的版本，第一个构造器只有一个参数用来指定容量，第二个构造器多了一个参数来指定访问策略，第三个构造器又多了一个参数可以指定用另外一个集合进行初始化。 数据的添加接下来我们看看BlockingQueue的三个插入的方法：put()、add()和offer()： put() 方法：队列满，会阻塞调用存储元素的线程 1234567891011121314151617public void put(E e) throws InterruptedException &#123; // 先检查e是不是空，如果空则抛异常 Objects.requireNonNull(e); // 获取一个重入锁lock final ReentrantLock lock = this.lock; // 加锁，保证调用put方法的时候只有1个线程 lock.lockInterruptibly(); try &#123; // 如果线程中的元素数量是否等于当前数组的长度，如果相等则调用await方法等待，如果不相等则enqueue方法插入元素 while (count == items.length) notFull.await(); enqueue(e); &#125; finally &#123; // 解锁 lock.unlock(); &#125;&#125; add()方法：实际上调用了offer()方法 123456public boolean add(E e) &#123; if (offer(e)) return true; else throw new IllegalStateException("Queue full");&#125; offer()方法：成功返回true，失败返回false 1234567891011121314151617181920public boolean offer(E e) &#123; // 检查e是否为空 Objects.requireNonNull(e); // 获取重入锁lock final ReentrantLock lock = this.lock; // 加锁 lock.lock(); try &#123; // 如果如果线程中的元素数量是否等于当前数组的长度，如果相等则调返回false，如果不相等则enqueue方法插入元素并返回true if (count == items.length) return false; else &#123; enqueue(e); return true; &#125; &#125; finally &#123; // 解锁 lock.unlock(); &#125;&#125; 以上三个方法都调用了enqueue()方法。下面我们就来看看这个方法：123456789101112131415/** * Inserts element at current put position, advances, and signals. * Call only when holding lock. */private void enqueue(E e) &#123; // assert lock.isHeldByCurrentThread(); // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; final Object[] items = this.items; items[putIndex] = e; if (++putIndex == items.length) putIndex = 0; count++; notEmpty.signal();&#125; 先获取元素数组items，然后添加putIndex上，如果++putIndex等于items的长度，则证明当前这个items所有元素都添加进了，就让putIndex等于0.然后调用notEmpty.signal()方法唤醒正在获取元素的线程，让他们从队列中取数据。 数据的取出ArrayBlockingQueue的取数据方法总共也有三个方法：poll()、take()和remove() poll()方法：获取元素，存在返回元素e,不存在返回null 12345678910111213public E poll() &#123; // 获取重入锁lock final ReentrantLock lock = this.lock; // 加锁 lock.lock(); try &#123; // 如果元素数量等于0就返回null，否则调用dequeue()方法 return (count == 0) ? null : dequeue(); &#125; finally &#123; // 解锁 lock.unlock(); &#125;&#125; take()方法：取元素。如果队列为空,则会阻塞调用获取元素的线程 123456789101112131415public E take() throws InterruptedException &#123; // 获取重入锁lock final ReentrantLock lock = this.lock; // 加锁 lock.lockInterruptibly(); try &#123; // 如果线程中的元素数量是否等于0，如果相等则调用await方法等待，如果不相等则dequeue方法删除元素 while (count == 0) notEmpty.await(); return dequeue(); &#125; finally &#123; // 解锁 lock.unlock(); &#125;&#125; remove()方法：取元素，它是取特定的那个元素 1234567891011121314151617181920212223242526public boolean remove(Object o) &#123; // 判断o是否为空 if (o == null) return false; // 获取重入锁lock final ReentrantLock lock = this.lock; // 加锁 lock.lock(); try &#123; // 如果元素数量大于0，则获取items，然后便利元素，判断o是其中的哪个，然后删除那个 if (count &gt; 0) &#123; final Object[] items = this.items; for (int i = takeIndex, end = putIndex, to = (i &lt; end) ? end : items.length; ; i = 0, to = end) &#123; for (; i &lt; to; i++) if (o.equals(items[i])) &#123; removeAt(i); return true; &#125; if (to == end) break; &#125; &#125; return false; &#125; finally &#123; // 解锁 lock.unlock(); &#125;&#125; poll()和take()两个方法都调用了dequeue()方法，我们就看下dequeue()是如何来实现的：12345678910111213141516171819/** * Extracts element at current take position, advances, and signals. * Call only when holding lock. */private E dequeue() &#123; // assert lock.isHeldByCurrentThread(); // assert lock.getHoldCount() == 1; // assert items[takeIndex] != null; final Object[] items = this.items; @SuppressWarnings("unchecked") E e = (E) items[takeIndex]; items[takeIndex] = null; if (++takeIndex == items.length) takeIndex = 0; count--; if (itrs != null) itrs.elementDequeued(); notFull.signal(); return e;&#125; 和上面的enqueue()方法类似，再次就不再赘述。 阻塞队列的应用前面我说过，阻塞队列主要用在生产者和消费者模式中，那下面我们就来写一个简单的小demo 这段代码来自刘望舒所著《Android进阶之光》 如果不用阻塞队列：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.PriorityQueue;public class Test &#123; private int queueSize = 10; private PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(queueSize); public static void main(String[] args) &#123; Test test = new Test(); Producer producer = test.new Producer(); Consumer consumer = test.new Consumer(); producer.start(); consumer.start(); &#125; class Consumer extends Thread &#123; @Override public void run() &#123; while (true) &#123; synchronized (queue) &#123; while (queue.size() == 0) &#123; try &#123; System.out.println("队列空，等待数据"); queue.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); queue.notify(); &#125; &#125; // 每次移走队首元素 queue.poll(); queue.notify(); &#125; &#125; &#125; &#125; private class Producer extends Thread &#123; @Override public void run() &#123; while (true) &#123; synchronized (queue) &#123; try &#123; System.out.println("队列满，等待有空余空间"); queue.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); queue.notify(); &#125; &#125; // 每次插入一个元素 queue.offer(1); queue.notify(); &#125; &#125; &#125;&#125; 使用阻塞队列ArrayBlockingQueue：12345678910111213141516171819202122232425262728293031323334353637383940import java.util.concurrent.ArrayBlockingQueue;public class BlockingQueueTest &#123; private int queueSize = 10; private ArrayBlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;&gt;(queueSize); public static void main(String[] args) &#123; BlockingQueueTest test = new BlockingQueueTest(); BlockingQueueTest.Producer producer = test.new Producer(); BlockingQueueTest.Consumer consumer = test.new Consumer(); producer.start(); consumer.start(); &#125; class Consumer extends Thread &#123; @Override public void run() &#123; while (true) &#123; try &#123; queue.take(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; private class Producer extends Thread &#123; @Override public void run() &#123; while (true) &#123; try &#123; queue.put(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin入门1:Kotlin和Java区别基础篇]]></title>
    <url>%2Fposts%2F343b01ae.html</url>
    <content type="text"><![CDATA[Koltin入门Kotlin简介 科特林岛(Котлин)是一座俄罗斯的岛屿,位于圣彼得堡以西约30公里处,形状狭长,东西长度约14公里,南北宽度约2公里,面积有16平方公里,扼守俄国进入芬兰湾的水道。科特林岛上建有喀琅施塔得市,为圣彼得堡下辖的城市。 而我们虽说的kotlin，就是一门根据它命名的一种现代程序设计语言。Kotlin 是一个用于现代多平台应用的静态编程语言，由 JetBrains 开发。Kotlin可以编译成Java字节码，也可以编译JavaScript，方便在没有JVM的设备上运行。Kotlin已正式成为Android官方支持开发语言。 变量kotlin和Java的最基本的区别就是kotlin中万物皆对象，Java中还存在着int、float等基本类型，但是在kotlin中，它把这些都定义成了对象，类似于Java中的封装类 变量的声明上面说了，kotlin万物皆对象，所以所有的变量也都是对象。在kotlin定义对象和Java有点小区别。kotlin定义对象的格式为 声明类型 变量名： 变量类型 其中： 声明类型分为val和var。val是不可变类型，类似于const，定义时必须赋值，赋值后不能被修改。var是可变类型。 变量名就是你定义的这个变量的名称。 变量类型就是你这个变量对应的类的名字。 类型推断省去变量类型kotlin里面类似c++的auto类型，对于基本类型，你可以不写变量类型，kotlin会自动帮你判断。 1234567891011var a = 5println(a is Int)var b = “123println(b is String)var c = 1.3println(c is Float)var d = trueprintln(d is Boolean) is关键字is顾名思义，就是判断这个变量是不是这个类型的实例。例子见上。 数字类型 类型 宽度(bit) Byte 8 Short 16 Int 32 Long 64 Float 32 Double 64 这些类型都继承自Number和Comparable类。 字面常量值 十进制：123 十六进制：0x0f 二进制：0b0010 Long类型：123L double类型：123.4 Float类型：123.4f或者123.4F 我们也可以使用下划线_来方便我们阅读 121_000_000 // 10000000xFF_EC // 0xFFEC 显示转换kotlin中不可隐式转换比如Java 中 12int a = 2;long b = a; 但是在kotlin中 123var a : Int? = 2var b : Long? = a; // errorvar b : Long? = a.toLong() Char类型kotlin中的Char表示字符。但是和Java不同，他不能直接当ASCII码值。 12345fun check(c : Char) &#123; if (c == 1) &#123; // error &#125;&#125; Boolean类型kotlin中的布尔类型用Boolean来表示，他有两个值true和false。用法和Java一样。 String类型和Java一样，kotlin中的字符串也是String。但是kotlin中String是不可变的。所以kotlin中String必须是val类型。同时，String是final不可继承的。 Array类型kotlin中数组必须使用Array表示。基本写法 val array: Array&lt;类型&gt; = arrayOf(..) 例如12345678910111213141516171819202122232425262728293031/**整型Int的数组*/val arrayOfInt: IntArray = intArrayOf(1,3,5,7,9)/**字符Char类型的数组*/val arrayOfChar: CharArray = charArrayOf('H','e','l','l','o','W','o','r','l','d')/**字符串String数组*/val arrayOfString: Array&lt;String&gt; = arrayOf("Hello","World")fun main(args: Array&lt;String&gt;) &#123; //查看有多少个元素 println(arrayOfInt.size) //遍历数组 for (char in arrayOfChar)&#123; println(char) &#125; //根据所引获取数据,数组是从0开始的，现在获取第二个东京大学 println(arrayOfUniversity[1]) //重新给数组赋值，早稻田大学 arrayOfUniversity[1] = University("早稻田大学") println(arrayOfUniversity[1]) //将char连接成一个字符串,默认是自动由逗号","分割的，输出H, e, l, l, o, W, o, r, l, d println(arrayOfChar.joinToString()) //如果想要连成HelloWorld println(arrayOfChar.joinToString ("")) //数组的切片,输出3，5,结尾需要arrayOfInt-1，不然会报索引越界异常 println(arrayOfInt.slice(1..2)) println(arrayOfInt.size)&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin Anko入门]]></title>
    <url>%2Fposts%2F62bb1dd7.html</url>
    <content type="text"><![CDATA[Kotlin Anko入门简介Anko的官网就是他的GitHub地址 https://github.com/Kotlin/anko 官方对Anko的解释是 Anko是一个 Kotlin 库，它使Android应用程序开发更快更容易。它使您的代码清晰易读，让您忘记Android SDK for Java的粗糙边缘。 为什么这样说呢？比方说如果你写Android，你在xml中定义了一个Button，他的ID是button_login。如果是Java：12setContentView(R.layout.activity_words_detail);Button button = findViewById(R.Id.button_login); 而如果你使用kotlin的话，你可以就按如下代码写123import kotlinx.android.synthetic.main.activity_kotlin_main.*...button_login.setText("Kotlin Android Extensions 我不太喜欢"); 这样确实比Java方便多了，不需要对每一个组件都定义再findViewById，可以就直接输入组件的id然后就能使用了。但是我们还是觉得不够啊，为什么我们不能就直接在代码中写入各个组件呢，于是，Anko来了。 导入AnkoAnko由几部分组成： Anko Commons：一个轻量级的库，包含用于Layouts，Intent，Log等的帮助程序; Anko Layouts：一种快速且类型安全的方式来编写动态Android布局; Anko SQLite：Android SQLite的查询DSL和解析器集合; Anko Coroutines：基于kotlinx.coroutines库的实用程序。 你可以在app的build.gradle中添加12345678dependencies &#123; // Anko Layouts implementation "org.jetbrains.anko:anko-sdk25:$anko_version" // sdk15, sdk19, sdk21, sdk23 are also available implementation "org.jetbrains.anko:anko-appcompat-v7:$anko_version" // Coroutine listeners for Anko Layouts implementation "org.jetbrains.anko:anko-sdk25-coroutines:$anko_version" implementation "org.jetbrains.anko:anko-appcompat-v7-coroutines:$anko_version"&#125; 这个依赖可以直接导入所有的可用特性（包括Commons, Layouts, SQLite)。 使用Anko layout创建简单布局使用Anko创建布局很简单： 12345678910111213141516171819class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) verticalLayout &#123; padding = dip(30) editText &#123; hint = "Name" textSize = 24f &#125; editText &#123; hint = "Password" textSize = 24f &#125; button("登录") &#123; textSize = 26f &#125; &#125; &#125;&#125; 你只需要在Activity中写入DSL代码就能使用它。 AnkoComponent尽管我们现在可以直接在Activity中写入DSL代码，但是我们还是觉得把代码和布局文件放在一起不太好，希望把Activity和DSl代码放到两个不同的类里面，所以AnkoComponent就出来了。代码如下12345678910111213141516171819202122232425class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) MainActivityUI().setContentView(this) &#125;&#125;class MainActivityUI : AnkoComponent&lt;MainActivity&gt; &#123; override fun createView(ui: AnkoContext&lt;MainActivity&gt;) = with(ui) &#123; verticalLayout &#123; padding = dip(30) editText &#123; hint = "Name" textSize = 24f &#125; editText &#123; hint = "Password" textSize = 24f &#125; button("登录") &#123; textSize = 26f &#125; &#125; &#125;&#125; Theme在Anko如果你想设置Theme需要使用themeable1234verticalLayout &#123; padding = dip(30) themedButton("登陆", theme = R.style.Base_TextAppearance_AppCompat_Button)&#125; LayoutParams在Anko中也可以使用LayoutParams。比方说我现在要显示一个button，下面显示一个图片。 如果使用XML:12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" android:gravity=center android:textSize="20sp" /&gt; &lt;ImageView android:layout_width="match_parent" android:layout_height="match_parent" android:background="@color/colorAccent" /&gt;&lt;/LinearLayout&gt; 但是使用Anko: 12345678910verticalLayout &#123; textView ("Hello World!") &#123; textSize = sp(12).toFloat() &#125;.lparams(height = wrapContent, width = wrapContent) &#123; horizontalGravity = Gravity.CENTER_HORIZONTAL &#125; imageView &#123; backgroundColor = Color.BLUE &#125;.lparams(height = matchParent, width = matchParent)&#125; 注意： horizontalMargin 同时设置 left 和 right margins verticalMargin 同时设置 top 和 bottom margin 同时设置4个方向的 margins Listeners在Anko中设置Listeners非常简单，我下面以Button的OnClick举例：12345button("登录") &#123; id = buttonLogin textSize = 26f onClick &#123; toast("OnClickLoginButton") &#125;&#125; 使用Fragment加载先创建一个Activity，把Fragment加进去123456789class AnkoFragmentActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) linearLayout &#123; id = R.id.fragment_id supportFragmentManager.beginTransaction().replace(id, AnkoFragment.newInstance()).commit() &#125; &#125;&#125; 然后在Fragment的onCreateView()中加入DSL代码，然后返回View即可12345678910111213141516class AnkoFragment : Fragment() &#123; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; // return inflater.inflate(R.layout.fragment_anko, container, false) return UI &#123; verticalLayout &#123; editText() button("OK") &#125; &#125;.view &#125; companion object &#123; fun newInstance(): AnkoFragment &#123; return AnkoFragment() &#125; &#125;&#125; 不足AnkoLayout确实挺好的，因为他把UI代码集成到了代码文件中，不用再像以前一样写一个点击事件还得先findViewBuId，然后再setOnClickListeners。代码能非常简洁。 但是AnkoLayout还是不够完美，感觉写起来还是没有XML那个顺手（可能是我写惯了XML，刚开始用Anko还不够熟练），而且Anko还有很多控件都不支持。最重要的是，他没有实时预览！！！ Android Studio里面有一个叫Anko Support的插件，可以实现anko的预览，但是他必须是先将项目构建了再预览的，不算是实时预览]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android类之SharedPreferences]]></title>
    <url>%2Fposts%2F8a47fe84.html</url>
    <content type="text"><![CDATA[Android类之SharedPreferences简介SharedPreferences是一个轻量的存储类，用于把一些只需要少量简单类型数据保存到本地，例如搜索历史、用户设置等。 他只适合处理简单的数据，处理太过于庞大的数据会减慢程序运行。 使用步骤1. 存储数据 使用Activity类的getSharedPreferences()方法获得SharedPreferences对象，其中存储key-value的文件名由getSharedPreferences()方法的第一个参数指定。 使用SharedPreferences接口的edit()获得SharedPreferences.Editor对象。 通过SharedPreferences.Editor接口的putXxx()方法保存key-value对，其中Xxx表示不同的数据类型。例如：字符串类型的value需要用putString方法。 通过SharedPreferences.Editor接口的commit()方法保存key-value对，commit方法相当于数据库事务中的提交操作。 12345SharedPreferences sharedPreferences = getSharedPreferences("test", Context.MODE_PRIVATE);Editor editor = sharedPreferences.edit();//获取编辑器editor.putString("name", "小明");editor.putInt("age", 24);editor.commit();//提交修改 2. 读取数据 使用Activity类的getSharedPreferences()方法获得SharedPreferences对象。 通过SharedPreferences对象的getXxx()方法得到数据。 1234SharedPreferences sharedPreferences= getSharedPreferences("test", Activity.MODE_PRIVATE);// 使用getString方法获得value，注意第2个参数是value的默认值 String name =sharedPreferences.getString("name", "");int age =sharedPreferences.getInt("age", 0); SharedPreferences的四种模式 1234Context.MODE_PRIVATE：为默认操作模式,代表该文件是私有数据,只能被应用本身访问,在该模式下,写入的内容会覆盖原文件的内容Context.MODE_APPEND：模式会检查文件是否存在,存在就往文件追加内容,否则就创建新文件.Context.MODE_WORLD_READABLE：表示当前文件可以被其他应用读取.Context.MODE_WORLD_WRITEABLE：表示当前文件可以被其他应用写入.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidView之PopupWindow]]></title>
    <url>%2Fposts%2F1900f7eb.html</url>
    <content type="text"><![CDATA[AndroidView之PopupWindow因为项目中有很多地方都需要使用PopupWindow，所以特别查了一下，做了一个简单的总结，过两天就加到项目中去。 PopupWindowPopupWindow，顾名思义，就是一个用来显示弹窗的组件。 创建步骤 创建PopupWindow实例 设置一些基本参数 显示PopupWindow构造方法 1PopupWindow window = new PopupWindow(View contentView, int width, int height, boolean focusable); 这个方法有四个参数，第一个参数是用于PopupWindow中的View，第二个参数是PopupWindow的宽度，第三个参数是PopupWindow的高度，第四个参数指定PopupWindow能否获得焦点。 示例代码 12View contentView = LayoutInflater.from(MainActivity.this).inflate(R.layout.popuplayout, null);PopupWindwo window = PopupWindow (contentView, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, true); 基本方法 window.setBackgroundDrawable(Drawable background); 设置PopupWindow的背景 window.setOutsideTouchable(boolean touchable); 设置PopupWindow是否能响应外部点击事件 window.setTouchable(boolean touchable); 设置PopupWindow是否能响应点击事件只有同时设置PopupWindow的背景和可以响应外部点击事件，它才能“真正”响应外部点击事件。 显示PopupWindow window.showAtLocation(View parent, int gravity, int x, int y); 第一个参数是PopupWindow的父View，第二个参数是PopupWindow相对父View的位置，第三和第四个参数分别是PopupWindow相对父View的x、y偏移 window.showAsDropDown(View anchor, int xoff, int yoff, int gravity); 第一个参数是PopupWindow的锚点，第二和第三个参数分别是PopupWindow相对锚点的x、y偏移 为PopupWindow添加动画 进入时动画：(context_menu_enter.xml) 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:duration="@android:integer/config_shortAnimTime" android:fromXDelta="0" android:fromYDelta="100%p" android:interpolator="@android:anim/accelerate_decelerate_interpolator" android:toXDelta="0" android:toYDelta="0"/&gt; &lt;/set&gt; 退出时动画：(context_menu_exit.xml) 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;translate android:duration="@android:integer/config_shortAnimTime" android:fromXDelta="0" android:fromYDelta="0" android:interpolator="@android:anim/accelerate_decelerate_interpolator" android:toXDelta="0" android:toYDelta="100%p" /&gt; &lt;/set&gt; 生成style 1234&lt;style name=&quot;contextMenuAnim&quot; parent=&quot;@android:style/Animation.Activity&quot;&gt; &lt;item name=&quot;android:windowEnterAnimation&quot;&gt;@anim/context_menu_enter&lt;/item&gt; &lt;item name=&quot;android:windowExitAnimation&quot;&gt;@anim/context_menu_exit&lt;/item&gt;&lt;/style&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
</search>
