<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[操作系统4--进程的通信和线程]]></title>
    <url>%2Fposts%2F30b7e738.html</url>
    <content type="text"><![CDATA[大家可以看下我使用幕布软件画的思维导图，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员https://mubu.com/inv/477598 4.1 进程通信进程通信就是指进程之间的信息交换。 早期的时候，由于技术不发达，以及由于进程的同步和互斥需要在进程间交换一定的数据，所以不少人也将他们称为进程通信，但是实质上他们只能被成为低级的进程通信。以信号量为例，他 效率低 生产者或消费者每次只能向缓冲区投放一个产品或者取出一个产品。 通信对用户不透明 而关于进程间通信所需的数据结构的设置和数据的传送、进程的同步和互斥，都需要程序员去完成，显然是非常不方便的。 所以高级进程通信必须满足如下特点： 使用方便。 OS隐藏了实现进程通信的具体细节，向用户提供了一组用于实现高级通信的命令，用户可以方便地直接利用它实现进程之间的通信。 高效的传送数据。 用户可以直接利用高级通信命令高效的传送大量的数据。 进程通信主要有共享存储器系统、管道通信系统、消息传递系统以及客户机-服务器系统。 4.1.1 共享存储器系统共享存储器系统又分为了两种： 基于共享数据结构的通信方式 在这种通信方式下，要求进程公用某些数据结构，借以实现诸进程间的信息交换。这种方式仅适用于传递相对少量的数据，通信效率低下，属于低级通信。 基于共享存储区的通信方式 为了传输大量数据，就在内存中划出了一块共享存储区域，诸进程可通过对该共享区的读或写交换数据，实现通信，数据的形式和位置甚至访问控制都是由进程负责，而不是OS。 4.1.2 管道通信系统所谓管道，是指用于连接一个读进程和一个写进程以实现他们之间通信的一块共享存储文件，又叫pipe文件。向管道提供输入的发送进程以字符流形式将达量的数据送入管道，而接收管道输出的接收进程则从管道中接收数据。这种方式是UNIX系统IPC最古老的形式。 为了协调双方的通信，他必须提供一下三个功能的协调能力： 互斥 同步 确定对方是否存在 4.1.3 消息传递系统在这种方式下，集成不再借助任何共享存储区或数据结构，而是以格式化的消息(Message)为单位，将通信的数据封装在消息中，并利用操作系统提供的一组通信命令，在进程间进行消息传递，完成进程间的数据交换。 该方式隐藏了通信实现细节，使通信过程对用户透明化，降低了通信程序设计的复杂性和错误率，成为当前应用最为广泛的一类进程间的通信机制. 4.1.4 客户机-服务器系统前面的几种通信系统，虽然也可以用于实现不同计算机间进程的双向通信，但是客户机-服务器系统的通信机制，在网络环境的各种应用领域已成为当前主流的通信实现机制，主要分为三类：套接字、远程过程调用和远程方法调用。在这就不多赘述了。 4.2 线程4.2.1 为什么要引入线程我们都知道，进程有两个基本属性：①进程是一个可拥有资源的独立单位，一个进程要能独立运行，他必须拥有一定的数据结构。②进程同时又是一个可独立调度和分派的基本单位。 为了程序能并发执行，系统必须能进行创建进程、撤销进程和切换进程操作。但是由于进程是资源的拥有者，所以在上述这些操作中，系统必须为之付出较大的时空开销。这就限制了系统中所设置进程的数目，而且进程切换也不宜过于频繁，从而限制了并发程度的进一步提高。 4.2.2 线程的概念在上述原因下，引入了线程的概念。学者们将进程的两个属性分开，让作为调度和分派的基本单位不拥有资源，让拥有资源的基本单倍不被频繁的调度。这样的话，就形成了线程的概念。 下面我们从6个方面来比较下进和线程： 调度的基本单位 传统OS中，进程是作为独立调度的基本单位，每次调度时，都需要上下文切换，开销大。在引入了线程的OS中，线程是作为独立调度的基本单位，线程切换时只需要保存和设置少量的寄存器内容，切换代价远小于进程。 并发性 在引入线程的OS中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可以并发执行，甚至还允许在一个进程中的所有线程都能并发执行。 拥有资源 进程可以拥有资源，而且还是系统中拥有资源的一个基本单位。但是线程本身并不拥有资源，而是仅有一点必不可少的、能保证独立运行的资源。 独立性 同一进程中的线程之间的独立性比不同进程间的独立性低得多。 系统开销 进程切换需要大量的系统开销，而线程间则需要的很少 支持多处理机系统 在多处理机系统中，对于传统进程，不管有多少处理机，该进程只能运行在一个处理机上。但是对于多线程进程，可以将一个进程中的多个线程分配到多个处理机上。 4.2.3 线程的状态和线程控制块与进程一样，线程也拥有三个状态和线程控制块。 4.2.3.1 线程运行的三个状态线程的三个状态和进程类似。 运行状态，表示线程已获得处理机而正在运行。 就绪状态，表示线程已具备各种执行条件，只须再获得CPU便可立即执行。 阻塞状态，只线程在执行中因某事件受阻而处于暂停状态。 4.2.3.2 线程控制块TCB线程控制块用来纪录用于控制和管理线程的信息。线程控制块中通常由这几项： 线程标识符，为每个线程设置唯一地标识符。 一组寄存器，包括程序计数器PC、状态寄存器和通用寄存器的内容。 线程运行状态，用于描述线程正处于何种运行状态。 优先级，描述线程执行的优先程度。 线程专有存储区，用于线程切换时存放现场保护信息，和与该线程相关的统计信息等。 信号屏蔽，即对某些信号加以屏蔽。 堆栈指针。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uCrop框架用法和源码解析]]></title>
    <url>%2Fposts%2F4e4b8b52.html</url>
    <content type="text"><![CDATA[本人能力不足，在看到源码最后一部分的时候大量抄袭可能是最详细的UCrop源码解析 1. uCrop简介uCrop是目前较火的图片裁剪框架，开发者宣称他会比目前市面上所有的图片裁剪方案都要更流畅。外加他封装程度较高，可自定义，而且颜值很高（似乎这个才是重点），现在越来越多APP选择使用它。github 2. 使用方法得益于uCrop优秀的封装，uCrop的使用方法特简单。 2.1 导入依赖 先在项目的build.gradle中添加 123456allprojects &#123; repositories &#123; jcenter() maven &#123; url "https://jitpack.io" &#125; &#125;&#125; 并在module的build.gradle中添加 implementation &#39;com.github.yalantis:ucrop:2.2.3&#39; - 轻量级框架 implementation &#39;com.github.yalantis:ucrop:2.2.3-native&#39; - 获得框架全部强大的功能以及图片的高质量(最终可能会导致apk的大小增加1.5MB以上) 由于框架的本质是调用到另一个Activity去处理图片，所以需要在AndroidManifest.xml中将UCropActivity添加进去 1234&lt;activity android:name="com.yalantis.ucrop.UCropActivity" android:screenOrientation="portrait" android:theme="@style/Theme.AppCompat.Light.NoActionBar"/&gt; 到这你就能把cUrop全部导入到你的项目里面了，接下来咱们就拉将如何调用 2.2 开始基本的调用调用起来很简单： 12UCrop.of(sourceUri, destinationUri) .start(context); 其中sourceUri是输入图片的Uri，destinationUri是输出图片的Uri。然后他就会由Intent的调动跳到UCropActivity，用户就在UCropActivity里面进行图片裁剪操作，然后最后由UCropActivity发起一个Intent回到你的Activity。 2.3 处理回来的数据由于是从UCropAcitivity传回数据，所以你需要在你的Activity里面的onActivityResult方法处理uCrop返回的信息： 12345678@Overridepublic void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (resultCode == RESULT_OK &amp;&amp; requestCode == UCrop.REQUEST_CROP) &#123; final Uri resultUri = UCrop.getOutput(data); &#125; else if (resultCode == UCrop.RESULT_ERROR) &#123; final Throwable cropError = UCrop.getError(data); &#125;&#125; 到这，基本用法就完了，你就可以尽情的使用uCrop。但是我前面说过，uCrop封装程度好，这点很多图片处理框架都可以做到，基本上都是把需要的数据传到自己的Activity之后由自己的Activity处理，所以很多框架看起来都有优秀的封装，那uCrop相比其他又有啥好呢，答案就是自定义灵活： 2.4 uCrop高阶用法2.4.1 配置uCrop12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 启动裁剪 * @param activity 上下文 * @param sourceFilePath 需要裁剪图片的绝对路径 * @param requestCode 比如：UCrop.REQUEST_CROP * @param aspectRatioX 裁剪图片宽高比 * @param aspectRatioY 裁剪图片宽高比 * @return */public static String startUCrop(Activity activity, String sourceFilePath, int requestCode, float aspectRatioX, float aspectRatioY) &#123; Uri sourceUri = Uri.fromFile(new File(sourceFilePath)); File outDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES); if (!outDir.exists()) &#123; outDir.mkdirs(); &#125; File outFile = new File(outDir, System.currentTimeMillis() + ".jpg"); //裁剪后图片的绝对路径 String cameraScalePath = outFile.getAbsolutePath(); Uri destinationUri = Uri.fromFile(outFile); //初始化，第一个参数：需要裁剪的图片；第二个参数：裁剪后图片 UCrop uCrop = UCrop.of(sourceUri, destinationUri); //初始化UCrop配置 UCrop.Options options = new UCrop.Options(); //设置裁剪图片可操作的手势 options.setAllowedGestures(UCropActivity.SCALE, UCropActivity.ROTATE, UCropActivity.ALL); //是否隐藏底部容器，默认显示 options.setHideBottomControls(true); //设置toolbar颜色 options.setToolbarColor(ActivityCompat.getColor(activity, R.color.colorPrimary)); //设置状态栏颜色 options.setStatusBarColor(ActivityCompat.getColor(activity, R.color.colorPrimary)); //是否能调整裁剪框 options.setFreeStyleCropEnabled(true); //UCrop配置 uCrop.withOptions(options); //设置裁剪图片的宽高比，比如16：9 uCrop.withAspectRatio(aspectRatioX, aspectRatioY); //uCrop.useSourceImageAspectRatio(); //跳转裁剪页面 uCrop.start(activity, requestCode); return cameraScalePath;&#125; 2.4.2 其他配置1234567891011121314151617181920212223242526//设置Toolbar标题void setToolbarTitle(@Nullable String text)//设置裁剪的图片格式void setCompressionFormat(@NonNull Bitmap.CompressFormat format)//设置裁剪的图片质量，取值0-100void setCompressionQuality(@IntRange(from = 0) int compressQuality)//设置最多缩放的比例尺void setMaxScaleMultiplier(@FloatRange(from = 1.0, fromInclusive = false) float maxScaleMultiplier)//动画时间void setImageToCropBoundsAnimDuration(@IntRange(from = 100) int durationMillis)//设置图片压缩最大值void setMaxBitmapSize(@IntRange(from = 100) int maxBitmapSize)//是否显示椭圆裁剪框阴影void setOvalDimmedLayer(boolean isOval) //设置椭圆裁剪框阴影颜色void setDimmedLayerColor(@ColorInt int color)//是否显示裁剪框void setShowCropFrame(boolean show)//设置裁剪框边的宽度void setCropFrameStrokeWidth(@IntRange(from = 0) int width)//是否显示裁剪框网格void setShowCropGrid(boolean show) //设置裁剪框网格颜色void setCropGridColor(@ColorInt int color)//设置裁剪框网格宽void setCropGridStrokeWidth(@IntRange(from = 0) int width) 3. 源码解析 在我开始说源码之前，我建议大家可以先看下我下面的连接，因为本框架的作者真的是个好人，他不仅为我们贡献了这么好的一个框架，还把自己写这个框架的思路都写了出来，大家可以看看英文原版国内网友翻译版百度网页翻译机翻版其实我个人感觉百度机翻没有谷歌翻译的好，大家有条件的可以使用谷歌翻译浏览器插件翻译整个网页（谷歌翻译好像国内可以直接访问） 代码结构大致分为三个部分: 3.1 第一部分：UCropActivity（整个框架的外在，用户操作图片的地方）他的功能就是项目主要的界面，以及实现一些基本的初始化。你跳转到uCrop看到的那个操作图片的界面就是它。 这块看源码的时候代码居多，但是，说实话，就像刚刚说的一样，他除了初始化还是初始化。初始化完Toolbar接着初始化ViewGroup，初始化完ViewGroup接着初始化Image数据等等。所以这块我就没咋细看（其实是因为代码太长了，逃） 3.2 第二部分：OverlayView（绘制裁剪框）这一块主要就是来画你所看到的图片中的裁剪的辅助线。 在构造方法里面就调用了一个方法，就是init()，而init()方法也就干了一件事——判断。当系统小于JELLY_BEA_MR2也就是Android4.3时，启动了硬件加速，至于为什么setLayerType(LAYER_TYPE_SOFTWARE, null);这个看着就像启动硬件加速的方法，甚至参数里面还有软件这个单词的方法能启动硬件加速，请大家移步HenCoder Android 自定义 View 1-8 硬件加速（进去直接搜索这个方法即可，就能找到解释的地方），我再次不做解释。 这个类主要有两个方法 drawDimmedLayer()绘制裁剪框之外的灰色部分 drawCropGrid()绘制裁剪框 那我们分别来看下这两个方法： 3.2.1 drawDimmedLayer()123456789101112131415161718192021protected void drawDimmedLayer(@NonNull Canvas canvas) &#123; //先保存当前当前画布 canvas.save(); //判断是否显示圆框 if (mCircleDimmedLayer) &#123; //按Path路径裁剪 canvas.clipPath(mCircularPath, Region.Op.DIFFERENCE); &#125; else &#123; //裁剪矩形 canvas.clipRect(mCropViewRect, Region.Op.DIFFERENCE); &#125; //着色 canvas.drawColor(mDimmedColor); //恢复之前保存的Canvas的状态 canvas.restore(); if (mCircleDimmedLayer) &#123; // 绘制1px笔划以修复反锯齿 canvas.drawCircle(mCropViewRect.centerX(), mCropViewRect.centerY(), Math.min(mCropViewRect.width(), mCropViewRect.height()) / 2.f, mDimmedStrokePaint); &#125;&#125; 首先就是一个mCircleDimmedLayer，这个我真的很迷，因为我不知道她是咋来的，于是我就看OverlayView有没有对这个变量的赋值，于是整个类我就找到了一个setCircleDimmedLayer()方法，于是我看这个方法是在哪被调用了的，然后我就找到他分别被UCropActivity和UCropFragment两个类调用到，而且一个是intent.getBooleanExtra()方法一个是bundle.getBoolean()方法，看到这个我相信大家都有点数了，这明显就是其他类传过来的啊，我发现他两的key的值都是UCrop.Options.EXTRA_CIRCLE_DIMMED_LAYER，那我就懂了，找整个框架里面哪儿提到过这个值不就得了，于是我就发现除了上面两个方法以及他的初始化以外，我发现了第4个调用的地方，也是唯一一个调用的地方——Ucrop.setCircleDimmedLayer()： 1234567/** * @param isCircle - set it to true if you want dimmed layer to have an circle inside * iscircle-如果希望暗显层中有一个圆，请将其设置为true。 */public void setCircleDimmedLayer(boolean isCircle) &#123; mOptionBundle.putBoolean(EXTRA_CIRCLE_DIMMED_LAYER, isCircle);&#125; 注释上面是原话，下面是我百度机翻的翻译。看了就懂了吧，反正我没懂，我也完全没有见到哪调用过这个方法，我更不懂啥叫希望暗显层有个圆，啥玩意？充满线条的黑？？？直到我将UCrop的调用方法修改了并运行之后我才懂了： 12345val options = UCrop.Options()options.setCircleDimmedLayer(true)UCrop.of(uri, destinationUri) .withOptions(options) .start(this) 结果是： 然后就懂了，应该是能截一个圆形的图案吧，然后我点下了✔️，然后…… 无话可说，作者牛逼！！！ 回去回去，刚刚说到drawDimmedLayer()，可以看到，如果mCircleDimmedLayer为true就调用clipPath()跟着路径裁切一个矩形加原，不然的话就调用clipRect()裁切一个矩形。然后加入颜色，然后完了 3.2.2 drawCropGrid()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950protected void drawCropGrid(@NonNull Canvas canvas) &#123; // 判断是否显示剪裁框 if (mShowCropGrid) &#123; // 判断矩形数据是否为空，mGridPoints 如果等于空的话进入填充数据 if (mGridPoints == null &amp;&amp; !mCropViewRect.isEmpty()) &#123; // 该数组为 canvas.drawLines 的第一个参数，该参数要求其元素个数为 4 的倍数 mGridPoints = new float[(mCropGridRowCount) * 4 + (mCropGridColumnCount) * 4]; int index = 0; // 组装数据，数据为每一组线段的坐标点 for (int i = 0; i &lt; mCropGridRowCount; i++) &#123; mGridPoints[index++] = mCropViewRect.left; mGridPoints[index++] = (mCropViewRect.height() * (((float) i + 1.0f) / (float) (mCropGridRowCount + 1))) + mCropViewRect.top; mGridPoints[index++] = mCropViewRect.right; mGridPoints[index++] = (mCropViewRect.height() * (((float) i + 1.0f) / (float) (mCropGridRowCount + 1))) + mCropViewRect.top; &#125; for (int i = 0; i &lt; mCropGridColumnCount; i++) &#123; mGridPoints[index++] = (mCropViewRect.width() * (((float) i + 1.0f) / (float) (mCropGridColumnCount + 1))) + mCropViewRect.left; mGridPoints[index++] = mCropViewRect.top; mGridPoints[index++] = (mCropViewRect.width() * (((float) i + 1.0f) / (float) (mCropGridColumnCount + 1))) + mCropViewRect.left; mGridPoints[index++] = mCropViewRect.bottom; &#125; &#125; //绘制线段 if (mGridPoints != null) &#123; canvas.drawLines(mGridPoints, mCropGridPaint); &#125; &#125; //绘制矩形包裹线段 if (mShowCropFrame) &#123; canvas.drawRect(mCropViewRect, mCropFramePaint); &#125; //绘制边角包裹,mFreestyleCropMode此参数如果等于1的话 剪裁框为可移动状态，一般不用 if (mFreestyleCropMode != FREESTYLE_CROP_MODE_DISABLE) &#123; canvas.save(); mTempRect.set(mCropViewRect); mTempRect.inset(mCropRectCornerTouchAreaLineLength, -mCropRectCornerTouchAreaLineLength); canvas.clipRect(mTempRect, Region.Op.DIFFERENCE); mTempRect.set(mCropViewRect); mTempRect.inset(-mCropRectCornerTouchAreaLineLength, mCropRectCornerTouchAreaLineLength); canvas.clipRect(mTempRect, Region.Op.DIFFERENCE); canvas.drawRect(mCropViewRect, mCropFrameCornersPaint); canvas.restore(); &#125;&#125; 一开头又是一个和上面类似的变量mShowCropGrid，这下我就不说我找的具体步骤，他的功能就是如果他是true就会在裁剪框中显示9宫格线，为false就没有。接着就是画线部分，我觉得这个我不用讲啥，也没啥讲的，唯一就是为什么mGridPoints这个数组的大小是4的倍数，大家可以看下这个博客Android Canvas DrawLines中第一个参数的解释 3.3 第三部分：GestureCropImageView（正在框架的内在，代码操作操作图片的地方）这个是整个项目最核心的地方。前面的两部分都是UI的，而这个才是真正的对图片进行处理的部分，也是我最想知道了解的部分。这部分作者也在他的博客里面说的最多最清楚。作者把这部分的逻辑分为了三个部分 TransformImageView extends ImageView 他处理了 从源拿到图片 将图片进变换（平移、缩放、旋转），并应用到当前图片上 CropImageView extends TransformImageView 他处理了 绘制裁剪边框和网格 为裁剪区域设置一张图片（如果用户对图片操作导致裁剪区域出现了空白，那么图片应自动移动到边界填充空白区域） 继承父类方法，使用更精准的规则来操作矩阵（限制最大和最小缩放比） 添加方法和缩小的方法 裁剪图片 GestureCropImageView extends CropImageView 他处理了 监听用户手势，并调用对应的正确的方法 3.3.1 TransformImageView作者说这是最容易的部分。在看这个类之前我们先来看看BitmapLoadTask类，这个类是一切图像处理的基础，这个类负责了Uri解码bitmap，并处理分辨率：首先根据拿到的Uri解析位图： 12345678910111213final ParcelFileDescriptor parcelFileDescriptor;try &#123; parcelFileDescriptor = mContext.getContentResolver().openFileDescriptor(mInputUri, "r");&#125; catch (FileNotFoundException e) &#123; return new BitmapWorkerResult(e);&#125;final FileDescriptor fileDescriptor;if (parcelFileDescriptor != null) &#123; fileDescriptor = parcelFileDescriptor.getFileDescriptor();&#125; else &#123; return new BitmapWorkerResult(new NullPointerException("ParcelFileDescriptor was null for given Uri: [" + mInputUri + "]"));&#125; 现在，可以使用BitmapFactory方法解码FileDescriptor。 但在解码位图之前，有必要知道它的大小，因为如果分辨率太高，位图将被二次采样。 123456789101112131415161718192021222324252627282930313233final BitmapFactory.Options options = new BitmapFactory.Options();options.inJustDecodeBounds = true;BitmapFactory.decodeFileDescriptor(fileDescriptor, null, options);options.inSampleSize = calculateInSampleSize(options, requiredWidth, requiredHeight);options.inJustDecodeBounds = false;Bitmap decodeSampledBitmap = BitmapFactory.decodeFileDescriptor(fileDescriptor, null, options);close(parcelFileDescriptor);ExifInterface exif = getExif(uri);if (exif != null) &#123; int exifOrientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL); return rotateBitmap(decodeSampledBitmap, exifToDegrees(exifOrientation));&#125; else &#123; return decodeSampledBitmap;&#125; 这样就拿到了bitmap实例了，就可以去TansformImageView去对图片进行调整了。其实这个类我也不知道说啥😂，我觉得这个类也就是把Matrix的postTranslate()、postRotate()和postScale()方法给封装了下。关于Matrix的知识大家可以参考这篇博客：安卓自定义View进阶-Matrix原理 3.3.2 CropImageView这一层是最复杂的一层，作者的操作大致可以分为3步：图片裁剪框偏移计算、图片归为动画处理、裁剪图片 第一步：图片裁剪框偏移计算当用户手指移开时，要确保图片处于裁剪区域中，如果不处于，需要通过平移把它移过来： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public void setImageToWrapCropBounds(boolean animate) &#123; //如果图片加载完毕并且图片不处于剪裁区域 if (mBitmapLaidOut &amp;&amp; !isImageWrapCropBounds()) &#123; //获取中心点X,Y坐标 float currentX = mCurrentImageCenter[0]; float currentY = mCurrentImageCenter[1]; //获取缩放比例 float currentScale = getCurrentScale(); //获取偏移距离 float deltaX = mCropRect.centerX() - currentX; float deltaY = mCropRect.centerY() - currentY; float deltaScale = 0; mTempMatrix.reset(); mTempMatrix.setTranslate(deltaX, deltaY); final float[] tempCurrentImageCorners = Arrays.copyOf(mCurrentImageCorners, mCurrentImageCorners.length); mTempMatrix.mapPoints(tempCurrentImageCorners); //判断图片是否包含在剪裁区域 boolean willImageWrapCropBoundsAfterTranslate = isImageWrapCropBounds(tempCurrentImageCorners); //如果包含在剪裁区域 if (willImageWrapCropBoundsAfterTranslate) &#123; //获取偏移的距离 final float[] imageIndents = calculateImageIndents(); //偏移的距离，横坐标加横坐标 纵坐标加纵坐标 deltaX = -(imageIndents[0] + imageIndents[2]); deltaY = -(imageIndents[1] + imageIndents[3]); &#125; else &#123; //如果不包含在剪裁区域，创建临时矩形 RectF tempCropRect = new RectF(mCropRect); mTempMatrix.reset(); //设置偏移角度 mTempMatrix.setRotate(getCurrentAngle()); mTempMatrix.mapRect(tempCropRect); //获得矩形的边长坐标 final float[] currentImageSides = RectUtils.getRectSidesFromCorners(mCurrentImageCorners); //获取放大比例 deltaScale = Math.max(tempCropRect.width() / currentImageSides[0], tempCropRect.height() / currentImageSides[1]); deltaScale = deltaScale * currentScale - currentScale; &#125; //如果需要动画 if (animate) &#123; post(mWrapCropBoundsRunnable = new WrapCropBoundsRunnable( CropImageView.this, mImageToWrapCropBoundsAnimDuration, currentX, currentY, deltaX, deltaY, currentScale, deltaScale, willImageWrapCropBoundsAfterTranslate)); &#125; else &#123; //不需要动画，直接移动到目标位置 postTranslate(deltaX, deltaY); if (!willImageWrapCropBoundsAfterTranslate) &#123; zoomInImage(currentScale + deltaScale, mCropRect.centerX(), mCropRect.centerY()); &#125; &#125; &#125;&#125; 第二步：处理平移通过一个Runnable线程来处理平移，并且通过时间差值的计算来移动动画，使动画看起来更真实：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 此可运行文件用于动画图像，使其完全填充裁剪边界。 * 给定值在动画期间内插。 * runnable可以终止于vie&#123;@link #cancelAllAnimations()&#125;方法， * 也可以在触发&#123;@link WrapCropBoundsRunnable#run()&#125;方法内的某些条件时终止。 */private static class WrapCropBoundsRunnable implements Runnable &#123; private final WeakReference&lt;CropImageView&gt; mCropImageView; private final long mDurationMs, mStartTime; private final float mOldX, mOldY; private final float mCenterDiffX, mCenterDiffY; private final float mOldScale; private final float mDeltaScale; private final boolean mWillBeImageInBoundsAfterTranslate; public WrapCropBoundsRunnable(CropImageView cropImageView, long durationMs, float oldX, float oldY, float centerDiffX, float centerDiffY, float oldScale, float deltaScale, boolean willBeImageInBoundsAfterTranslate) &#123; mCropImageView = new WeakReference&lt;&gt;(cropImageView); mDurationMs = durationMs; mStartTime = System.currentTimeMillis(); mOldX = oldX; mOldY = oldY; mCenterDiffX = centerDiffX; mCenterDiffY = centerDiffY; mOldScale = oldScale; mDeltaScale = deltaScale; mWillBeImageInBoundsAfterTranslate = willBeImageInBoundsAfterTranslate; &#125; @Override public void run() &#123; CropImageView cropImageView = mCropImageView.get(); if (cropImageView == null) &#123; return; &#125; long now = System.currentTimeMillis(); float currentMs = Math.min(mDurationMs, now - mStartTime); float newX = CubicEasing.easeOut(currentMs, 0, mCenterDiffX, mDurationMs); float newY = CubicEasing.easeOut(currentMs, 0, mCenterDiffY, mDurationMs); float newScale = CubicEasing.easeInOut(currentMs, 0, mDeltaScale, mDurationMs); if (currentMs &lt; mDurationMs) &#123; cropImageView.postTranslate(newX - (cropImageView.mCurrentImageCenter[0] - mOldX), newY - (cropImageView.mCurrentImageCenter[1] - mOldY)); if (!mWillBeImageInBoundsAfterTranslate) &#123; cropImageView.zoomInImage(mOldScale + newScale, cropImageView.mCropRect.centerX(), cropImageView.mCropRect.centerY()); &#125; if (!cropImageView.isImageWrapCropBounds()) &#123; cropImageView.post(this); &#125; &#125; &#125;&#125; 下面还有另一个线程，用于双击放大: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 此可运行项用于设置图像缩放的动画。 * 给定值在动画期间内插。 * runnable可以终止vie &#123;@link #cancelAllAnimations()&#125;方法， * 也可以在触发&#123;@link ZoomImageToPosition#run()&#125;方法内的某些条件时终止。 */private static class ZoomImageToPosition implements Runnable &#123; private final WeakReference&lt;CropImageView&gt; mCropImageView; private final long mDurationMs, mStartTime; private final float mOldScale; private final float mDeltaScale; private final float mDestX; private final float mDestY; public ZoomImageToPosition(CropImageView cropImageView, long durationMs, float oldScale, float deltaScale, float destX, float destY) &#123; mCropImageView = new WeakReference&lt;&gt;(cropImageView); mStartTime = System.currentTimeMillis(); mDurationMs = durationMs; mOldScale = oldScale; mDeltaScale = deltaScale; mDestX = destX; mDestY = destY; &#125; @Override public void run() &#123; CropImageView cropImageView = mCropImageView.get(); if (cropImageView == null) &#123; return; &#125; long now = System.currentTimeMillis(); float currentMs = Math.min(mDurationMs, now - mStartTime); float newScale = CubicEasing.easeInOut(currentMs, 0, mDeltaScale, mDurationMs); if (currentMs &lt; mDurationMs) &#123; cropImageView.zoomInImage(mOldScale + newScale, mDestX, mDestY); cropImageView.post(this); &#125; else &#123; cropImageView.setImageToWrapCropBounds(); &#125; &#125;&#125; 第三步：裁剪图片 12345678910111213141516171819202122232425/** * 取消所有当前动画并设置图像以填充裁剪区域（不带动画）。 * 然后用适当的参数创建并执行&#123;@link BitmapCropTask&#125;。 */public void cropAndSaveImage(@NonNull Bitmap.CompressFormat compressFormat, int compressQuality, @Nullable BitmapCropCallback cropCallback) &#123; //结束子线程 cancelAllAnimations(); //设置要剪裁的图片，不需要位移动画 setImageToWrapCropBounds(false); //存储图片信息，四个参数分别为：mCropRect要剪裁的图片矩阵，当前图片要剪裁的矩阵，当前放大的值，当前旋转的角度 final ImageState imageState = new ImageState( mCropRect, RectUtils.trapToRect(mCurrentImageCorners), getCurrentScale(), getCurrentAngle()); //剪裁参数，mMaxResultImageSizeX，mMaxResultImageSizeY：剪裁图片的最大宽度、高度。 final CropParameters cropParameters = new CropParameters( mMaxResultImageSizeX, mMaxResultImageSizeY, compressFormat, compressQuality, getImageInputPath(), getImageOutputPath(), getExifInfo()); //剪裁操作放到AsyncTask中执行 new BitmapCropTask(getViewBitmap(), imageState, cropParameters, cropCallback).execute();&#125; 这块核心方法还是在BitmapCropTask中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//调整剪裁大小，如果有设置最大剪裁大小也会在这里做调整到设置范围private float resize() &#123; final BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeFile(mImageInputPath, options); boolean swapSides = mExifInfo.getExifDegrees() == 90 || mExifInfo.getExifDegrees() == 270; float scaleX = (swapSides ? options.outHeight : options.outWidth) / (float) mViewBitmap.getWidth(); float scaleY = (swapSides ? options.outWidth : options.outHeight) / (float) mViewBitmap.getHeight(); float resizeScale = Math.min(scaleX, scaleY); mCurrentScale /= resizeScale; resizeScale = 1; if (mMaxResultImageSizeX &gt; 0 &amp;&amp; mMaxResultImageSizeY &gt; 0) &#123; float cropWidth = mCropRect.width() / mCurrentScale; float cropHeight = mCropRect.height() / mCurrentScale; if (cropWidth &gt; mMaxResultImageSizeX || cropHeight &gt; mMaxResultImageSizeY) &#123; scaleX = mMaxResultImageSizeX / cropWidth; scaleY = mMaxResultImageSizeY / cropHeight; resizeScale = Math.min(scaleX, scaleY); mCurrentScale /= resizeScale; &#125; &#125; return resizeScale;&#125;// 剪裁图片private boolean crop(float resizeScale) throws IOException &#123; ExifInterface originalExif = new ExifInterface(mImageInputPath); //四舍五入取整 cropOffsetX = Math.round((mCropRect.left - mCurrentImageRect.left) / mCurrentScale); cropOffsetY = Math.round((mCropRect.top - mCurrentImageRect.top) / mCurrentScale); mCroppedImageWidth = Math.round(mCropRect.width() / mCurrentScale); mCroppedImageHeight = Math.round(mCropRect.height() / mCurrentScale); //计算出图片是否需要被剪裁 boolean shouldCrop = shouldCrop(mCroppedImageWidth, mCroppedImageHeight); Log.i(TAG, "Should crop: " + shouldCrop); if (shouldCrop) &#123; //调用C++方法剪裁 boolean cropped = cropCImg(mImageInputPath, mImageOutputPath, cropOffsetX, cropOffsetY, mCroppedImageWidth, mCroppedImageHeight, mCurrentAngle, resizeScale, mCompressFormat.ordinal(), mCompressQuality, mExifInfo.getExifDegrees(), mExifInfo.getExifTranslation()); //剪裁成功复制图片EXIF信息 if (cropped &amp;&amp; mCompressFormat.equals(Bitmap.CompressFormat.JPEG)) &#123; ImageHeaderParser.copyExif(originalExif, mCroppedImageWidth, mCroppedImageHeight, mImageOutputPath); &#125; return cropped; &#125; else &#123; //直接复制图片到目标文件夹 FileUtils.copyFile(mImageInputPath, mImageOutputPath); return false; &#125;&#125; 3.3.3 GestureCropImageView这个类主要就是对手势的监听，所以我们简单粗暴，直接找他的onTouchEvent方法： 123456789101112131415161718192021222324252627282930313233343536/** * 如果是ACTION_DOWN event，用户触摸屏幕，必须取消所有当前动画。 * 如果是ACTION_UP event，用户从屏幕上取下所有手指，必须纠正当前图像位置。 * 如果有两个以上的手指-更新焦点坐标。 * 如果已启用，则将事件传递给手势检测器。 */@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; if ((event.getAction() &amp; MotionEvent.ACTION_MASK) == MotionEvent.ACTION_DOWN) &#123; cancelAllAnimations(); &#125; if (event.getPointerCount() &gt; 1) &#123; mMidPntX = (event.getX(0) + event.getX(1)) / 2; mMidPntY = (event.getY(0) + event.getY(1)) / 2; &#125; //双击监听和拖动监听 mGestureDetector.onTouchEvent(event); //两指缩放监听 if (mIsScaleEnabled) &#123; mScaleDetector.onTouchEvent(event); &#125; //旋转监听 if (mIsRotateEnabled) &#123; mRotateDetector.onTouchEvent(event); &#125; if ((event.getAction() &amp; MotionEvent.ACTION_MASK) == MotionEvent.ACTION_UP) &#123; //最后一指抬起时判断图片是否填充剪裁框 setImageToWrapCropBounds(); &#125; return true;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码</tag>
        <tag>uCrop</tag>
        <tag>图片处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Aria2macOS安装]]></title>
    <url>%2Fposts%2F4f46fdbb.html</url>
    <content type="text"><![CDATA[对不起大家，在我配置好这个软件之后，我兴冲冲的打开了github想下载下ssr4.0forWindows，迫不及待想感受下aria2的快感，结果发现我错了。下载速度就才几十k/s，那一瞬间，我感触很多，我突然想到我昨晚的迅雷下载同样的资源同样的网同样的vpn下大几百k/s 的速度，然后又看到了此时我给予希望的aria，我陷入了沉思，或许这就是人生吧。突然觉得macOS迅雷，也还挺好看的，也挺好用的，完全没有广告，要下载打开，下载完了就退出，唯一问题就是Chrome的迅雷拓展似乎太灵敏了点，我啥都没点就莫名其妙弹出下载页面，除了这个，似乎非常完美。所以，在我配置好aria2并写下这篇博客后的不到1个小时时间，我卸载了aira2，并重新用上了迅雷。所以，我最后只想说一句，财大nb！财大nb！财大nb！对不起，走错片场了，重来，IDM牛逼！IDM牛逼！IDM牛逼！如果哪位牛逼的大哥看到了这篇博客，记得帮我给IDM说声，一个Windows的IDM正版用户急需IDM macOS版！！！ 下载Aira2通过github安装 打开github主页 aria2/aria2-Release 找到对应的系统下载安装即可 通过Homebrew安装终端输入命令brew install aria2安装即可。没有安装Homebrew的同学可以搜索安装Homebrew即可。 这个软件是没有图形界面的，所以安装好之后在启动台里面是找不到Aria2的图标的 配置Aira2先创建Aria2的配置文件Aria2提供了两种工作模式： 直接命令行模式下载 不太推荐这种，因为命令行下下载比较繁琐，而且也不太好操作 RPC模式 在这种方式，Aria2启动之后就会以后台的方式运行，你就可以通过WebUI或者安装客户端的方式来使用图形界面控制Aria2.但是这种方式下需要配置文件，现在就告诉大家如何配置：首先创建文件 1234cd ~mkdir /.aria2cd /.aria2touch aria2.conf 然后打开Finder，使用快捷键Shift+Cmd+G弹出路径输入框，接着复制粘贴~/.aria2/回车就进入了.aria2文件夹，你就会看到里面的aria2.conf文件，接着用文本编辑器打开，复制粘贴以下内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#用户名#rpc-user=user#密码#rpc-passwd=passwd#上面的认证方式不建议使用,建议使用下面的token方式#设置加密的密钥#rpc-secret=token#允许rpcenable-rpc=true#允许所有来源, web界面跨域权限需要rpc-allow-origin-all=true#允许外部访问，false的话只监听本地端口rpc-listen-all=true#RPC端口, 仅当默认端口被占用时修改#rpc-listen-port=6800#最大同时下载数(任务数), 路由建议值: 3max-concurrent-downloads=5#断点续传continue=true#同服务器连接数max-connection-per-server=5#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要min-split-size=10M#单文件最大线程数, 路由建议值: 5split=10#下载速度限制max-overall-download-limit=0#单文件速度限制max-download-limit=0#上传速度限制max-overall-upload-limit=0#单文件速度限制max-upload-limit=0#断开速度过慢的连接#lowest-speed-limit=0#验证用，需要1.16.1之后的release版本#referer=*#文件保存路径, 默认为当前启动位置dir=/Users/xxx/Downloads#文件缓存, 使用内置的文件缓存, 如果你不相信Linux内核文件缓存和磁盘内置缓存时使用, 需要1.16及以上版本#disk-cache=0#另一种Linux文件缓存方式, 使用前确保您使用的内核支持此选项, 需要1.15及以上版本(?)#enable-mmap=true#文件预分配, 能有效降低文件碎片, 提高磁盘性能. 缺点是预分配时间较长#所需时间 none &lt; falloc ? trunc « prealloc, falloc和trunc需要文件系统和内核支持file-allocation=prealloc#开启BT下载enable-dht=truebt-enable-lpd=trueenable-peer-exchange=true# bt-tracker 更新，解决Aria2 BT下载速度慢没速度的问题udp://tracker.coppersurfer.tk:6969/announce,http://tracker.internetwarriors.net:1337/announce,udp://tracker.opentrackr.org:1337/announce,udp://9.rarbg.to:2710/announce,udp://9.rarbg.me:2710/announce,udp://tracker.openbittorrent.com:80/announce,http://tracker3.itzmx.com:6961/announce,http://tracker1.itzmx.com:8080/announce,udp://exodus.desync.com:6969/announce,udp://retracker.lanta-net.ru:2710/announce,udp://tracker.torrent.eu.org:451/announce,udp://tracker.tiny-vps.com:6969/announce,udp://bt.xxx-tracker.com:2710/announce,udp://tracker2.itzmx.com:6961/announce,udp://tracker.cyberia.is:6969/announce,udp://open.demonii.si:1337/announce,udp://explodie.org:6969/announce,udp://denis.stalker.upeer.me:6969/announce,udp://open.stealth.si:80/announce,http://tracker4.itzmx.com:2710/announce 不用更改啥，也不建议更改啥，大家可以看一下上面的配置内容，至少记得每一项大致是个啥，因为等会配置图形界面需要这些信息。 最后面的BT下载的bt-tracker大家配置记得到这个页面更新：https://raw.githubusercontent.com/ngosang/trackerslist/master/trackers_best.txt 然后再把内容复制粘贴过去。 下载路径你可以自己选择，可以就把/Users/xxx/Downloads中的xxx换成你自己的macOS用户名即可。 启动Aria2 RPC模式终端输入aria2c --conf-path=&quot;/Users/xxx/.aria2/aria2.conf&quot; -D就可以启动了。一样的，xxx是你的用户名。 进入图形界面Aria2有很多第三方图形界面，客户端有，但是我没用过所以我不做介绍，在这主要介绍WebUI。 YAAW插件 在chrome的拓展中心搜索YAAW，然后安装即可，接着就会出现YAAM的插件 点击打开它，就会进入YAAW的WebUI。 点击右上角的🔧图标，进入设置界面 如果你上面的aria2.conf是直接复制粘贴的我的话，照着我图中的填写就可以了，然后就可以使用了。找到需要下载的资源右键然后选择YAAW就会自动开始下载。 AriaNg WebUI这个比上面那个好看点，缺点是没有插件，你只能复制下载链接手动新建下载任务 在浏览器中输入网址 http://ariang.mayswind.net/latest/#!/downloading 点击AriaNg设置 一样，如果你上面的aria2.conf是直接复制粘贴的我的话，照着我图中的填写就可以了，然后就可以使用了。 你可以点击Aria2状态，看看是不是已连接，如果不是就看看有没有哪儿和aria2.conf设置的不一样。 关闭Aria2这个好像官方没有方法关闭，于是我们就用最简单粗暴的方法。 终端输入ps aux|grep aria2得到Aria2的进程号 然后输入kill number调用系统命令直接杀死这个进程，number改为上面的到的进程号即可。 配置自启动创建sh文件进入到希望保存的目录下，新建一个文件aria2.sh： 1touch aria2.sh 然后输入下面的代码并保存： 12345#!/bin/bashecho &quot;start aria2 server&quot;aria2c --conf-path=&quot;/Users/xxx/.aria2/aria2.conf&quot; -Decho &quot;exiting&quot;exit 修改文件权限 给aria2.sh文件执行权限：chmod +x aria2.sh 让aria2.sh默认用自己常用的terminal工具打开。右键文件 －&gt; 显示简介：设置“打开方式-&gt;所有应用程序”为自己的terminal即可。 添加到开机启动项 在Mac桌面顶部菜单中，点击苹果图标，在弹出的菜单中，点击进入系统偏好设置。 在打开系统偏好设置后，然后点击进入用户与群组设置选项。 然后在用户与群组设置界面，先在左侧选择登陆用户-当前用户，然后在右侧切换到登录项 然后点下面的+进行添加，选择刚才我们创建的文件aria2.sh，并勾选隐藏。这样 aria2 就可以在每次开机的时候自启动了。 最后，Aria2卸载方式终端下执行sudo pkgutil --forget aria2以及sudo pkgutil --forget aria2.path，然后上面创建的.aria2文件夹]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Aria2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统3--进程的同步]]></title>
    <url>%2Fposts%2F362e394f.html</url>
    <content type="text"><![CDATA[大家可以看下我使用幕布软件画的思维导图，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员https://mubu.com/inv/477598 3.1 进程同步3.1.1 同步概念3.1.1.1 进程同步的概念进程同步机制的主要任务就是对多个相关进程在执行次序上进行协调，使并发执行的进程之间能按照一定的规则共享系统资源，并能很好的配合工作，从而使程序的执行具有可再现性。 3.1.1.2 制约关系对于处于同一个系统中的多个进程，由于他们共享着系统的资源，或者为了完成同一个任务而相互合作，所以他们之间可能存在下面两种制约关系： 间接相互制约关系 系统中的进程难免会调用像打印机、CPU等这样的临界资源。如果想这些资源正常调用，必须保证多个进程之间互斥地访问这些资源，进而就在这些进程间形成了间接相互制约关系。 为了保证这些进程能有序的进行，对于系统中的这类资源，必须由系统实施统一分配，即用户在使用之前必须先提出申请，绝不允许用户直接使用。 直接相互制约关系 在系统中也会存在一些进程，他们为了完成同一个目标而相互配合合作工作，这种就是直接互相制约关系。 进程间的直接制约关系就是源于他们之间的相互合作。 3.1.1.3 临界资源虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。此外，如果变量、数据等都可以被若干进程共享，也属于临界资源。 3.1.1.4 临界区人们把在每个进程中访问临界资源的那段代码称为临界区。若能保证诸进程互斥地进入自己的临界区，便可实现诸进程对临界资源的互斥访问。为此，每个进程在进入临界区之前，应先对要访问的临界区进程检查：如果临界区正在被访问，则进程不能进入临界区；如果临界区没有被访问，那进程就可进入临界区，并将临界区正在被访问的标志置为正被访问。所以，我们可以将访问临界资源的线程的循环代码分为如下部分： 访问临界区之前用于上述判断的代码区称为进入区 在访问完临界区之后用于将临界区正被访问的标志恢复为未被访问的标志的代码区称为退出区 除了进入去、临界区、退出区代码之外的其它代码称为剩余区 123456while (true) &#123; 进入区 临界区 退出区 剩余区&#125; 3.1.1.5 同步机制应遵循的规则 空闲让进：当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效的利用临界资源 忙则等待：当已有进程进入临界区，表明临界资源正在被访问，因而其它视图进入临界区的进程必须等待，以保证对临界资源的互斥访问 有限等待：对要求访问临界资源的进程，应保证在有限的时间内能进入自己的临界区，以免陷入“死等”状态 让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态 3.1.2 同步机制3.2.2.1 信号量机制1. 什么是信号量信号量的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程，值则与相应的资源的使用情况有关： 当他的值大于0时，表示当前可用资源的数量 当他的值小于0时，其绝对值表示等待使用该资源的进程个数 2. 什么是信号量机制信号量机制即利用pv操作对信号量进行处理。而且信号量只能由pv操作进程处理。当S&gt;0时，S表示可用资源的数量。执行一次P操作意味着分配一个单位资源，因此S值减1；当S&lt;0时，表示已经没有可用资源，请求者必须等待别的进程释放该类资源，他才能运行下去。而执行一个V操作以为着释放一个单位资源，因此S的值加1；当S&gt;0，表示有某些资源正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去。 3.2.2.2 PV操作1. P操作申请一个单位资源，进程进入临界区 1234wait (S) &#123; while (s &lt;= 0) ;// 如果没有资源则循环等待 S--;&#125; 将信号量S的值减1，即S=S-1； 如果S&lt;=0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。 2. V操作释放一个单位资源，进程从临界区出来 123signal (S) &#123; S++;&#125; 将信号量S的值加1，即S=S+1； 如果S&gt;0，则该进程继续执行；否则释放队列中第一个等待信号量的进程。 3. PV操作的意义用PV操作来实现进程的同步和互斥 3.2.3 管程机制尽管信号量机制很方又高效，但是每个要访问临界资源的进程都必须必备同步操作，这就使得大量的同步操作分散在各个进程中。这不仅给系统的管理带来麻烦，还会因同步操作不当而产生死锁。为了解决上述问题，变产生了一种新的同步工具——管程。 1. 管程的定义系统中各种硬件资源和软件资源均可用数据结构抽象地描述其资源特征，即用少量信息和对该资源所执行的操作来表征该资源。所以就出现了管程。管程可以看成一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。在管程入口处的等待队列称为入口等待队列，由于进程会执行唤醒操作，因此可能有多个等待使用管程的队列，这样的队列称为紧急队列，它的优先级高于等待队列。 2. 管程的特征 模块化 管程是一个基本的软件模块，可以单独编译 抽象数据类型 管程中封装了数据及对于数据的操作 信息隐藏 管程外的进程或其他软件模块只能通过管程对外的接口来访问管程提供的操作，管程内部的实现细节对外界是透明的 使用的互斥性 任何一个时刻，管程只能由一个进程使用。进入管程时的互斥由编译器负责完成 3. 条件变量一个进程被阻塞或挂起的条件（原因）有多个，因此在管程中设置了多个条件变量，对这些条件变量的访问只能在管程中进行。管程中每个条件变量都需予以说明，形式为：condition x。对其的操作只有wait和signal，其含义是： x.wait：正在调用管程的进程因x条件需要被阻塞或挂起，则调用x.wait将自己插入到x条件的等待队列上，并释放管程，知道x条件发生变化。此时其它进程可以使用该管程。 x.signal： 正在调用管程的进程发现x条件发生了变化，则调用x.signal，重新启动一个因x条件而阻塞或挂起的进程，如果存在多个这样的进程，则选择其中的一个，如果没有，继续执行原进程，不产生任何结果。（与信号量的signal不同，没有s=s+1的操作） 3.2 进程同步的经典问题3.2.1 生产者-消费者问题1. 问题描述有一群生产者进程在生产产品，并将这些产品提供给消费者进程去消费。为使生产者进程与消费者进程能并发执行，在两者之间设置了一个大小为n的缓冲区，生产者进程将其所产生的产品放入缓冲区中；消费者可从缓冲区中取走产品去消费。他们之间必须保持同步，也就是既不允许消费者进程到一个空缓冲区去取产品，也不允许生产者进程向一个已装满产品且尚未被取走的缓冲区中投放产品。 2. 问题分析需要注意的几点： 在缓冲区为空时，消费者不能再进行消费 在缓冲区已满时，生产者不能再进行生产 当一个线程进行生产或消费时，其余线程不能再进行生产或消费 3. 伪代码12345678910111213141516171819202122232425262728293031var items = 0, space = 10, mutex = 1;var in = 0, out = 0;item buf[10] = &#123; NULL &#125;;producer &#123; while( true ) &#123; wait( space ); // 等待缓冲区有空闲位置， 在使用PV操作时，条件变量需要在互斥锁之前 wait( mutex ); // 保证在product时不会有其他线程访问缓冲区 // product buf.push( item, in ); // 将新资源放到buf[in]位置 in = ( in + 1 ) % 10; signal( mutex ); // 唤醒的顺序可以不同 signal( items ); // 通知consumer缓冲区有资源可以取走 &#125;&#125;consumer &#123; while( true ) &#123; wait( items ); // 等待缓冲区有资源可以使用 wait( mutex ); // 保证在consume时不会有其他线程访问缓冲区 // consume buf.pop( out ); // 将buf[out]位置的的资源取走 out = ( out + 1 ) % 10; signal( mutex ); // 唤醒的顺序可以不同 signal( space ); // 通知缓冲区有空闲位置 &#125;&#125; 不能将线程里两个wait的顺序调换否则会出现死锁。例如(调换后)，将consumer的两个wait调换，在producer发出signal信号后，如果producer线程此时再次获得运行机会，执行完了wait(space)，此时，另一个consumer线程获得运行机会，执行了wait(mutex)，如果此时缓冲区为空，那么consumer将会阻塞在wait(items)，而producer也会因为无法获得锁的所有权所以阻塞在wait(mutex)，这样两个线程都在阻塞，也就造成了死锁。 3.2.2 哲学家进餐问题1. 问题描述有五位哲学家共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五支筷子。他们的生活的方式是交替的进行思考和进餐：平时，一个哲学家进行思考，饥饿时便视图取其左右离他最近的筷子，只有在他拿到两只筷子时才能进餐，进餐完毕，放下筷子继续思考。 2. 问题分析 只有拿到两只筷子时，哲学家才能吃饭。 如果筷子已被别人拿走，则必须等别人吃完之后才能拿到筷子。 任一哲学家在自己未拿到两只筷子吃完饭前，不会放下手中已经拿到的筷子 3. 伪代码至多只允许四个哲学家同时进餐，以保证至少有一个哲学家能够进餐，最终总会释放出他所使用过的两支筷子，从而可使更多的哲学家进餐。定义信号量count，只允许4个哲学家同时进餐，这样就能保证至少有一个哲学家可以就餐。 12345678910111213141516semaphore chopstick[5]=&#123;1,1,1,1,1&#125;;semaphore count=4; // 设置一个count，最多有四个哲学家可以进来void philosopher(int i)&#123; while(true) &#123; think(); wait(count); //请求进入房间进餐 当count为0时 不能允许哲学家再进来了 wait(chopstick[i]); //请求左手边的筷子 wait(chopstick[(i+1)%5]); //请求右手边的筷子 eat(); signal(chopstick[i]); //释放左手边的筷子 signal(chopstick[(i+1)%5]); //释放右手边的筷子 signal(count); //离开饭桌释放信号量 &#125;&#125; 3.2.3 读者-写者问题1. 问题描述一个数据文件或记录可被多个进程共享，我们把只要求读该文件的进程称为“Reader进程”，其它进程则称为“Writer进程”。允许多个进程同时读一个共享对象，因为读操作不会使数据文件混乱。但不允许一个Writer进程和其它Reader进程或Writer进程同时访问共享对象，这样很有可能造成共享数据混乱。 2. 问题分析 允许多个Reader进程同时操作一个共享对象 不允许Writer进程和其它进程同时操作一个共享对象 3. 伪代码12345678910111213141516171819202122232425semaphore rmutex = 1,wmutex = 1;int readcount = 0;void reader()&#123; do&#123; wait(rmutex); if(readcount==0) wait(wmutex); readcount++; signal(rmutex); ··· perform read operation; ··· wait（rmutex）； if(readcount==0) signal(wmutex); readcount--; signal(rmutex); &#125;while(TRUE);&#125;void writer()&#123; do&#123; wait(wmutex); perfrom write operation; signal(wmutex); &#125;while(TRUE);&#125;]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android网络请求3--解析OkHttp源码]]></title>
    <url>%2Fposts%2F151ac78a.html</url>
    <content type="text"><![CDATA[1. OkHttp简介okhttp是一个第三方类库，用于android中请求网络。 这是一个开源项目,是安卓端最火热的轻量级框架,由移动支付Square公司贡献。用于替代因移除了HttpClient而导致没用的Volley。 目前更多人选择了Retrofit。 2. 源码解析 本文对OkHttp的探讨全部基于目前的最新版OkHttp:4.0.1，而这个版本作者已经使用kotlin对源码进行了重写，所以有些小伙伴可能阅读稍微有点问题，但是别担心，本文中所涉及的源码阅读起来基本上和Java一样，所以请不会kotlin的小伙伴还是耐心看下去，不太懂的语法就百度下，同时我也会对某些语法作注释 2.1 OkHttp请求流程2.1.1 从请求处理开始分析我们无论在使用OkHttp进行什么请求的时候都会创建OkHttpClient对象并调用他的newCall()方法，那我们就从这个方法看起： 123override fun newCall(request: Request): Call &#123;return RealCall.newRealCall(this, request, forWebSocket = false)&#125; 可以看到返回了一个RealCall对象，所以也就意味着我们使用OkHttpClient对象调用的execute()操作实际上是RealCall的execute()操作，那我们就来看RealCall的execute()方法： 123456789101112131415161718192021override fun execute(): Response &#123; // 添加同步锁 synchronized(this) &#123; // check()是kotlin特有的一个方法，他本质上就是一个if， // 但是当他的判断语句是false的话， // 他就会抛出一个IllegalStateException异常，异常的内容就是后面的语句 check(!executed) &#123; "Already Executed" &#125; executed = true // executed是一个布尔值，他的作用就是判断是不是执行过了， // 如果执行过了还执行了这个方法的话就抛异常 &#125; // transmitter用于连接OKHTTP的应用程序和网络层，不用多管 transmitter.timeoutEnter() transmitter.callStart() try &#123; client.dispatcher.executed(this) return getResponseWithInterceptorChain() &#125; finally &#123; client.dispatcher.finished(this) &#125;&#125; 这块又调用了client.dispatcher，然后找回去找到OkHttpClient的dispatcher对象，发现他就是Dispatcher类的一个对象，接着我们继续看Dispatcher类。 2.1.2 Dispatcher任务调度进入Dispatcher类，我们可以看到如下成员变量定义: 注：kotlin中一个成员变量的@get和@set分别对应了Java中get和set方法，所以这块我没有完完全全复制粘贴到这，我只取了定义部分 123456789101112// 最大并发请求数var maxRequests = 64// 每个主机的最大请求数var maxRequestsPerHost = 5// 消费者线程val executorService: ExecutorService// 将要运行的异步请求队列private val readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()// 正在运行的异步请求队队列private val runningAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()// 正在运行的同步请求队列private val runningSyncCalls = ArrayDeque&lt;RealCall&gt;() 接下来我们看看Dispatcher的构造方法 123456// 主构造方法，没写具体实现class Dispatcher constructor() &#123;&#125; constructor(executorService: ExecutorService) : this() &#123; this.executorServiceOrNull = executorService&#125; 我们可以看到他将传进来的executorService传给了executorServiceOrNull，那我们来看看executorServiceOrNull的定义： 123456789101112// executorServiceOrNull这个应该是因为kotlin的空安全检查特性而定义的，本质上就是executorServiceprivate var executorServiceOrNull: ExecutorService? = null@get:Synchronized@get:JvmName("executorService") val executorService: ExecutorService get() &#123; if (executorServiceOrNull == null) &#123; executorServiceOrNull = ThreadPoolExecutor(0, Int.MAX_VALUE, 60, TimeUnit.SECONDS, SynchronousQueue(), threadFactory("OkHttp Dispatcher", false)) &#125; return executorServiceOrNull!! &#125; 我们可以看到executorService的set方法，就是创建了一个线程池。再结合他有两个构造器就知道：如果没有给Dispatcher传入一个线程池他就会自己创建一个线程池。这个线程池适合执行大量且耗时较少的任务。 构造器我们看完了，我们就来看他的enqueue()方法： 12345678910111213internal fun enqueue(call: AsyncCall) &#123; synchronized(this) &#123; readyAsyncCalls.add(call) // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to // the same host. if (!call.get().forWebSocket) &#123; val existingCall = findExistingCallWithHost(call.host()) if (existingCall != null)call.reuseCallsPerHostFrom(existingCall) &#125; &#125; promoteAndExecute()&#125; 来一个请求就把他添加到就绪请求队列中去，然后就来判断forWebSocket这个属性。看到这个属性我还迷了下，有点搞不懂她是干嘛的，然后经过我的一番搜索后，发现原来OkHttp还可以进行WebSocket通信，而这个属性就是为WebSocket通信准备的。于是我就到RealCall里面找在哪儿定义了这个属性了，然后我就发现了在RealCall的newRealCall()方法这块，这个方法传入的参数中有一个Boolean值名字就叫forWebSocket。 123456789101112companion object &#123; fun newRealCall( client: OkHttpClient, originalRequest: Request, forWebSocket: Boolean ): RealCall &#123; // Safely publish the Call instance to the EventListener. return RealCall(client, originalRequest, forWebSocket).apply &#123; transmitter = Transmitter(client, this) &#125; &#125;&#125; 不知道大家有没有印象，咱们在上面说过，执行OkHttpClient.newCall()方法实际上是返回了一个RealCall对象，于是在那找到了这个的答案，forWebSocket=false所以说这个if咱们不用管，直接看promoteAndExecute()方法： 12345678910111213141516171819202122232425262728293031private fun promoteAndExecute(): Boolean &#123; // 不知道大家还记不记得咱们之前说的kotlin里面的check()语法， // 这个和check也一样，只不过抛出的是AssertionError异常 assert(!Thread.holdsLock(this)) // mutableListOf是kotlin里面的可变list集合 val executableCalls = mutableListOf&lt;AsyncCall&gt;() val isRunning: Boolean synchronized(this) &#123; val i = readyAsyncCalls.iterator() while (i.hasNext()) &#123; val asyncCall = i.next() if (runningAsyncCalls.size &gt;= this.maxRequests) break // 最大容量 if (asyncCall.callsPerHost().get() &gt;= this.maxRequestsPerHost) continue // 主机最大容量 i.remove() asyncCall.callsPerHost().incrementAndGet() executableCalls.add(asyncCall) runningAsyncCalls.add(asyncCall) &#125; isRunning = runningCallsCount() &gt; 0 &#125; for (i in 0 until executableCalls.size) &#123; val asyncCall = executableCalls[i] asyncCall.executeOn(executorService) &#125; return isRunning&#125; 首先将已就绪队列遍历一遍，判断正在运行的数量是不是大于定义的最大请求数，如果大于的话直接退出循环；如果不大于则在判断这个请求的主机请求数是不是大于定义的每个主机最大请求数，如果大于就跳过这个请求换下一个请求；不大于就把它调入正在运行的请求队列里面，直到遍历完成。然后判断还有没有正在运行的请求，如果有就isRunning置true。接着再取出executableCalls里的每一个元素，然后执行executteOn()方法。我们继续来看AsyncCall的executeOn()方法： 1234567891011121314151617fun executeOn(executorService: ExecutorService) &#123; assert(!Thread.holdsLock(client.dispatcher)) var success = false try &#123; executorService.execute(this) success = true &#125; catch (e: RejectedExecutionException) &#123; val ioException = InterruptedIOException("executor rejected") ioException.initCause(e) transmitter.noMoreExchanges(ioException) responseCallback.onFailure(this@RealCall, ioException) &#125; finally &#123; if (!success) &#123; client.dispatcher.finished(this) // This call is no longer running! &#125; &#125;&#125; 这段代码就是在执行线程池中的线程，如果成功执行就将success置true，如果不成功，则抛异常并返回给responseCallback的onFailure()方法。并且如果没有成功执行也就是success为false，那么在finally中就会执行client.dispatcher.finished()方法: 1234internal fun finished(call: AsyncCall) &#123; call.callsPerHost().decrementAndGet() finished(runningAsyncCalls, call) &#125; 这个方法先将传入的AsyncCall的callsPerHost给减1，然后再调用了finished()方法，我们再来看这个finished()方法： 12345678910111213private fun &lt;T&gt; finished(calls: Deque&lt;T&gt;, call: T) &#123; val idleCallback: Runnable? synchronized(this) &#123; if (!calls.remove(call)) throw AssertionError("Call wasn't in-flight!") idleCallback = this.idleCallback &#125; val isRunning = promoteAndExecute() if (!isRunning &amp;&amp; idleCallback != null) &#123; idleCallback.run() &#125;&#125; 他讲此次请求从runningAsyncCalls中移除，然后执行了promoteAndExecute()方法，咱们在上面说过这个方法，他的返回值就是判断当前这个运行队列中还有没有请求，如果还有就返回true，没有就false。接着一个if，判断isRunning和idleCallback的，那么如果当前这个请求还没有执行的话，就调用run()方法执行当前请求。这样每个请求都执行完毕了。那我们再来看看他的run()方法： 1234567891011121314151617181920override fun run() &#123; threadName("OkHttp $&#123;redactedUrl()&#125;") &#123; var signalledCallback = false transmitter.timeoutEnter() try &#123; val response = getResponseWithInterceptorChain() signalledCallback = true responseCallback.onResponse(this@RealCall, response) &#125; catch (e: IOException) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, "Callback failure for $&#123;toLoggableString()&#125;", e) &#125; else &#123; responseCallback.onFailure(this@RealCall, e) &#125; &#125; finally &#123; client.dispatcher.finished(this) &#125; &#125;&#125; 这块调用了一个getResponseWithInterceptorChain()方法，并返回了response，并将它返回给了responseCallback.onResponse()方法。如果失败了就将结果返回给responseCallback.onFailure()方法。最后调用client.dispatcher.finished()方法。 2.1.3 Interceptor拦截器2.1.3.1 getResponseWithInterceptorChain()方法首先我们看看getResponseWithInterceptorChain()方法： 12345678910111213141516171819202122232425262728293031323334@Throws(IOException::class)fun getResponseWithInterceptorChain(): Response &#123; // Build a full stack of interceptors. val interceptors = mutableListOf&lt;Interceptor&gt;() interceptors += client.interceptors interceptors += RetryAndFollowUpInterceptor(client) interceptors += BridgeInterceptor(client.cookieJar) interceptors += CacheInterceptor(client.cache) interceptors += ConnectInterceptor if (!forWebSocket) &#123; interceptors += client.networkInterceptors &#125; interceptors += CallServerInterceptor(forWebSocket) val chain = RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this, client.connectTimeoutMillis, client.readTimeoutMillis, client.writeTimeoutMillis) var calledNoMoreExchanges = false try &#123; val response = chain.proceed(originalRequest) if (transmitter.isCanceled) &#123; response.closeQuietly() throw IOException("Canceled") &#125; return response &#125; catch (e: IOException) &#123; calledNoMoreExchanges = true throw transmitter.noMoreExchanges(e) as Throwable &#125; finally &#123; if (!calledNoMoreExchanges) &#123; transmitter.noMoreExchanges(null) &#125; &#125;&#125; 首先就创建了一大堆的连接器并添加到interceptors集合中。然后创建了一个RealInterceptorChain对象，并调用了他的proceed()方法，接着主要目的就是讲proceed()返回的response给返回去。那我们就来看看RealInterceptorChain的proceed()方法： 1234567891011121314151617181920212223242526272829303132333435363738override fun proceed(request: Request): Response &#123; return proceed(request, transmitter, exchange)&#125; @Throws(IOException::class)fun proceed(request: Request, transmitter: Transmitter, exchange: Exchange?): Response &#123; if (index &gt;= interceptors.size) throw AssertionError() calls++ // If we already have a stream, confirm that the incoming request will use it. check(this.exchange == null || this.exchange.connection()!!.supportsUrl(request.url)) &#123; "network interceptor $&#123;interceptors[index - 1]&#125; must retain the same host and port" &#125; // If we already have a stream, confirm that this is the only call to chain.proceed(). check(this.exchange == null || calls &lt;= 1) &#123; "network interceptor $&#123;interceptors[index - 1]&#125; must call proceed() exactly once" &#125; // Call the next interceptor in the chain. val next = RealInterceptorChain(interceptors, transmitter, exchange, index + 1, request, call, connectTimeout, readTimeout, writeTimeout) val interceptor = interceptors[index] @Suppress("USELESS_ELVIS") val response = interceptor.intercept(next) ?: throw NullPointerException( "interceptor $interceptor returned null") // Confirm that the next interceptor made its required call to chain.proceed(). check(exchange == null || index + 1 &gt;= interceptors.size || next.calls == 1) &#123; "network interceptor $interceptor must call proceed() exactly once" &#125; check(response.body != null) &#123; "interceptor $interceptor returned a response with no body" &#125; return response &#125; 首先就是一个index，index是RealInterceptorChain构造器中传入的参数，她是第四个参数，所以我们看getResponseWithInterceptorChain()方法中创建RealInterceptorChain对象时构造器的第四个传入的值为0。然后判断index的值是不是大于interceptors的大小，如果大于就抛异常，否则就继续一顿检查！！！然后再创建RealInterceptorChain对象，此时创建的对象传入的index为此时的index+1，然后再调用interceptor的intercept()方法，并返回response。 interceptor的intercept()作用是当存在多个拦截器时都会在上面代码注释1处阻塞，并等待下一个拦截器的调用返回。 2.1.3.2 Interceptor源码那现在我们再来讲几个重要的拦截器吧。OkHttp中Interceptor的实现类有： ConnectInterceptor：连接拦截器。 CallServerInterceptor：请求服务器拦截器 CacheInterceptor：缓存拦截器 BridgeInterceptor：桥梁拦截器。 其中较为重要的就是ConnectInterceptor和CallServerInterceptor，那我们来看看这两个。 2.1.3.2.1 ConnectInterceptor这个类主要用来实现网络请求连接。我们来看下他的intercept方法： 123456789101112@Throws(IOException::class)override fun intercept(chain: Interceptor.Chain): Response &#123; val realChain = chain as RealInterceptorChain val request = realChain.request() val transmitter = realChain.transmitter() // We need the network to satisfy this request. Possibly for validating a conditional GET. val doExtensiveHealthChecks = request.method != "GET" val exchange = transmitter.newExchange(chain, doExtensiveHealthChecks) return realChain.proceed(request, transmitter, exchange)&#125; 这个方法先将传入的chain对象造型成了RealInterceptorChain的对象，这个类我们在上面提到过，然后调用他的response()和transmitter()方法，分别得到当前chain的response和transmitter。然后执行了request的method()方法，判断request的类型是不是GET，如果是doExtensiveHealthChecks就为false，否则为true，接着把doExtensiveHealthChecks传入transmitter的newExchange()方法中去，这个方法我们等会再说，然后再调用了proceed()方法，这个方法我们在上面说过。 2.1.3.2.2 CallServerInterceptor这个类是网络请求的本质。它的intercept方法源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103@Throws(IOException::class) override fun intercept(chain: Interceptor.Chain): Response &#123; val realChain = chain as RealInterceptorChain val exchange = realChain.exchange() val request = realChain.request() val requestBody = request.body val sentRequestMillis = System.currentTimeMillis() // 写入请求头 exchange.writeRequestHeaders(request) var responseHeadersStarted = false var responseBuilder: Response.Builder? = null // 写入请求体信息 if (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody != null) &#123; // 如果请求上有“expect:100 continue”头 // 请等待“http/1.1 100 continue”响应，然后再传输请求主体. // 如果我们没有得到，返回我们得到的（例如4xx响应），而不传输请求体。 if ("100-continue".equals(request.header("Expect"), ignoreCase = true)) &#123; exchange.flushRequest() responseHeadersStarted = true exchange.responseHeadersStart() responseBuilder = exchange.readResponseHeaders(true) &#125; if (responseBuilder == null) &#123; if (requestBody.isDuplex()) &#123; // 准备一个双工主体，以便应用程序稍后可以发送请求主体。 exchange.flushRequest() val bufferedRequestBody = exchange.createRequestBody(request, true).buffer() requestBody.writeTo(bufferedRequestBody) &#125; else &#123; // 如果满足“expect:100 continue”预期，则编写请求正文。 val bufferedRequestBody = exchange.createRequestBody(request, false).buffer() requestBody.writeTo(bufferedRequestBody) bufferedRequestBody.close() &#125; &#125; else &#123; exchange.noRequestBody() if (!exchange.connection()!!.isMultiplexed) &#123; // 如果不满足“expect:100 continue”的要求，请防止重用HTTP/1连接。 // 否则，我们仍然有义务传输请求主体以使连接保持一致状态。 exchange.noNewExchangesOnConnection() &#125; &#125; &#125; else &#123; exchange.noRequestBody() &#125; // 结束请求 if (requestBody == null || !requestBody.isDuplex()) &#123; exchange.finishRequest() &#125; if (!responseHeadersStarted) &#123; exchange.responseHeadersStart() &#125; if (responseBuilder == null) &#123; responseBuilder = exchange.readResponseHeaders(false)!! &#125; // 读取响应头信息 var response = responseBuilder .request(request) .handshake(exchange.connection()!!.handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build() var code = response.code if (code == 100) &#123; // 服务器发送了一个100继续，即使我们没有请求。 // 再次尝试读取实际响应 response = exchange.readResponseHeaders(false)!! .request(request) .handshake(exchange.connection()!!.handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build() code = response.code &#125; exchange.responseHeadersEnd(response) // openResponseBody 获取响应体信息 response = if (forWebSocket &amp;&amp; code == 101) &#123; // 连接正在升级，但我们需要确保拦截器看到非空的响应主体。 response.newBuilder() .body(EMPTY_RESPONSE) .build() &#125; else &#123; response.newBuilder() .body(exchange.openResponseBody(response)) .build() &#125; if ("close".equals(response.request.header("Connection"), ignoreCase = true) || "close".equals(response.header("Connection"), ignoreCase = true)) &#123; exchange.noNewExchangesOnConnection() &#125; if ((code == 204 || code == 205) &amp;&amp; response.body?.contentLength() ?: -1L &gt; 0L) &#123; throw ProtocolException( "HTTP $code had non-zero Content-Length: $&#123;response.body?.contentLength()&#125;") &#125; //返回一个响应 return response&#125; 具体过程可以看代码中的注释，它主要是向服务器发送请求数据和接受服务器返回的数据。 2.1.4 TransmiterTransmitter类是OkHttp的应用层和网络层的一个桥梁类。 我们先来看看该类的初始化： 12345678910111213class Transmitter( private val client: OkHttpClient, private val call: Call) &#123; private val connectionPool: RealConnectionPool = client.connectionPool.delegate private val eventListener: EventListener = client.eventListenerFactory.create(call) private val timeout = object : AsyncTimeout() &#123; override fun timedOut() &#123; cancel() &#125; &#125;.apply &#123; timeout(client.callTimeoutMillis.toLong(), MILLISECONDS) &#125; Transmitter主要的一些成员变量就这些，首先构造器中传入了两个参数，一个OkHttpClient，一个Call。然后又创建了一个连接池connectionPool，还有一个监听器，我们可以通过扩展这个类来监听程序的HTTP的调用数量、大小和持续时间。 2.1.5 RealConnection我们先看看他的一些属性： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class RealConnection( val connectionPool: RealConnectionPool, private val route: Route) : Http2Connection.Listener(), Connection &#123; // 以下字段由connect（）初始化，从不重新分配。 // 底层socket private var rawSocket: Socket? = null /** * 应用层套接字。如果此连接不使用SSL，则可以是[sslsocket]分层在[rawsocket]上，也可以是[rawsocket]本身。 */ // 应用层socket private var socket: Socket? = null // 握手 private var handshake: Handshake? = null // 协议 private var protocol: Protocol? = null // http2的连接 private var http2Connection: Http2Connection? = null // 与服务器交互的输入输出流 private var source: BufferedSource? = null private var sink: BufferedSink? = null // 跟踪连接状态下的字段由连接池保护。 /** * 如果为true，则不能在此连接上创建新的交换。一旦是true的，这总是true的。 * 由[ConnectionPool]监视。 */ var noNewExchanges = false /** * 建立可能由于所选路由而导致的流时出现问题的次数。由[ConnectionPool]保护。 */ internal var routeFailureCount = 0 internal var successCount = 0 private var refusedStreamCount = 0 /** * 此连接可以承载的最大并发流数。 * 如果“allocations.size（）&lt;allocationlimit”，则可以在此连接上创建新流。 */ private var allocationLimit = 1 接下来我们看看他的connect()方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788fun connect( connectTimeout: Int, readTimeout: Int, writeTimeout: Int, pingIntervalMillis: Int, connectionRetryEnabled: Boolean, call: Call, eventListener: EventListener) &#123; check(protocol == null) &#123; "already connected" &#125; // 线路的选择 var routeException: RouteException? = null val connectionSpecs = route.address.connectionSpecs val connectionSpecSelector = ConnectionSpecSelector(connectionSpecs) if (route.address.sslSocketFactory == null) &#123; if (ConnectionSpec.CLEARTEXT !in connectionSpecs) &#123; throw RouteException(UnknownServiceException( "CLEARTEXT communication not enabled for client")) &#125; val host = route.address.url.host if (!Platform.get().isCleartextTrafficPermitted(host)) &#123; throw RouteException(UnknownServiceException( "CLEARTEXT communication to $host not permitted by network security policy")) &#125; &#125; else &#123; if (Protocol.H2_PRIOR_KNOWLEDGE in route.address.protocols) &#123; throw RouteException(UnknownServiceException( "H2_PRIOR_KNOWLEDGE cannot be used with HTTPS")) &#125; &#125; // 连接开始 while (true) &#123; try &#123; // 如果要求隧道模式，建立通道连接，通常不是这种 if (route.requiresTunnel()) &#123; connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener) if (rawSocket == null) &#123; // 我们无法连接隧道，但适当关闭了我们的资源。 break &#125; &#125; else &#123; // 一般都走这条逻辑了，实际上很简单就是socket的连接 connectSocket(connectTimeout, readTimeout, call, eventListener) &#125; // https的建立 establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener) eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol) break &#125; catch (e: IOException) &#123; socket?.closeQuietly() rawSocket?.closeQuietly() socket = null rawSocket = null source = null sink = null handshake = null protocol = null http2Connection = null eventListener.connectFailed(call, route.socketAddress, route.proxy, null, e) if (routeException == null) &#123; routeException = RouteException(e) &#125; else &#123; routeException.addConnectException(e) &#125; if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) &#123; throw routeException &#125; &#125; &#125; if (route.requiresTunnel() &amp;&amp; rawSocket == null) &#123; throw RouteException(ProtocolException( "Too many tunnel connections attempted: $MAX_TUNNEL_ATTEMPTS")) &#125; val http2Connection = this.http2Connection if (http2Connection != null) &#123; synchronized(connectionPool) &#123; allocationLimit = http2Connection.maxConcurrentStreams() &#125; &#125;&#125; 首先检查是否已经建立连接，如果已经建立就抛异常，没有的话就继续。接着就得到了ConnectionSpecs，然后根据他建立了一个connectionSpecSelector集合。接着判断是不是安全连接，也就是ssl连接，如果不是的话就判断了一些属性，先确定是不是明文然后再确定主机能不能接受明文操作。接着就开始连接，判断是不是要进行隧道通信，如果是就调用connectTunnel()建立隧道通信，如果不是就调用connectSocket()建立普通的通信。然后通过establishProtocol()建立协议。如果是HTTP/2就设置相关属性。 然后我们就来看看他具体如何实现的，先看看connectSocket()方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243@Throws(IOException::class)private fun connectSocket( connectTimeout: Int, readTimeout: Int, call: Call, eventListener: EventListener) &#123; val proxy = route.proxy val address = route.address // 根据代理类型选择socket类型是代理还是直连 val rawSocket = when (proxy.type()) &#123; Proxy.Type.DIRECT, Proxy.Type.HTTP -&gt; address.socketFactory.createSocket()!! else -&gt; Socket(proxy) &#125; this.rawSocket = rawSocket eventListener.connectStart(call, route.socketAddress, proxy) rawSocket.soTimeout = readTimeout try &#123; // 连接socket，之所以这样写是因为支持不同的平台 // 里面实际上是 socket.connect(address, connectTimeout); Platform.get().connectSocket(rawSocket, route.socketAddress, connectTimeout) &#125; catch (e: ConnectException) &#123; throw ConnectException("Failed to connect to $&#123;route.socketAddress&#125;").apply &#123; initCause(e) &#125; &#125; // 下面的Try/Catch块是一种避免Android 7.0崩溃的伪黑客方法 // More details: // https://github.com/square/okhttp/issues/3245 // https://android-review.googlesource.com/#/c/271775/ try &#123; // 得到输入／输出流 source = rawSocket.source().buffer() sink = rawSocket.sink().buffer() &#125; catch (npe: NullPointerException) &#123; if (npe.message == NPE_THROW_WITH_NULL) &#123; throw IOException(npe) &#125; &#125;&#125; 首先先判断连接类型，如果是直连或者HTTP连接就直连，否则的话走Socket代理，然后通过eventListener.connectStart()方法创建连接，再设定超时-&gt;完成连接-&gt;创建用于I/O的source和sink。 我们接着再来看connectTunnel()方法： 123456789101112131415161718192021222324@Throws(IOException::class)private fun connectTunnel( connectTimeout: Int, readTimeout: Int, writeTimeout: Int, call: Call, eventListener: EventListener) &#123; var tunnelRequest: Request = createTunnelRequest() val url = tunnelRequest.url for (i in 0 until MAX_TUNNEL_ATTEMPTS) &#123; connectSocket(connectTimeout, readTimeout, call, eventListener) tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url) ?: break // 已成功创建隧道。 // 代理决定在身份验证质询后关闭连接。 // 我们需要创建一个新的连接，但这次需要使用身份验证凭据。 rawSocket?.closeQuietly() rawSocket = null sink = null source = null eventListener.connectEnd(call, route.socketAddress, route.proxy, null) &#125;&#125; 大体就是先创建隧道请求，然后建立socket连接，再发送请求建立隧道。 3. 请求流程图那我们最后来总结下 3.1 同步请求是如何操作的？ 3.2 异步请求是如何操作的？]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
        <tag>源码</tag>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android网络请求2--解析Volley源码]]></title>
    <url>%2Fposts%2Fdf8fd75e.html</url>
    <content type="text"><![CDATA[本文大篇幅参考此篇文章，大家可以结合两篇文章看一下 1. Volley简介在很早以前，如果Android开发者想使用网络请求的话，必须自己通过HttpClient或者HttpURLConnection编写代码来访问。但是他两的用法还是很复杂的，如果不适当的封装的话，就会有很多多余代码甚至效率降低。所以当时出现了很多第三方网络通信框架，但是都是第三方的，而谷歌官方一直没有作为。最终在2013年，谷歌终于意识到了问题，于是他们推出了一个官方的全新的网络框架——Volley。Volley它又能非常简单的进行HTTP通信，又能轻松加载网络上的图片。他的设计目的就是应对数据量不大但是频发的网络操作，但是对于下载等需要大数据量的网络操作，他就不太适合。 2. 源码解析2.1 从RequestQueue入手如果你使用Volley的话，就会发现Volley不管进行什么操作，首先第一步就是先创建RequestQueue对象。所以我们就可以认定他为Volley的入口。创建RequestQueue的方法是RequestQueue mQueue = Volley.newRequestQueue(getApplicationContext());,我们就看看newRequestQueue干了什么： 1234567891011121314151617181920212223242526272829public static RequestQueue newRequestQueue(Context context, BaseHttpStack stack) &#123; BasicNetwork network; if (stack == null) &#123; if (Build.VERSION.SDK_INT &gt;= 9) &#123; network = new BasicNetwork(new HurlStack()); &#125; else &#123; // 在Android 2.3之前，HttpURLConnection是不可靠的。 // 请参阅：http://android-developers.blogspot.com/2011/09/androids-http-clients.html // 在将来的某个时候，我们将把minsdkversion移到Android 2.2之上， // 并可以删除这个回退（连同所有ApacheHTTP代码）。 String userAgent = "volley/0"; try &#123; String packageName = context.getPackageName(); PackageInfo info = context.getPackageManager().getPackageInfo(packageName, /* flags= */ 0); userAgent = packageName + "/" + info.versionCode; &#125; catch (NameNotFoundException e) &#123; &#125; network = new BasicNetwork( new HttpClientStack(AndroidHttpClient.newInstance(userAgent))); &#125; &#125; else &#123; network = new BasicNetwork(stack); &#125; return newRequestQueue(context, network);&#125; 调用方法后，先查看Android版本是否大于等于2.3，如果大于则调用基于HttpURLConnection的HurlStack，否则调用基于HttpClient的HttpClientStack。接下来创建BasicNetwork并调用newRequestQueue(context, network)方，我们再来看看这个newRequestQueue()方法： 1234567891011121314151617181920private static RequestQueue newRequestQueue(Context context, Network network) &#123; final Context appContext = context.getApplicationContext(); // 对缓存目录使用惰性供应商，以便可以在主线程上调用newRequestQueue（）， // 而不会导致严格的模式冲突。 DiskBasedCache.FileSupplier cacheSupplier = new DiskBasedCache.FileSupplier() &#123; private File cacheDir = null; @Override public File get() &#123; if (cacheDir == null) &#123; cacheDir = new File(appContext.getCacheDir(), DEFAULT_CACHE_DIR); &#125; return cacheDir; &#125; &#125;; RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheSupplier), network); queue.start(); return queue;&#125; 可以看到，这个方法主要为Volley创建了一个硬盘缓存DiskBasedCache，然后通过这个磁盘缓存和Network创建了一个RequestQueue对象，并调用了start()方法，接下来我们看下start()方法: 123456789101112131415public void start() &#123; stop(); // 确保当前运行的所有调度程序都已停止。 // 创建缓存调度器并开始它。 mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery); mCacheDispatcher.start(); // 创建达到池大小的网络调度程序（和相应的线程）。 for (int i = 0; i &lt; mDispatchers.length; i++) &#123; NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery); mDispatchers[i] = networkDispatcher; networkDispatcher.start(); &#125;&#125; CacheDispatcher是一个缓存调度线程，并调用了start()方法。在循环中调用NetworkDispatcher的start()方法。NetworkDispatcher是网络调度线程，默认情况下mDispatchers.length为4，默认开启了4个调度线程，外加1个缓存调度线程，总共5个线程。接下来Volley会创建各种Request，并调用RequestQueue的add()方法： 123456789101112131415161718192021public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) &#123; // 将请求标记为属于此队列，并将其添加到当前请求集。 request.setRequestQueue(this); synchronized (mCurrentRequests) &#123; //mCurrentRequests是一个HashSet mCurrentRequests.add(request); &#125; // 按添加的顺序处理请求。 request.setSequence(getSequenceNumber()); request.addMarker("add-to-queue"); sendRequestEvent(request, RequestEvent.REQUEST_QUEUED); // 如果请求是不可执行的，跳过缓存队列，然后直接进入网络。 if (!request.shouldCache()) &#123; mNetworkQueue.add(request); return request; &#125; mCacheQueue.add(request); return request;&#125; 这块地方的代码就很简单了，就是根据request的shouldCache()方法来返回request的mShouldCache属性来判断是否可以缓存，默认是可以的。如果能缓存，将此请求加入mCacheQueue队列，不再重复请求；不可以的话就将请求加入网络请求队列mNetworkQueue。 2.2 CacheDispatcher缓存调度线程RequestQueue的add()方法并没有请求网络或者对缓存进行操作。当将请求添加到网络请求队 列或者缓存队列时，在后台的网络调度线程和缓存调度线程轮询各自的请求队列，若发现有请求任务则开 始执行。下面先看看缓存调度线程。 首先先来看看CacheDispatcher的add()方法： 123456789101112131415161718192021222324252627@Overridepublic void run() &#123; if (DEBUG) VolleyLog.v("start new dispatcher"); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); // Process.THREAD_PRIORITY_BACKGROUND默认值为10 // 进行阻塞调用以初始化缓存。 mCache.initialize(); while (true) &#123; try &#123; processRequest(); &#125; catch (InterruptedException e) &#123; // 可能被打断了，因为是时候要退出了。 if (mQuit) &#123; Thread.currentThread().interrupt(); return; &#125; VolleyLog.e( "Ignoring spurious interrupt of CacheDispatcher thread; " + "use quit() to terminate it"); // 忽略cachedispatcher线程的假中断； // 使用quit（）终止它 &#125; &#125;&#125; 这块可以看出主要就是初始化了缓存队列，然后开了个死循环，一直调用processRequest()，我们来看看这个方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182private void processRequest() throws InterruptedException &#123; // 从CacheQueue中取出一个可用的request final Request&lt;?&gt; request = mCacheQueue.take(); processRequest(request);&#125;@VisibleForTestingvoid processRequest(final Request&lt;?&gt; request) throws InterruptedException &#123; request.addMarker("cache-queue-take"); request.sendEvent(RequestQueue.RequestEvent.REQUEST_CACHE_LOOKUP_STARTED); try &#123; //request如果被取消了，就直接返回 if (request.isCanceled()) &#123; request.finish("cache-discard-canceled"); return; &#125; Cache.Entry entry = mCache.get(request.getCacheKey()); // 没有缓存就把request添加到NetworkQueue中 if (entry == null) &#123; request.addMarker("cache-miss"); // 没有缓存，并且等待队列中也没有此request，那么就直接加入到NetworkQueue中 if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123; mNetworkQueue.put(request); &#125; return; &#125; // 如果缓存过期了，也是一样把request添加到NetworkQueue中 if (entry.isExpired()) &#123; request.addMarker("cache-hit-expired"); request.setCacheEntry(entry); if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123; mNetworkQueue.put(request); &#125; return; &#125; // 有缓存并且没有过期 request.addMarker("cache-hit"); // 根据缓存的内容解析 Response&lt;?&gt; response = request.parseNetworkResponse( new NetworkResponse(entry.data, entry.responseHeaders)); request.addMarker("cache-hit-parsed"); // 是否需要更新 if (!entry.refreshNeeded()) &#123; // 不需要更新，直接将结果调度到主线程 mDelivery.postResponse(request, response); &#125; else &#123; request.addMarker("cache-hit-refresh-needed"); request.setCacheEntry(entry); response.intermediate = true; // 判断是否有相同缓存键的任务在执行 if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123; // 需要更新结果，先将结果调度到主线程，然后执行new runnable()&#123;&#125; // runnable中就是将request添加到NetworkQueue中，更新一下内容 mDelivery.postResponse( request, response, new Runnable() &#123; @Override public void run() &#123; try &#123; mNetworkQueue.put(request); &#125; catch (InterruptedException e) &#123; // Restore the interrupted status Thread.currentThread().interrupt(); &#125; &#125; &#125;); &#125; else &#123; // request已经加入到mWaitingRequests中 // 直接把结果调度到主线程 mDelivery.postResponse(request, response); &#125; &#125; &#125; finally &#123; request.sendEvent(RequestQueue.RequestEvent.REQUEST_CACHE_LOOKUP_FINISHED); &#125;&#125; 我们在processRequest中可以看到有一个方法经常出现，那就是mWaitingRequestManager.maybeAddToWaitingRequests(request)，它的作用是判断当前这个request是否有存在相同缓存键的请求已经处于运行状态，如果有，那么就将这个request加入到一个等待队列中，等到相同缓存键的请求完成。 总结一下CacheDispatcher主要步骤： 从CacheQueue中循环取出request； 如果缓存丢失，加入到NetworkQueue中； 如果缓存过期，加入到NetworkQueue中； 将缓存中的数据解析成Response对象； 如果不需要更新，直接将结果回调到主线程，回调操作等介绍完NetworkDispatcher之后一起深入剖析； 如果需要更新，先将结果回调到主线程，然后再将request加入到NetworkQueue中。 下面来看看网络调度线程。 2.3 NetWorkDispatcher网络调度线程NetworkDispatcher的run方法代码如下所示: 123456789101112131415161718@Overridepublic void run() &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); while (true) &#123; try &#123; processRequest(); &#125; catch (InterruptedException e) &#123; // 我们可能被打断了，因为是时候退出了。 if (mQuit) &#123; Thread.currentThread().interrupt(); return; &#125; VolleyLog.e( "Ignoring spurious interrupt of NetworkDispatcher thread; " + "use quit() to terminate it"); &#125; &#125;&#125; 由此可以看出，NetWordDispatch和CacheDispatch非常类似。他的run()方法和CacheDispatch的方法基本一样，这就不多做介绍，下面来看看他的processRequest()方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private void processRequest() throws InterruptedException &#123; // 从NetworkQueue中取出request Request&lt;?&gt; request = mQueue.take(); processRequest(request);&#125;@VisibleForTestingvoid processRequest(Request&lt;?&gt; request) &#123; long startTimeMs = SystemClock.elapsedRealtime(); request.sendEvent(RequestQueue.RequestEvent.REQUEST_NETWORK_DISPATCH_STARTED); try &#123; request.addMarker("network-queue-take"); // 如果request被取消了，那么就不执行此request if (request.isCanceled()) &#123; request.finish("network-discard-cancelled"); request.notifyListenerResponseNotUsable(); return; &#125; addTrafficStatsTag(request); // 还记得这个mNetwork么，它就是Volley.newRequestQueue()方法里的BasicNetwork对象，一会我们来看看mNetwork.performRequest()方法是如何得到NetworkResponse的 NetworkResponse networkResponse = mNetwork.performRequest(request); request.addMarker("network-http-complete"); // notModified是服务端返回304，hasHadResponseDelivered()是request已经回调过了 if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123; request.finish("not-modified"); request.notifyListenerResponseNotUsable(); return; &#125; // 将NetworkResponse解析成Response对象，在子线程中执行 Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse); request.addMarker("network-parse-complete"); // 将request写入缓存 if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123; mCache.put(request.getCacheKey(), response.cacheEntry); request.addMarker("network-cache-written"); &#125; request.markDelivered(); // 回调结果至主线程 mDelivery.postResponse(request, response); request.notifyListenerResponseReceived(response); &#125; // 以下都是处理异常错误，然后也需要回调至主线程 catch (VolleyError volleyError) &#123; volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs); parseAndDeliverNetworkError(request, volleyError); request.notifyListenerResponseNotUsable(); &#125; catch (Exception e) &#123; VolleyLog.e(e, "Unhandled exception %s", e.toString()); VolleyError volleyError = new VolleyError(e); volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs); mDelivery.postError(request, volleyError); request.notifyListenerResponseNotUsable(); &#125; finally &#123; request.sendEvent(RequestQueue.RequestEvent.REQUEST_NETWORK_DISPATCH_FINISHED); &#125;&#125; 通过NetworkDispatcher.processRequest()方法可以发现，主要分为以下几步： 通过BasicNetwork.performRequest(request)得到NetworkResponse对象； 通过request.parseNetworkResponse(networkResponse)解析得到Response对象； 通过mDelivery将成功结果或者失败结果回调到主线程。 现在我们依次来分析这三步： 请求网络，得到NetworkResponse 我们看看BasicNetwork的performRequest()方法： 123456789101112131415161718192021222324252627@Overridepublic NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123; long requestStart = SystemClock.elapsedRealtime(); while (true) &#123; HttpResponse httpResponse = null; byte[] responseContents = null; List&lt;Header&gt; responseHeaders = Collections.emptyList(); try &#123; // Gather headers. Map&lt;String, String&gt; additionalRequestHeaders = getCacheHeaders(request.getCacheEntry()); httpResponse = mBaseHttpStack.executeRequest(request, additionalRequestHeaders); int statusCode = httpResponse.getStatusCode(); responseHeaders = httpResponse.getHeaders(); // Handle cache validation. if (statusCode == HttpURLConnection.HTTP_NOT_MODIFIED) &#123; Entry entry = request.getCacheEntry(); if (entry == null) &#123; return new NetworkResponse( HttpURLConnection.HTTP_NOT_MODIFIED, /* data= */ null, /* notModified= */ true, SystemClock.elapsedRealtime() - requestStart, responseHeaders); &#125; …………省略 通过上面源码可以看出，BasicNetwork就是封装了一下NetworkResponse，并没有涉及到网络请求，我们继续深入到BaseHttpStack.executeRequest(request, additionalRequestHeaders)源码中。 123public abstract HttpResponse executeRequest( Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders) throws IOException, AuthFailureError; 这时发现这个BaseHttpStack就是一个抽象类，而这个executeRequest()也就是一个抽象方法。我当时就卡在这了，调用了一个抽象类的抽象方法，这咋操作嘛。然后我就好好再看了一遍，找到BasicNetwork的构造函数中对mBaseHttpStck定义的地方，发现这个是构造函数传进来的，然后就想到了在调用Volley.newRequestQueue()时，是根据Android版本传入了不同的Stack，那我们就来看看HurlStack.executeRequest()方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overridepublic HttpResponse executeRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders) throws IOException, AuthFailureError &#123; String url = request.getUrl(); HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.putAll(additionalHeaders); // request.getheaders（）优先于给定的附加（缓存）头. map.putAll(request.getHeaders()); if (mUrlRewriter != null) &#123; String rewritten = mUrlRewriter.rewriteUrl(url); if (rewritten == null) &#123; throw new IOException("URL blocked by rewriter: " + url); &#125; url = rewritten; &#125; URL parsedUrl = new URL(url); HttpURLConnection connection = openConnection(parsedUrl, request); boolean keepConnectionOpen = false; try &#123; for (String headerName : map.keySet()) &#123; connection.setRequestProperty(headerName, map.get(headerName)); &#125; setConnectionParametersForRequest(connection, request); // 使用来自httpurlConnection的数据初始化httpResponse。 int responseCode = connection.getResponseCode(); if (responseCode == -1) &#123; // 如果无法检索响应代码，getResponseCode（）将返回-1。 // 向呼叫者发出信号，说明连接有问题。 throw new IOException("Could not retrieve response code from HttpUrlConnection."); &#125; if (!hasResponseBody(request.getMethod(), responseCode)) &#123; return new HttpResponse(responseCode, convertHeaders(connection.getHeaderFields())); &#125; // 需要保持连接打开，直到调用方使用流。包装流，以便close（）将断开连接。 keepConnectionOpen = true; return new HttpResponse( responseCode, convertHeaders(connection.getHeaderFields()), connection.getContentLength(), new UrlConnectionInputStream(connection)); &#125; finally &#123; if (!keepConnectionOpen) &#123; connection.disconnect(); &#125; &#125;&#125; 可以看到，主要就是借助了HttpURLConnection对象来请求网络，并根据不同的条件返回不同的HttpResponse对象。 解析NetworkResponse, 得到Response： 解析过程是定义在Request类中，但是他是一个抽象类，不同的Request都有自己的实现，我们现在就以JsonRequest为例看看：然后发现他又是一个抽象类，那我们就看看JsonRequest其中一个实现类JsonObjectRequest的parseNetworkResponse()方法： 123456789101112131415@Overrideprotected Response&lt;JSONObject&gt; parseNetworkResponse(NetworkResponse response) &#123; try &#123; String jsonString = new String( response.data, HttpHeaderParser.parseCharset(response.headers, PROTOCOL_CHARSET)); return Response.success( new JSONObject(jsonString), HttpHeaderParser.parseCacheHeaders(response)); &#125; catch (UnsupportedEncodingException e) &#123; return Response.error(new ParseError(e)); &#125; catch (JSONException je) &#123; return Response.error(new ParseError(je)); &#125;&#125; 这个就不用多说了，根据返回来的response建了一个String然后把这个String放到Response里面去然后再返回去。 回调主线程回调主要是通过Delivery的postResponse()方法实现的，我们来看看这个方法,找过去又找到了一个ResponseDelivery抽象类，然后又得找他的实现类，这时大家应该记得RequestQueue()的时候初始化了一个Delivery： 1234567public RequestQueue(Cache cache, Network network, int threadPoolSize) &#123; this( cache, network, threadPoolSize, new ExecutorDelivery(new Handler(Looper.getMainLooper())));&#125; 他返回了一个ExecutorDelivery，我们来看看这个类，然后就惊喜的发现，我们终于找到我们需要的东西了： 123456789101112131415/** * Creates a new response delivery interface. * * @param handler &#123;@link Handler&#125; to post responses on */public ExecutorDelivery(final Handler handler) &#123; // Make an Executor that just wraps the handler. mResponsePoster = new Executor() &#123; @Override public void execute(Runnable command) &#123; handler.post(command); &#125; &#125;;&#125; 知道了它的初始化，我们再来看看它是如何实现回调的： Volley中回调是通过postResponse()方法的 : 12345678910public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response) &#123; postResponse(request, response, null);&#125;@Overridepublic void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) &#123; request.markDelivered(); request.addMarker("post-response"); mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));&#125; postResponse()最终会调用mResponsePoster对象的execute()方法，传入了一个ResponseDeliveryRunnable对象，它实现了Runnable接口，execute()方法会通过Handler.post(runnable)将ResponseDeliveryRunnable放入消息队列。最后我们来看看这个ResponseDeliveryRunnable的run()方法在主线程中做了什么操作： 12345678910111213141516171819202122232425262728293031@SuppressWarnings("unchecked")@Overridepublic void run() &#123; // If this request has canceled, finish it and don't deliver. if (mRequest.isCanceled()) &#123; mRequest.finish("canceled-at-delivery"); return; &#125; if (mResponse.isSuccess()) &#123; // 执行成功的回调，在具体的Request实现类中，比如StringRequest就会调用listener.onResponse(string)回调 mRequest.deliverResponse(mResponse.result); &#125; else &#123; // 执行失败的回调，在request中，直接回调了listener.onErrorResponse(error) mRequest.deliverError(mResponse.error); &#125; // intermediate默认为false，但是在CacheDispatcher的run()中，如果需要更新缓存，那么就会置为true if (mResponse.intermediate) &#123; mRequest.addMarker("intermediate-response"); &#125; else &#123; mRequest.finish("done"); &#125; // 如果传入了runnable不为空，那就就执行runnable.run()方法 // 回忆下在CacheDispatcher的run()方法中，如果request有缓存，但是需要更新缓存的时候，mDelivery是不是调用的带runnable的方法 if (mRunnable != null) &#123; mRunnable.run(); &#125;&#125; 3 请求流程图最后附上Volley的请求流程图]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>kotlin</tag>
        <tag>Volley</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统2--进程的描述和控制]]></title>
    <url>%2Fposts%2F2e847144.html</url>
    <content type="text"><![CDATA[大家可以看下我使用幕布软件画的思维导图，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员https://mubu.com/inv/477598 [TOC] 2.1 进程的描述2.1.1 进程的定义和特征2.1.1.1 进程的定义为了能够使程序并发执行，并且可以对并发执行的程序加以描述和控制，人们引入了“进程”的概念。为了使参与并发执行的每个程序都能独立地运行，操作系统必须为之配置一个专门的数据结构，称为进程数据块（PCB）。他用来纪录进程的各种属性，描述进程的动态变化过程。主要包含有进程的描述信息（进程标识符，进程名，用户标识符，进程组关系等）、进程控制信息（当前状态，优先级，代码执行入口地址，保存的磁盘地址等等）、所拥有的资源和使用情况（虚拟地址空间的状态，文件打开列表等）和CPU现场信息等内容。PCB是系统感知进程存在的唯一标志。所以一般情况下，我们把进程实体就简称为进程，创建进程，实质上是创建进程实体中的PCB；撤销进程，实质上是撤销进程的PCB。对于进程的定义，比较典型的有： 进程是程序的一次执行 进程是一个程序及其数据在处理机上顺序执行时所发生的活动 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位 2.1.1.2 进程的特征 结构性进程实体是由程序段、数据段及进程控制快三部分组成。 动态性进程的实质是进程实体的执行过程，而且进程“由创建而产生，由调度而执行，由撤销而消亡”。 并发性多个进程实体同存于内存中，且能在一段时间内同时运行。 独立性进程实体是一个能独立运行、独立获得资源和独立接收调度的基本单位。 异步性进程是按异步方式运行的。 2.1.2 进程的基本状态及转换2.1.2.1 进程的三种基本状态进程主要分为三种基本状态： 运行态指进程已经获得了CPU，他正在CPU上执行。 就绪态指进程已经准备就绪，准备好了被CPU执行的状态。如果系统中有很多处于就绪态的进程，通常把他们按一定的策略排成一个队列，这个队列称为就绪队列。 等待态指正在运行的进程由于发生某事件（如I/O请求、申请缓冲区失败等问题）暂时无法继续执行时的状态。此时引起进程调度，OS把处理机分配给就绪中的进程，让受阻的进程处于阻塞状态。 2.1.2.2 三种状态的转换 2.1.2.3 创建状态和终止状态为了满足进程控制块对数据及操作的完整性要求以及增强管理的灵活性，通常在系统中又为进程引入了两种常见的状态：创建状态和终止状态。 2.1.3 进程管理中的数据结构在最开始我已经经提到了进程控制块PCB这个东西，现在我们就进一步来了解他。 2.1.3.1 进程控制块中的作用PCB的作用主要就是使一个在多道程序环境下不能独立运行的程序称为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。 作为独立运行基本单位的标志。 当一个程序配置了PCB之后，就表示他已是一个能在多道程序环境下独立运行的、合法的基本单位，也就具有取得OS服务的权利。当系统创建一个新的进程的时候，就为他创建了一个PCB，进程结束后收回PCB。 能实现间断性运行方式。 在多道程序运行环境下，由于存在时间片或者有等待I/O请求的情况，所以进程一般都是出于走走停停的状态，当一个进程被阻塞的时候，他应该有一种能保存当前运行状态的能力也就是保护现场机制，方便在此被调度执行时恢复阻塞前的状态。所以就需要在PCB里面提供一个数据结构来保存该进程被中断时的一些信息。 提供进程管理所需要的信息。 这个就不用多说吧。 提供进程调度所需要的信息。 只有处于就绪状态的进程才能被调度执行，而在PCB中就提供了进程处于何种状态的信息。 实现与其它进程的同步与通信。 2.1.3.2 进程控制块中的信息根据上面进程控制块作用的描述，对应的进程控制块中就需要包含以下信息。 进程标识符 进程标识符用于唯一地标识一个进程。一个进程通常具有两种标识符： 外部标识符 为了方便用户（进程）对进程的访问，进程需要提供一个用于用户（进程）访问的标识符。 内部标识符 为了方便系统对进程的使用，在OS中又为进程设置了内部标识符。通常是一个进程的序号。 处理机状态 处理机状态信息也称为处理机的上下文，主要是由处理机的各种寄存器中的内容组成的。这些寄存器信息包括通用寄存器、指令寄存器、程序状态字PSW和用户栈指针。 进程调度信息 在OS进行调度的时候，必须了解进程的状态及有关进程调度的信息，这些信息包括：进程状态、进程优先级、进程调度所需其他信息（与所采用的的调度算法有关）和事件（阻塞原因）。 进程控制信息 用于进程控制所必须的信息，包括：程序和数据的地址、进程同步和通信机制、资源清单和链接指针。 2.1.3.3 进程控制块的组织方式一个系统中有很多个PCB，为了对他们进行有效的管理，应该用适当的方式将这些PCB组织起来，常用的组织方式有三种 线性方式直接将所有PCB放在一张线性表中，优点是简单，开销小，但是每次查找起来很麻烦。 链接方式把具有相同状态的PCB分别通过PCB中的链接字链接成一个队列。 索引方式根据所有进程状态的不同建立几张索引表，并把个索引表在内存的首地址纪录在内存的一些专用单元中。 2.2 进程控制2.2.1 进程的层次结构在OS中，允许一个进程创建另一个进程，通常把创建进程的进程称为父进程，被创建的进程称为子进程。然后子进程可以作为父进程继续去创建子进程，进而形成一个进程家族。 2.2.2 进程的创建每当出现了创建新进程的请求后，OS便调用进程创建原语Creat按下述步骤创建新进程： 申请空白PCB，为新进程申请获得唯一的数字标识符，并从PCB集合中索取一个空白PCB。 为新进程分配其运行所需的资源，包括各种物理和逻辑资源。 初始化进程控制块PCB。 如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。 2.2.3 进程的终止 根据被终止进程的标识符，从PCB集合中检索出进程的PCB，从中读出该进程的状态。 若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志位真，用于指示该进程被终止后应重新进行调度。 若该进程还有子孙进程，还应将其所有子孙进程也都予以终止，以防它们称为不可控的进程。 将被终止进程所拥有的的全部资源或者归还给其父进程，或者归还给系统。 将被终止进程（PCB）从所在队列（或链表）中移出，等待其他程序来搜集信息。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统1--操作系统概述]]></title>
    <url>%2Fposts%2F62248b34.html</url>
    <content type="text"><![CDATA[大家可以看下我使用幕布软件画的思维导图，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员https://mubu.com/inv/477598 现如今主流的操作系统1.1.1 PC1.1.1.1 WindowsMicrosoft Windows是微软公司推出的一系列操作系统。其问世时间为1985年，起初为运行于MS-DOS之下的桌面环境，其后续版本逐渐发展成为主要为个人计算机和服务器用户设计的操作系统，并最终获得了世界个人计算机操作系统的垄断地位。此操作系统可以在几种不同类型的平台上运行，如个人计算机、移动设备、服务器和嵌入式系统等等，其中在个人计算机的领域应用内最为普遍。Windows操作系统当前最新的稳定版是于2015年7月29日发布的 Windows 10。Windows Server当前最新的稳定版是2018年10月2日发布的Windows Server 2019。Windows Phone当前最新的稳定版是Windows10 Mobile，但是已停止开发新版本，仅对现有版本进行安全补丁和维护，直到2019年12月。 1.1.1.2 macOSmacOS（2011年及之前称Mac OS X，2012年至2015年称OS X）是苹果公司推出的基于图形用户界面操作系统，为麦金塔（Macintosh）的主操作系统。StatCounter在2018年8月的数据表示，在桌面操作系统中，macOS的使用份额为12.65%，次于Windows的82.51%位居第二。macOS当前最新的稳定版是2018年9月25日发布的macOS 10.14 Mojave，2019年6月4日推出macOS 10.15 Catalina的第一个测试版本。 1.1.1.3 LinuxLinux是一种自由和开放源码的类UNIX 操作系统。该操作系统的内核由林纳斯·托瓦兹在1991年10月5日首次发布，在加上用户空间的应用程序之后，成为 Linux 操作系统。Linux也是自由软件和开放源代码软件发展中最著名的例子。只要遵循 GNU 通用公共许可证（GPL），任何个人和机构都可以自由地使用 Linux 的所有底层源代码，也可以自由地修改和再发布。大多数 Linux 系统还包括像提供 GUI 的 X Window 之类的程序。除了一部分专家之外，大多数人都是直接使用 Linux 发行版，而不是自己选择每一样组件或自行设置。 1.1.1.4 UnixUNIX操作系统（尤尼斯），是一个强大的多用户、多任务操作系统，支持多种处理器架构，按照操作系统的分类，属于分时操作系统，最早由KenThompson、Dennis Ritchie和Douglas McIlroy于1969年在AT&amp;T的贝尔实验室开发。它的商标权由国际开放标准组织所拥有，只有符合单一UNIX规范的UNIX系统才能使用UNIX这个名称，否则只能称为类UNIX（UNIX-like）。 1.1.2 移动端1.1.2.1 AndroidAndroid，常见的非官方中文名称为安卓，是一个基于Linux内核的开放源代码移动操作系统，由Google成立的Open Handset Alliance持续领导与开发，主要设计用于触摸屏移动设备如智能手机和平板电脑与其他便携式设备。Android Inc.于2003年10月由安迪·鲁宾、利奇·米纳尔、尼克·席尔斯、克里斯·怀特在加州帕罗奥图创建。Android最初由安迪·鲁宾等人开发制作，最初开发这个系统的早期方向是创建一个数字相机的先进操作系统，但是后来发现市场需求不够大，加上智能手机市场快速成长，于是Android成为一款面向智能手机的操作系统。于2005年7月11日Android Inc.被美国科技企业Google收购。2017年3月，Android全球网络流量和设备超越Microsoft Windows，正式成为全球第一大操作系统。 1.1.2.2 iOSiOS（原名为iPhone OS）是苹果公司为其移动设备所开发的专有移动操作系统，为其公司的许多移动设备提供操作界面，支持设备包括iPhone、iPad和iPod touch。iPhone OS自iOS 4起便改名为iOS，它是继Android后全球第二大最受欢迎的移动操作系统，市占率已上升至约24.5% ，但仍远低于Google开发的Android系统的72.2%。 1.2 操作系统的简介与作用1.2.1 操作系统的简介操作系统是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。主要作用是对管理好计算机硬件设备，提高他们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单接口，便于用户使用。 1.2.2 操作系统的目的 方便性 如果一个计算机没有OS，那么他会非常难用。用户不管进行啥操作都得通过机器语言编写程序然后运行，而如果有OS的话，用户就可以使用各种各样的语言编写程序，然后通过编译将高级语言编译成机器代码，方便了用户。 有效性 有效性分两层含义——提高系统资源的利用率和提高系统的吞吐量。早期没有OS的计算机中，处理机和I/O设备等经常处于空闲状态，各种资源不能得到合理利用，所以提高系统资源利用率是推动OS发展的主要动力。另一方面，OS可以通过合理组织计算机的工作流程，加速程序的运行，缩短程序的运行周期，从而提高系统的吞吐量。 可扩充性 为了适应现在越来越多的计算机硬件以及体系结构，OS必修有良好的可扩充性。 开放性 OS需要遵循世界标准规范，凡遵循国际标准所开发的硬件和软件都能彼此兼容，方便地实现互联。 1.2.3 操作系统的作用 OS作为用户与计算机硬件系统之间的接口 OS处于用户和硬件之间，方便用户通过OS使用硬件。或者说，用户在OS的帮助下能够方便、快捷、可靠地操纵计算机硬件和运行自己的程序。 OS作为计算机系统资源的管理者 计算机系统资源主要可分为处理机、存储器、I/O设备以及文件。OS主要功能也就是对这四类资源进行有效的管理。处理机管理是用于分配和控制处理机；存储器管理主要负责内存的分配与回收；I/O设备管理是负责I/O设备的分配与操纵；文件管理是用于实现对文件的存取、共享和保护。 OS实现了对计算机资源的抽象 在裸机中，用户如果想要对计算器进行操作，必须对物理接口的实现细节有充分的了解。但在操作系统中，用户并不需要关心具体的物理，而由操作系统来实现具体的操作细节，并向上讲操作设备抽象为一组数据结构以及一组操作命令。此时在用户眼里，看到的是一台比裸机功能更强，使用更方便的机器。 1.2.4 推动操作系统发展的主要动力 不断提高计算机资源利用率 方便用户 器件的不断更新换代 计算机体系结构的不断发展 不断提出新的应用需求 1.3 操作系统的发展1.3.1 单道批处理系统在说单道批处理之前现要引入一个概念——作业。作业包括用户程序、数据、作业说明书。这样每一个处理对象都是作业。 1. 处理过程每个单道批处理系统都有一个系统操作员。用户先将作业交给系统操作员，然后操作系统操作员就将一个个作业组成一批作业，输入到计算机中，在系统中形成一个自动转接的作业流，然后启动操作系统对作业自动、依次的处理，处理完成后再将处理结果返回给系统操作员，操作员在返回给用户。这样就形成了一个单道批处理过程。 2. 缺点系统资源得不到充分利用。这是因为在内存中仅有一道程序，每逢程序在运行中发出I/O请求后，CPU便处于等待状态，必须在I/O完成后才继续运行。 1.3.2 多道批处理系统1. 处理过程在该系统中，用户所提交的作业先放在外存中，并排成一个队列，称为“后备队列“。然后由作业调度程序按一定的算法，从后备队列中选择若干作业调入内存。由于同时在内存中装有若干道程序，这样便可以在运行程序A时，利用其I/O操作暂停执行时的CPU空档期，再调度另一道程序B运行。 2. 优缺点 优点 资源利用率高 系统吞吐量大 缺点 平均周转时间长 无交互能力 1.3.3 分时系统1. 运行方式 作业直接进入内存。因为作业在磁盘上不可运行，所以作业应直接进入内存 采用轮转运行方式。如果一个作业独占CPU连续运行，那么其他作业没法运行。为了避免这种情况，引入了时间片概念。一个时间片是一个很短的时间，系统规定了每个作业每次只能运行一个时间片，然后就暂停该作业的运行，并立即调度下一个作业运行。如果在不长的时间内能使所有的作业都执行一个时间片的时间，便可以使每个用户都能及时地与自己的作业进行交互，从而使用户的请求的到及时响应。 2. 特征 多路性 独立性 及时性 交互性 1.3.4 实时系统实时系统是指系统能及时响应外部事件的请求，在规定时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。实时系统主要应用于： 工业（武器）控制系统 信息查询系统 多媒体系统 嵌入式系统 1.4 操作系统的基本特征1.4.1 并发正是系统中有这一特征，才使得OS能有效地提高系统中的资源利用率，增加系统的吞吐量。 并发与并行并行是指两个或多个事件在同一时刻发生，微观上是同一时刻多个线程在CPU上运行。并发是指宏观上两个或多个事件在同一时间发生，微观上缺是某一时刻CPU上只有一个进程。 1.4.2 共享资源共享，即操作系统中的资源可供多个并发执行的进程共同使用，由于资源属性不同，多个进程对资源的共享方式也不同。可分为：互斥共享方式和同时访问方式。 1. 互斥共享方式一段时间内只允许一个进程访问该资源，如磁带机,打印机等。虽然可以供多个进程使用，但是为了打印或记录结果不造成混淆，应规定一段时间内只允许一个进程访问该资源。 2. 同时访问方式某些资源，一段时间内是可以允许多个进程“同时”同时对他们进行访问，这个同时是宏观上的，在微观上可能是分时共享。 1.4.3 虚拟在OS中，把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为”虚拟“。 1.4.4 异步在多道环境下，允许多个程序并发执行。但由于资源有限，进程的执行不是一贯到底。而是走走停停，以不可预知的速度向前推进，这就是进程的异步。 1.5 操作系统的主要功能操作系统的主要功能应分为处理机管理、存储器管理、设备管理和文件管理。此外，还应向用户提供方便的用户接口。 1.5.1 处理机管理功能1. 进程控制在多道程序环境中，为了使作业能并发执行，必须为每道作业创建一个或几个进程，并为之分配必要的资源。当进程运行结束时，应立即撤销该进程，以便能及时回收该进程所占用的各种资源，供其它进程使用。 2. 进程同步为了使多个进程能有条不紊的运行，系统中必须设置相应的进程同步机制。该机制的主要任务是为多个进程的运行进行协调。 3. 进程通信如果一组相互合作的进程去完成一个共同的任务时，在他们之间往往需要交换信息。 4. 调度在传统OS中，调度包括作业调度和进程调度。 作业调度 作业调度的基本任务就是从后备队列中按照一定的算法选择出若干个作业，为他们分配所需资源，在这些作业调入内存后，分别为他们创建进程，是他们都称为可能获得处理机的就绪进程，并将他们插入就绪队列中。 进程调度 进程调度的任务是从进程的就绪队列中按照一定的算法选出一个进程，将处理机分配给他，并为他设置运行线程，使其投入执行。 1.5.2 存储器管理功能存储器管理视为多道程序的运行提供良好的环境，提高存储器利用率，并能从逻辑上扩充内存。为此，存储器管理应具有内存分配和回收、内存保护、地址映射和内存扩充等功能。 1. 内存分配内存分配主要任务是： 为每道程序分配内存空间 提高存储器的利用率，尽量减少不可用的内存空间 允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需要。 OS在实现内存分配时，可采取静态和动态两种方式： 静态分配内存。每个作业的内存空间在作业装入时确定，确定后不再改变。 动态分配内存。每个作业所要求的的基本内存空间虽然也是在装入时确定的，但允许作业在运行过程中继续申请新的附加内存空间，以适应程序和数据的动态增长。 2. 内存保护确保每道用户程序都在自己的内存空间内运行，彼此互不干扰。决不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其他用户程序中去执行。 3. 地址映射每道程序经编译连接后所形成的的可装入程序其地址都是从0开始的，但是不可能将他们从“0”地址开始装入内存，所以物理地址和逻辑地址并不一致，这时候就需要地址映射来让程序能正常运行。 4. 内存扩充借助虚拟存储技术来实现内存扩充，主要解决： 内存和I/O之间速度不匹配的问题 如果内存空间不足的问题 1.5.3 设备管理功能主要任务： 完成用户进程提出的I/O请求，为用户进程分配所需的I/O设备，并完成指定的I/O操作 提高CPU与I/O设备的利用率，提高I/O速度，方便用户使用I/O 为了实现以上功能，应具有缓冲管理、设备分配和设备处理以及虚拟设备等功能。 1. 缓冲管理为了有效的缓和CPU与I/O设备间速度不匹配的问题，提高CPU利用率，于是引入了缓冲管理。 2. 设备分配设备分配的基本任务是根据用户进程的I/O请求、系统现有资源情况以及按照某种设备分配策略，为之分配其所需的设备。 3. 设备处理实现CPU和设备控制器之间的通信，即由CPU向设备控制器发出I/O命令，要求他完成指定的I/O操作；反之，由CPU控制从接收器发来的中断请求，并给予迅速的响应和相应的处理。 1.5.4 文件管理功能主要是对用户文件和系统文件进行管理以方便用户使用，并保证文件的安全性。为此，文件管理应具有对文件存储空间管理、目录管理、文件的读/写管理以及文件的共享与保护等功能。 1. 文件存储空间的管理为每个文件分配必要的外存空间，提高我村利用率，进而提高文件系统的存、取速度。 2. 目录管理为每个文件建立一个目录项，目录项包括文件名、文件属性、文件在磁盘上的物理位置等，并对众多的目录项加以有效的组织，以实现方便的按名字存取。 3. 文件的读/写管理和保护根据用户的请求，从外存中读取数据或将数据写入外存。并且保护文件防止其被非法盗取和破坏。 1.5.5 操作系统与用户间的接口接口主要分为两大类：用户接口和程序接口。用户接口是供用户调用，方便用户直接或间接控制自己的作业。程序接口是为用户程序在执行中访问系统资源而设定的，是用户取得操作系统服务的唯一途径。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android多线程2--Java中的线程池]]></title>
    <url>%2Fposts%2Fb39fd0ab.html</url>
    <content type="text"><![CDATA[简介我们在写项目经常要用到多线程。但是线程的创建和摧毁都是较消耗资源和性能的，如果你每需要一个任务就新建一个线程，那可能会在线程的创建和摧毁上浪费掉很多资源。那如果我们让线程执行任务后不摧毁，接着执行下一个任务，这样是不是就能避免这种情况了。Java1.5中提供了Executor框架用于把任务的提交和执行解耦，任务的执行就交给Runnable或者Callable，而Executor框架用于处理任务。Executor中最核心的成员就是ThreadPoolExecutor，他就是线程池核心实现类。 ThreadPoolExecutor我们现在先来看下这个方法。构造器： 123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,markdownlint long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 我们来看下这些参数： corePoolSize：核心线程数。线程池刚创建的时候，线程数量为0，只有任务提交的时候才会创建线程。如果当前线程数量小于corePoolSize，则创建新线程；如果等于或者大于，则不再创建。 maximumPoolSize：线程池允许创建的最大线程数。当workQueue满了而且线程数小于maximumPoolSize时，线程池仍会创建新的线程。但是如果超过了maximumPoolSize时，则会抛出异常。 keepAliveTime：非核心线程闲置的超过时间。当线程池中线程数量大于workQueue，如果一个线程的空闲时间大于keepAliveTime，则该线程会被回收。如果任务很多，并且每个任务 的执行事件很短，则可以调大keepAliveTime来提高线程的利用率。另外，如果设置 allowCoreThreadTimeOut属性为true时，keepAliveTime也会应用到核心线程上。 timeUnit：keepAliveTime参数的时间单位。可选的单位有天(DAYS)、小时(HOURS)、分钟(MINUTES)、秒(SECONDS)、毫秒(MILLISECONDS)等。 workQueue：任务队列。如果当前线程数大于corePoolSize，则将任务添加到此任务队列中。该任务 队列是BlockingQueue类型的，也就是阻塞队列。 threadFactory：线程工厂。可以用线程工厂给每个创建出来的线程设置名字。一般情况下无须设置该参数。 RejectedExecutionHandler：饱和策略。这是当任务队列和线程池都满了时所采取的应对策略，默认是AbordPolicy，表示无法处理新任务，并抛出RejectedExecutionException异常。此外还有3种策略，它们分别如下: CallerRunsPolicy：用调用者所在的线程来处理任务。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。 DiscardPolicy：不能执行的任务，并将该任务删除。 DiscardOldestPolicy：丢弃队列最近的任务，并执行当前的任务。 线程池的处理流程线程池的任务处理主要分为3个步骤 提交任务后，线程池先判断线程数是否达到了核心线程数corePoolSize。如果未达到核心线程数，则创建核心线程处理任务；否则，就执行下一步操作。 接着线程池判断任务队列是否满了。如果没满，则将任务添加到任务队列中；否则，就执行下一步操作。 接着因为任务队列满了，线程池就判断线程数是否达到了最大线程数。如果未达到，则创建非核心线程处理任务；否则，就执行饱和策略，默认会抛出RejectedExecutionException异常。 如果线程池中的线程数未达到核心线程数，则创建核心线程处理任务。 如果线程数大于或者等于核心线程数，则将任务加入任务队列，线程池中的空闲线程会不断地从 任务队列中取出任务进行处理。 如果任务队列满了，并且线程数没有达到最大线程数，则创建非核心线程去处理任务。 如果线程数超过了最大线程数，则执行饱和策略。 线程池的种类CachedThreadPool：可缓存线程池 线程数无限制 有空闲线程则复用空闲线程，若无空闲线程则新建线程 一定程序减少频繁创建/销毁线程，减少系统开销 创建源码： 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; CachedThreadPool的corePoolSize为0，maximumPoolSize设置为Integer.MAX_VALUE，这意味着CachedThreadPool没有核心线程，非核心线程是无界的。keepAliveTime设置为60L，则空闲线程等待新任务 的最长时间为60s。在此用了阻塞队列SynchronousQueue，它是一个不存储元素的阻塞队列，每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都等待另一个线程的插入操作。 FixedThreadPool：定长线程池 可控制线程最大并发数（同时执行的线程数） 超出的线程会在队列中等待 创建源码： 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; FixedThreadPool的corePoolSize和maximumPoolSize都设置为创建FixedThreadPool指定的参数nThreads，也就意味着FixedThreadPool只有核心线程，并且数量是固定的，没有非核心线程。keepAliveTime设置为0L意味着多余的线程会被立即终止。因为不会产生多余的线程，所以keepAliveTime是无效的参数。另外，任务队列采用了无界的阻塞队列LinkedBlockingQueue。 ScheduledThreadPool：定长线程池支持定时及周期性任务执行。 创建源码： 1234public static ScheduledExecutorService newScheduledThreadPool( int corePoolSize, ThreadFactory threadFactory) &#123; return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);&#125; 我们可以看到在创建源码中他跳转到了ScheduledThreadPoolExecutor的构造方法，我们继续看进去： 123456public ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue(), threadFactory);&#125; 从上面的代码可以看出，ScheduledThreadPoolExecutor的构造方法最终调用的是ThreadPoolExecutor的构造方法。corePoolSize是传进来的固定数值，maximumPoolSize的值是Integer.MAX_VALUE。因为采用的DelayedWorkQueue是无界的，所以maximumPoolSize这个参数是无效的。 SingleThreadExecutor：单线程化的线程池 有且仅有一个工作线程执行任务 所有任务按照指定顺序执行，即遵循队列的入队出队规则 创建源码： 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; corePoolSize和maximumPoolSize都为1，意味着SingleThreadExecutor只有一个核心线程，其他的参数都和FixedThreadPool一样，这里就不赘述了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next配置备份]]></title>
    <url>%2Fposts%2F5b6e53a4.html</url>
    <content type="text"><![CDATA[Hexo配置备份 评论系统 来必力 - https://www.livere.com/ valine(在用) - https://valine.js.org/ 阅读量显示 leancloud - https://leancloud.cn/ valine(在用) - https://valine.js.org/]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android多线程1--Java中的阻塞队列]]></title>
    <url>%2Fposts%2F63ab42b7.html</url>
    <content type="text"><![CDATA[阻塞队列前言在谈论阻塞队列之前我们先看下操作系统多线程部分一个经典的例子——生产者和消费者问题： 现在有两个进程，一个是生产者一个是消费者，还有一个线程缓冲区。生产者主要作用就是向缓冲区中添加数据，消费者就是从缓冲区中取出数据。这个问题的核心就是如何确保生产者不会在缓冲区满了的时候还往其中添加元素，消费者不会在缓冲区空了的时候还要求取出数据。 关于这个问题的解决办法我们以后再说，我们现在主要讨论线程缓冲区——阻塞队列。 阻塞队列简介阻塞队列就是队列，只是在一般的队列上添加了两个条件： 当队列满了的时候不允许再添加数据 当队列空了的时候不允许从中取数据 在Java中，阻塞队列是通过BlockingQueue来实现的，BlockingQueue是Java.util.concurrent包下一个重要的数据结构。 BlockingQueue的操作方法 方法 抛异常 返回特定值 阻塞 超时 插入 add(E e) offer(E e) put(E e) offer(E e, long timeout, TimeUnit unit) 移除 remove() poll() take() poll(time, unit) 检查 element() peek() 不可用 不可用 解释： 抛异常：如果操作无法执行，则抛出一个异常 特定值：如果操作无法执行，则返回一个特定的值 阻塞： 如果操作无法执行，则方法调用被阻塞，直到可以执行 超时：如果操作无法执行，则方法调用被阻塞，直到可以执行或者超过限定的时间。返回一个特定值以告知该操作是否成功(典型的是true / false)。 Java中的各种阻塞队列Java基于BlockingQueue给开发者提供了7个阻塞队列： ArrayBlockingQueue：基于数组的有界阻塞队列。有界就意味着他有一个最大限度，所存储的线程的数量不能超过这个限定值。你也可以在对其初始化的时候给定这个限定值。但是由于它是基于数组所以他和数组一样，在初始化的时候限定了这个大小以后就不能改变。 LinkedBlockingQueue：基于链表的阻塞队列。它内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用Integer.MAX_VALUE作为上限。LinkedBlockingQueue内部以FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。由于默认是无上限的，所以在使用他的时候，如果生产者的速度大于消费者的速度，系统内存可能会被耗尽。所以使用他一定要设置初值。 PriorityBlockingQueue：支持优先级的无界队列。默认情况按照自然顺序生序排列，你可以重写compateTo()方法来制定元素按规定排序。 DelayQueue：支持延时获取元素的无界阻塞队列。队列中的元素必须实现Delayed接口。 SynchromousQueue：是一个特殊的队列。他不能存储任何元素，他的每一次插入操作必须等待另一个线程相应的删除操作，反之亦然。 LinkedTransferQueue：基于链表的无界阻塞TransferQueue队列。相对于其他队列，他多了transfer(E e)、tryTransfer(E e) 和 tryTransfer(E e, long timeout, TimeUnit unit)方法。 LinkedBlockingDeque：是一个链表结构的双向阻塞队列。可在两端入队出对。所以当多线程入队时，减少了一半的竞争。 阻塞队列实现原理下面我们以ArrayBlockingQueue源码为例，来看下阻塞队列实现原理： 定义首先就是一堆变量的定义： 123456789101112131415161718192021222324252627/** The queued items */final Object[] items;/** items index for next take, poll, peek or remove */int takeIndex;/** items index for next put, offer, or add */int putIndex;/** Number of elements in the queue */int count;/* * Concurrency control uses the classic two-condition algorithm * found in any textbook. *//** Main lock guarding all access */final ReentrantLock lock;/** Condition for waiting takes */privatefinal Condition notEmpty;/** Condition for waiting puts */privatefinal Condition notFull; items是存储队列元素的数组，takeIndex和putIndex分别是取数据和存数据的索引，count是队列中元素个数，lock为看一个可重入锁，notEmpty和notFull均为等待条件，由lock创建。 构造器接下来看下它的构造器 12345678public ArrayBlockingQueue(int capacity) &#123;&#125;public ArrayBlockingQueue(int capacity, boolean fair) &#123; &#125;public ArrayBlockingQueue(int capacity, boolean fair, Collection&lt;? extends E&gt; c) &#123;&#125; 构造器有三个重载的版本，第一个构造器只有一个参数用来指定容量，第二个构造器多了一个参数来指定访问策略，第三个构造器又多了一个参数可以指定用另外一个集合进行初始化。 数据的添加接下来我们看看BlockingQueue的三个插入的方法：put()、add()和offer()： put() 方法：队列满，会阻塞调用存储元素的线程 1234567891011121314151617public void put(E e) throws InterruptedException &#123; // 先检查e是不是空，如果空则抛异常 Objects.requireNonNull(e); // 获取一个重入锁lock final ReentrantLock lock = this.lock; // 加锁，保证调用put方法的时候只有1个线程 lock.lockInterruptibly(); try &#123; // 如果线程中的元素数量是否等于当前数组的长度，如果相等则调用await方法等待，如果不相等则enqueue方法插入元素 while (count == items.length) notFull.await(); enqueue(e); &#125; finally &#123; // 解锁 lock.unlock(); &#125;&#125; add()方法：实际上调用了offer()方法 123456public boolean add(E e) &#123; if (offer(e)) return true; else throw new IllegalStateException("Queue full");&#125; offer()方法：成功返回true，失败返回false 1234567891011121314151617181920public boolean offer(E e) &#123; // 检查e是否为空 Objects.requireNonNull(e); // 获取重入锁lock final ReentrantLock lock = this.lock; // 加锁 lock.lock(); try &#123; // 如果如果线程中的元素数量是否等于当前数组的长度，如果相等则调返回false，如果不相等则enqueue方法插入元素并返回true if (count == items.length) return false; else &#123; enqueue(e); return true; &#125; &#125; finally &#123; // 解锁 lock.unlock(); &#125;&#125; 以上三个方法都调用了enqueue()方法。下面我们就来看看这个方法： 123456789101112131415/** * Inserts element at current put position, advances, and signals. * Call only when holding lock. */private void enqueue(E e) &#123; // assert lock.isHeldByCurrentThread(); // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; final Object[] items = this.items; items[putIndex] = e; if (++putIndex == items.length) putIndex = 0; count++; notEmpty.signal();&#125; 先获取元素数组items，然后添加putIndex上，如果++putIndex等于items的长度，则证明当前这个items所有元素都添加进了，就让putIndex等于0.然后调用notEmpty.signal()方法唤醒正在获取元素的线程，让他们从队列中取数据。 数据的取出ArrayBlockingQueue的取数据方法总共也有三个方法：poll()、take()和remove() poll()方法：获取元素，存在返回元素e,不存在返回null 12345678910111213public E poll() &#123; // 获取重入锁lock final ReentrantLock lock = this.lock; // 加锁 lock.lock(); try &#123; // 如果元素数量等于0就返回null，否则调用dequeue()方法 return (count == 0) ? null : dequeue(); &#125; finally &#123; // 解锁 lock.unlock(); &#125;&#125; take()方法：取元素。如果队列为空,则会阻塞调用获取元素的线程 123456789101112131415public E take() throws InterruptedException &#123; // 获取重入锁lock final ReentrantLock lock = this.lock; // 加锁 lock.lockInterruptibly(); try &#123; // 如果线程中的元素数量是否等于0，如果相等则调用await方法等待，如果不相等则dequeue方法删除元素 while (count == 0) notEmpty.await(); return dequeue(); &#125; finally &#123; // 解锁 lock.unlock(); &#125;&#125; remove()方法：取元素，它是取特定的那个元素 1234567891011121314151617181920212223242526public boolean remove(Object o) &#123; // 判断o是否为空 if (o == null) return false; // 获取重入锁lock final ReentrantLock lock = this.lock; // 加锁 lock.lock(); try &#123; // 如果元素数量大于0，则获取items，然后便利元素，判断o是其中的哪个，然后删除那个 if (count &gt; 0) &#123; final Object[] items = this.items; for (int i = takeIndex, end = putIndex, to = (i &lt; end) ? end : items.length; ; i = 0, to = end) &#123; for (; i &lt; to; i++) if (o.equals(items[i])) &#123; removeAt(i); return true; &#125; if (to == end) break; &#125; &#125; return false; &#125; finally &#123; // 解锁 lock.unlock(); &#125;&#125; poll()和take()两个方法都调用了dequeue()方法，我们就看下dequeue()是如何来实现的： 12345678910111213141516171819/** * Extracts element at current take position, advances, and signals. * Call only when holding lock. */private E dequeue() &#123; // assert lock.isHeldByCurrentThread(); // assert lock.getHoldCount() == 1; // assert items[takeIndex] != null; final Object[] items = this.items; @SuppressWarnings("unchecked") E e = (E) items[takeIndex]; items[takeIndex] = null; if (++takeIndex == items.length) takeIndex = 0; count--; if (itrs != null) itrs.elementDequeued(); notFull.signal(); return e;&#125; 和上面的enqueue()方法类似，再次就不再赘述。 阻塞队列的应用前面我说过，阻塞队列主要用在生产者和消费者模式中，那下面我们就来写一个简单的小demo 这段代码来自刘望舒所著《Android进阶之光》 如果不用阻塞队列： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.PriorityQueue;public class Test &#123; private int queueSize = 10; private PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(queueSize); public static void main(String[] args) &#123; Test test = new Test(); Producer producer = test.new Producer(); Consumer consumer = test.new Consumer(); producer.start(); consumer.start(); &#125; class Consumer extends Thread &#123; @Override public void run() &#123; while (true) &#123; synchronized (queue) &#123; while (queue.size() == 0) &#123; try &#123; System.out.println("队列空，等待数据"); queue.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); queue.notify(); &#125; &#125; // 每次移走队首元素 queue.poll(); queue.notify(); &#125; &#125; &#125; &#125; private class Producer extends Thread &#123; @Override public void run() &#123; while (true) &#123; synchronized (queue) &#123; try &#123; System.out.println("队列满，等待有空余空间"); queue.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); queue.notify(); &#125; &#125; // 每次插入一个元素 queue.offer(1); queue.notify(); &#125; &#125; &#125;&#125; 使用阻塞队列ArrayBlockingQueue： 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.concurrent.ArrayBlockingQueue;public class BlockingQueueTest &#123; private int queueSize = 10; private ArrayBlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;&gt;(queueSize); public static void main(String[] args) &#123; BlockingQueueTest test = new BlockingQueueTest(); BlockingQueueTest.Producer producer = test.new Producer(); BlockingQueueTest.Consumer consumer = test.new Consumer(); producer.start(); consumer.start(); &#125; class Consumer extends Thread &#123; @Override public void run() &#123; while (true) &#123; try &#123; queue.take(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; private class Producer extends Thread &#123; @Override public void run() &#123; while (true) &#123; try &#123; queue.put(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin入门1:Kotlin和Java区别基础篇]]></title>
    <url>%2Fposts%2F343b01ae.html</url>
    <content type="text"><![CDATA[Koltin入门Kotlin简介 科特林岛(Котлин)是一座俄罗斯的岛屿,位于圣彼得堡以西约30公里处,形状狭长,东西长度约14公里,南北宽度约2公里,面积有16平方公里,扼守俄国进入芬兰湾的水道。科特林岛上建有喀琅施塔得市,为圣彼得堡下辖的城市。 而我们虽说的kotlin，就是一门根据它命名的一种现代程序设计语言。Kotlin 是一个用于现代多平台应用的静态编程语言，由 JetBrains 开发。Kotlin可以编译成Java字节码，也可以编译JavaScript，方便在没有JVM的设备上运行。Kotlin已正式成为Android官方支持开发语言。 变量kotlin和Java的最基本的区别就是kotlin中万物皆对象，Java中还存在着int、float等基本类型，但是在kotlin中，它把这些都定义成了对象，类似于Java中的封装类 变量的声明上面说了，kotlin万物皆对象，所以所有的变量也都是对象。在kotlin定义对象和Java有点小区别。kotlin定义对象的格式为 声明类型 变量名： 变量类型 其中： 声明类型分为val和var。val是不可变类型，类似于const，定义时必须赋值，赋值后不能被修改。var是可变类型。 变量名就是你定义的这个变量的名称。 变量类型就是你这个变量对应的类的名字。 类型推断省去变量类型kotlin里面类似c++的auto类型，对于基本类型，你可以不写变量类型，kotlin会自动帮你判断。 1234567891011var a = 5println(a is Int)var b = “123println(b is String)var c = 1.3println(c is Float)var d = trueprintln(d is Boolean) is关键字is顾名思义，就是判断这个变量是不是这个类型的实例。例子见上。 数字类型 类型 宽度(bit) Byte 8 Short 16 Int 32 Long 64 Float 32 Double 64 这些类型都继承自Number和Comparable类。 字面常量值 十进制：123 十六进制：0x0f 二进制：0b0010 Long类型：123L double类型：123.4 Float类型：123.4f或者123.4F 我们也可以使用下划线_来方便我们阅读 121_000_000 // 10000000xFF_EC // 0xFFEC 显示转换kotlin中不可隐式转换比如Java 中 12int a = 2;long b = a; 但是在kotlin中 123var a : Int? = 2var b : Long? = a; // errorvar b : Long? = a.toLong() Char类型kotlin中的Char表示字符。但是和Java不同，他不能直接当ASCII码值。 12345fun check(c : Char) &#123; if (c == 1) &#123; // error &#125;&#125; Boolean类型kotlin中的布尔类型用Boolean来表示，他有两个值true和false。用法和Java一样。 String类型和Java一样，kotlin中的字符串也是String。但是kotlin中String是不可变的。所以kotlin中String必须是val类型。同时，String是final不可继承的。 Array类型kotlin中数组必须使用Array表示。基本写法 val array: Array&lt;类型&gt; = arrayOf(..) 例如 12345678910111213141516171819202122232425262728293031/**整型Int的数组*/val arrayOfInt: IntArray = intArrayOf(1,3,5,7,9)/**字符Char类型的数组*/val arrayOfChar: CharArray = charArrayOf('H','e','l','l','o','W','o','r','l','d')/**字符串String数组*/val arrayOfString: Array&lt;String&gt; = arrayOf("Hello","World")fun main(args: Array&lt;String&gt;) &#123; //查看有多少个元素 println(arrayOfInt.size) //遍历数组 for (char in arrayOfChar)&#123; println(char) &#125; //根据所引获取数据,数组是从0开始的，现在获取第二个东京大学 println(arrayOfUniversity[1]) //重新给数组赋值，早稻田大学 arrayOfUniversity[1] = University("早稻田大学") println(arrayOfUniversity[1]) //将char连接成一个字符串,默认是自动由逗号","分割的，输出H, e, l, l, o, W, o, r, l, d println(arrayOfChar.joinToString()) //如果想要连成HelloWorld println(arrayOfChar.joinToString ("")) //数组的切片,输出3，5,结尾需要arrayOfInt-1，不然会报索引越界异常 println(arrayOfInt.slice(1..2)) println(arrayOfInt.size)&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin Anko入门]]></title>
    <url>%2Fposts%2F62bb1dd7.html</url>
    <content type="text"><![CDATA[Kotlin Anko入门简介Anko的官网就是他的GitHub地址 https://github.com/Kotlin/anko 官方对Anko的解释是 Anko是一个 Kotlin 库，它使Android应用程序开发更快更容易。它使您的代码清晰易读，让您忘记Android SDK for Java的粗糙边缘。 为什么这样说呢？比方说如果你写Android，你在xml中定义了一个Button，他的ID是button_login。 如果是Java： 12setContentView(R.layout.activity_words_detail);Button button = findViewById(R.Id.button_login); 而如果你使用kotlin的话，你可以就按如下代码写 123import kotlinx.android.synthetic.main.activity_kotlin_main.*...button_login.setText("Kotlin Android Extensions 我不太喜欢"); 这样确实比Java方便多了，不需要对每一个组件都定义再findViewById，可以就直接输入组件的id然后就能使用了。但是我们还是觉得不够啊，为什么我们不能就直接在代码中写入各个组件呢，于是，Anko来了。 导入AnkoAnko由几部分组成： Anko Commons：一个轻量级的库，包含用于Layouts，Intent，Log等的帮助程序; Anko Layouts：一种快速且类型安全的方式来编写动态Android布局; Anko SQLite：Android SQLite的查询DSL和解析器集合; Anko Coroutines：基于kotlinx.coroutines库的实用程序。 你可以在app的build.gradle中添加 12345678dependencies &#123; // Anko Layouts implementation "org.jetbrains.anko:anko-sdk25:$anko_version" // sdk15, sdk19, sdk21, sdk23 are also available implementation "org.jetbrains.anko:anko-appcompat-v7:$anko_version" // Coroutine listeners for Anko Layouts implementation "org.jetbrains.anko:anko-sdk25-coroutines:$anko_version" implementation "org.jetbrains.anko:anko-appcompat-v7-coroutines:$anko_version"&#125; 这个依赖可以直接导入所有的可用特性（包括Commons, Layouts, SQLite)。 使用Anko layout创建简单布局使用Anko创建布局很简单： 12345678910111213141516171819class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) verticalLayout &#123; padding = dip(30) editText &#123; hint = "Name" textSize = 24f &#125; editText &#123; hint = "Password" textSize = 24f &#125; button("登录") &#123; textSize = 26f &#125; &#125; &#125;&#125; 你只需要在Activity中写入DSL代码就能使用它。 AnkoComponent尽管我们现在可以直接在Activity中写入DSL代码，但是我们还是觉得把代码和布局文件放在一起不太好，希望把Activity和DSl代码放到两个不同的类里面，所以AnkoComponent就出来了。代码如下 12345678910111213141516171819202122232425class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) MainActivityUI().setContentView(this) &#125;&#125;class MainActivityUI : AnkoComponent&lt;MainActivity&gt; &#123; override fun createView(ui: AnkoContext&lt;MainActivity&gt;) = with(ui) &#123; verticalLayout &#123; padding = dip(30) editText &#123; hint = "Name" textSize = 24f &#125; editText &#123; hint = "Password" textSize = 24f &#125; button("登录") &#123; textSize = 26f &#125; &#125; &#125;&#125; Theme在Anko如果你想设置Theme需要使用themeable 1234verticalLayout &#123; padding = dip(30) themedButton("登陆", theme = R.style.Base_TextAppearance_AppCompat_Button)&#125; LayoutParams在Anko中也可以使用LayoutParams。 比方说我现在要显示一个button，下面显示一个图片。 如果使用XML: 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" android:gravity=center android:textSize="20sp" /&gt; &lt;ImageView android:layout_width="match_parent" android:layout_height="match_parent" android:background="@color/colorAccent" /&gt;&lt;/LinearLayout&gt; 但是使用Anko: 12345678910verticalLayout &#123; textView ("Hello World!") &#123; textSize = sp(12).toFloat() &#125;.lparams(height = wrapContent, width = wrapContent) &#123; horizontalGravity = Gravity.CENTER_HORIZONTAL &#125; imageView &#123; backgroundColor = Color.BLUE &#125;.lparams(height = matchParent, width = matchParent)&#125; 注意： horizontalMargin 同时设置 left 和 right margins verticalMargin 同时设置 top 和 bottom margin 同时设置4个方向的 margins Listeners在Anko中设置Listeners非常简单，我下面以Button的OnClick举例： 12345button("登录") &#123; id = buttonLogin textSize = 26f onClick &#123; toast("OnClickLoginButton") &#125;&#125; 使用Fragment加载先创建一个Activity，把Fragment加进去 123456789class AnkoFragmentActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) linearLayout &#123; id = R.id.fragment_id supportFragmentManager.beginTransaction().replace(id, AnkoFragment.newInstance()).commit() &#125; &#125;&#125; 然后在Fragment的onCreateView()中加入DSL代码，然后返回View即可 12345678910111213141516class AnkoFragment : Fragment() &#123; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; // return inflater.inflate(R.layout.fragment_anko, container, false) return UI &#123; verticalLayout &#123; editText() button("OK") &#125; &#125;.view &#125; companion object &#123; fun newInstance(): AnkoFragment &#123; return AnkoFragment() &#125; &#125;&#125; 不足AnkoLayout确实挺好的，因为他把UI代码集成到了代码文件中，不用再像以前一样写一个点击事件还得先findViewBuId，然后再setOnClickListeners。代码能非常简洁。 但是AnkoLayout还是不够完美，感觉写起来还是没有XML那个顺手（可能是我写惯了XML，刚开始用Anko还不够熟练），而且Anko还有很多控件都不支持。最重要的是，他没有实时预览！！！ Android Studio里面有一个叫Anko Support的插件，可以实现anko的预览，但是他必须是先将项目构建了再预览的，不算是实时预览]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android类之SharedPreferences]]></title>
    <url>%2Fposts%2F8a47fe84.html</url>
    <content type="text"><![CDATA[Android类之SharedPreferences简介SharedPreferences是一个轻量的存储类，用于把一些只需要少量简单类型数据保存到本地，例如搜索历史、用户设置等。 他只适合处理简单的数据，处理太过于庞大的数据会减慢程序运行。 使用步骤1. 存储数据 使用Activity类的getSharedPreferences()方法获得SharedPreferences对象，其中存储key-value的文件名由getSharedPreferences()方法的第一个参数指定。 使用SharedPreferences接口的edit()获得SharedPreferences.Editor对象。 通过SharedPreferences.Editor接口的putXxx()方法保存key-value对，其中Xxx表示不同的数据类型。例如：字符串类型的value需要用putString方法。 通过SharedPreferences.Editor接口的commit()方法保存key-value对，commit方法相当于数据库事务中的提交操作。 12345SharedPreferences sharedPreferences = getSharedPreferences("test", Context.MODE_PRIVATE);Editor editor = sharedPreferences.edit();//获取编辑器editor.putString("name", "小明");editor.putInt("age", 24);editor.commit();//提交修改 2. 读取数据 使用Activity类的getSharedPreferences()方法获得SharedPreferences对象。 通过SharedPreferences对象的getXxx()方法得到数据。 1234SharedPreferences sharedPreferences= getSharedPreferences("test", Activity.MODE_PRIVATE);// 使用getString方法获得value，注意第2个参数是value的默认值 String name =sharedPreferences.getString("name", "");int age =sharedPreferences.getInt("age", 0); SharedPreferences的四种模式 1234Context.MODE_PRIVATE：为默认操作模式,代表该文件是私有数据,只能被应用本身访问,在该模式下,写入的内容会覆盖原文件的内容Context.MODE_APPEND：模式会检查文件是否存在,存在就往文件追加内容,否则就创建新文件.Context.MODE_WORLD_READABLE：表示当前文件可以被其他应用读取.Context.MODE_WORLD_WRITEABLE：表示当前文件可以被其他应用写入.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidView之PopupWindow]]></title>
    <url>%2Fposts%2F1900f7eb.html</url>
    <content type="text"><![CDATA[AndroidView之PopupWindow因为项目中有很多地方都需要使用PopupWindow，所以特别查了一下，做了一个简单的总结，过两天就加到项目中去。 PopupWindowPopupWindow，顾名思义，就是一个用来显示弹窗的组件。 创建步骤 创建PopupWindow实例 设置一些基本参数 显示PopupWindow构造方法 1PopupWindow window = new PopupWindow(View contentView, int width, int height, boolean focusable); 这个方法有四个参数，第一个参数是用于PopupWindow中的View，第二个参数是PopupWindow的宽度，第三个参数是PopupWindow的高度，第四个参数指定PopupWindow能否获得焦点。 示例代码 12View contentView = LayoutInflater.from(MainActivity.this).inflate(R.layout.popuplayout, null);PopupWindwo window = PopupWindow (contentView, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, true); 基本方法 window.setBackgroundDrawable(Drawable background); 设置PopupWindow的背景 window.setOutsideTouchable(boolean touchable); 设置PopupWindow是否能响应外部点击事件 window.setTouchable(boolean touchable); 设置PopupWindow是否能响应点击事件只有同时设置PopupWindow的背景和可以响应外部点击事件，它才能“真正”响应外部点击事件。 显示PopupWindow window.showAtLocation(View parent, int gravity, int x, int y); 第一个参数是PopupWindow的父View，第二个参数是PopupWindow相对父View的位置，第三和第四个参数分别是PopupWindow相对父View的x、y偏移 window.showAsDropDown(View anchor, int xoff, int yoff, int gravity); 第一个参数是PopupWindow的锚点，第二和第三个参数分别是PopupWindow相对锚点的x、y偏移 为PopupWindow添加动画 进入时动画：(context_menu_enter.xml) 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:duration="@android:integer/config_shortAnimTime" android:fromXDelta="0" android:fromYDelta="100%p" android:interpolator="@android:anim/accelerate_decelerate_interpolator" android:toXDelta="0" android:toYDelta="0"/&gt; &lt;/set&gt; 退出时动画：(context_menu_exit.xml) 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;translate android:duration="@android:integer/config_shortAnimTime" android:fromXDelta="0" android:fromYDelta="0" android:interpolator="@android:anim/accelerate_decelerate_interpolator" android:toXDelta="0" android:toYDelta="100%p" /&gt; &lt;/set&gt; 生成style 1234&lt;style name=&quot;contextMenuAnim&quot; parent=&quot;@android:style/Animation.Activity&quot;&gt; &lt;item name=&quot;android:windowEnterAnimation&quot;&gt;@anim/context_menu_enter&lt;/item&gt; &lt;item name=&quot;android:windowExitAnimation&quot;&gt;@anim/context_menu_exit&lt;/item&gt;&lt;/style&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
</search>
