[{"title":"Android消息机制之Handler详解","url":"/posts/21eb5c30.html","content":"# 简介\n作为一个Android开发者，Handler的大名你一定听过。做Android开发肯定离不开Handler，它通常被我们用来连通主线程和子线程。\n\n可以说只要有异步的地方一定有Handler。\n\n那么，你了解过为什么Handler能连通主线程和子线程吗，也就是说，你了解过Handler背后的原理吗？\n\n就让本文带你了解。\n\n# Handler的基本用法\n按照惯例，我们首先看下Handler的一般用法：\n```java\nHandler mHandler = new Handler() {\n    @Override\n    public void handleMessage(final Message msg) {\n        // 在这里接受并处理消息\n    }\n};\n\n//发送消息\nmHandler.sendMessage(message);\nmHandler.post(runnable);\n```\n\n也就是创建一个Handler对象，并重写handlerMessage方法，然后在需要的时候调用sendMessage方法传入一个message对象，或者调用post方法传入一个runnable对象。\n\n那么我们从他的构造方法开始看起吧。\n\n# 从Handler构造方法入手\n```java\npublic Handler() {\n    // ->> 分析1.1\n    this(null, false);\n}\n```\n\n## 分析1.1 Handler # 构造方法\n```java\n/**\n * 分析1.1：实际上调用的又是另一个构造方法\n */\npublic Handler(@Nullable Callback callback, boolean async) {\n    if (FIND_POTENTIAL_LEAKS) {\n        // 这个变量字面意思是找到内存泄漏，\n        // 但是整个Handler中除了这块以及定义这个变量为false之外，\n        // 就没有其他地方使用到过这个变量了，所以这块我也不太懂这个变量是怎么变为true的\n        final Class<? extends Handler> klass = getClass();\n        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&\n                (klass.getModifiers() & Modifier.STATIC) == 0) {\n            Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +\n                klass.getCanonicalName());\n        }\n    }\n\n    // ->> 分析1.2\n    mLooper = Looper.myLooper();\n    // ->> 分析1.3\n    if (mLooper == null) {\n        throw new RuntimeException(\n            \"Can't create handler inside thread \" + Thread.currentThread()\n                    + \" that has not called Looper.prepare()\");\n    }\n    // 获取对象的mQueue属性，mQueue就是MessageQueue\n    mQueue = mLooper.mQueue;\n    mCallback = callback;\n    mAsynchronous = async;\n}\n```\n\n## 分析1.2 Looper # myLooper()\n```java\n/**\n * 分析1.2：Looper.myLopper()\n * 实际上调用的是ThreadLocal的get方法，然后返回该线程的Looper对象\n */\npublic static @Nullable Looper myLooper() {\n    return sThreadLocal.get();\n}\n```\nThreadLocal是一个数据存储类，他的特别之处在于他是线程间独立的，也就是说这个线程放入到ThreadLocal的数据，其它线程是获取不到的。sThreadLocal就是获取当前线程的Looper对象。详细可见我之前的博客。\n\n## 分析1.3 Looper # prepare()\n为什么说如果mLooper为空就抛异常呢，这是因为一个Handler必须和一个Looper绑定，并且要先初始化Looper才能去初始化Handler。初始化Looper就通过Looper的prepare方法。\n```java\n/**\n * 分析1.3：Looper.prepare()\n */\npublic static void prepare() {\n    prepare(true);\n}\n\nprivate static void prepare(boolean quitAllowed) {\n    if (sThreadLocal.get() != null) {\n        throw new RuntimeException(\"Only one Looper may be created per thread\");\n    }\n    // ->> 分析1.4\n    sThreadLocal.set(new Looper(quitAllowed));\n}\n```\n这个方法和myLooper方法类似，就是通过ThreadLocal设置Looper。\n\n## 分析1.4 Looper # 构造方法\n```java\n/**\n * 分析1.4：Looper的构造方法\n */\nprivate Looper(boolean quitAllowed) {\n    mQueue = new MessageQueue(quitAllowed);\n    mThread = Thread.currentThread();\n}\n```\nLooper的构造方法是私有的，也就是说外界并不能直接创建Looper方法，必须通过Looper.prepare方法来创建Looper对象，这样也就方便了保证一个线程只能有一个Looper对象。\n\n在构造方法中，我们创建了一个MessageQueue对象。这个对象就是用来存放消息的消息队列。关于MessageQueue我们后面再来讲。\n\n# 消息是如何存放的\n上面就是Handler和Looper的一个构造方式，构造完成后，我们就要关注Handler是如何把消息放入MessageQueue中的，以及是如何从MessageQueue中取出的。\n\n上面我们在讲Handler的基本用法的时候，讲到过sendMessage方法和post方法。我们先来看下这两个方法：\n\n## Handler # sendMessage() & post()\n其实这块先不上具体的方法实现，先说一下他们的方法调用流程：\n```java\nsendMessage()\n    -> sendMessageDelayed()\n        -> sendMessageAtTime()\n            -> enqueueMessage()\n\npost()\n    -> sendMessageDelayed()\n        -> sendMessageAtTime()\n            -> enqueueMessage()\n```\n\n可以看到，这两个方法都会调用立马调用sendMessageDelayed():\n```java\npublic final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) {\n    // 默认都传入0\n    if (delayMillis < 0) {\n        delayMillis = 0;\n    }\n    // ->> 分析2.1\n    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\n}\n```\n\n## 分析2.1 Handler # sendMessageAtTime()\n```java\n/**\n * 分析2.1：sendMessageAtTime()\n * 传入参数：\n *     msg：需要传递的消息\n *     uptimeMillis：更新时间，也就是系统从开机到目前经过的时候 + delayMillis(也就是0)\n */\npublic boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) {\n    MessageQueue queue = mQueue;\n    if (queue == null) {\n        RuntimeException e = new RuntimeException(\n                this + \" sendMessageAtTime() called with no mQueue\");\n        Log.w(\"Looper\", e.getMessage(), e);\n        return false;\n    }\n    // ->> 分析2.2\n    return enqueueMessage(queue, msg, uptimeMillis);\n}\n```\n\n## 分析2.2 Handler # enqueueMessage()\n```java\n/**\n * 分析2.2：enqueueMessage()\n */\nprivate boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,\n        long uptimeMillis) {\n    msg.target = this;\n    msg.workSourceUid = ThreadLocalWorkSource.getUid();\n\n    if (mAsynchronous) {\n        msg.setAsynchronous(true);\n    }\n    // ->> 这块就将消息存放到MessageQueue队列中去\n    return queue.enqueueMessage(msg, uptimeMillis);\n}\n```\n\n那么消息就成功的从Handler中被存入了MessageQueue，那么消息什么时候从MessageQueue中被调出来呢?\n\n# 消息是如何存放的\n## Looper # loop()\nLooper里面有一个loop方法，我们可以看下这个方法:\n```java\npublic static void loop() {\n    // 获取当前线程的Looper对象\n    final Looper me = myLooper();\n    if (me == null) {\n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }\n    // 获取当前线程的MessageQueue\n    final MessageQueue queue = me.mQueue;\n\n    // ...省略中间代码\n\n    // 死循环\n    for (;;) {\n        // 从消息队列中取出一个消息\n        // ->> 分析3.1\n        Message msg = queue.next(); // might block\n        // 如果取出的消息为空，就退出。\n        // 但是我之前说这个循环是个死循环？\n        // 这是因为虽然会有这个if可能会导致循环退出，但是通过next方法取出消息的时候，如果没有消息了，next方法会阻塞线程，直到有新的消息进来\n        // 这也就意味着，一般正常的遍历MessageQueue情况下，是不会有msg==null的。\n        // 但是如果你调用了Looper的quit或者quitSafely方法，这个时候next会返回null，就会退出循环。\n        if (msg == null) {\n            // No message indicates that the message queue is quitting.\n            return;\n        }\n\n        // ...省略中间代码\n        \n        try {\n            // 传给Handler去处理消息\n            // ->> 分析3.2\n            msg.target.dispatchMessage(msg);\n            if (observer != null) {\n                observer.messageDispatched(token, msg);\n            }\n            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;\n        } catch (Exception exception) {\n            // ...省略中间代码\n        } finally {\n            // ...省略中间代码\n        }\n        \n        // ...省略中间代码\n    }\n}\n```\n\n## 分析3.1 MessageQueue # next()\n```java\n/**\n * 分析3.1 MessageQueue.next()\n * 作用：\n *     用于取出消息队列中的下一个消息\n * PS：\n *     看到这个next你或许就应该懂了，其实这个MessageQueue并不是咱们顾名思义以为的那个Queue，其实他的实现是一个链表 \n */\nMessage next() {\n    // Return here if the message loop has already quit and been disposed.\n    // This can happen if the application tries to restart a looper after quit\n    // which is not supported.\n    // 如果Looper已经退出（调用了dispose方法后mPtr=0）\n    final long ptr = mPtr;\n    if (ptr == 0) {\n        return null;\n    }\n\n    // 记录空闲时需要处理的IdleHandler数量\n    int pendingIdleHandlerCount = -1; // -1 only during first iteration\n    // ->> 分析3.2.1\n    int nextPollTimeoutMillis = 0;\n    for (;;) {\n        if (nextPollTimeoutMillis != 0) {\n            // 刷新Binder命令\n            Binder.flushPendingCommands();\n        }\n\n        // 调用native层，如果返回了就说明可以从队列中取出一条消息\n        // 如果消息队列中没有消息就阻塞等待，靠enqueueMessage()中最后一步调用nativeWake()来唤醒该方法\n        nativePollOnce(ptr, nextPollTimeoutMillis);\n\n        synchronized (this) {\n            // Try to retrieve the next message.  Return if found.\n            // 得到时间-从手机开机到现在调用经过的时间\n            final long now = SystemClock.uptimeMillis();\n            Message prevMsg = null;\n            // 得到队头\n            Message msg = mMessages;\n            // 判断这个message是不是barrier\n            if (msg != null && msg.target == null) {\n                // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                // 循环遍历出第一个异步消息，如果设置了barrier，就不能再执行同步消息了，除非将barrier移除。\n                // 但是异步消息不受影响照样执行，所以在这里要找到异步消息\n                do {\n                    prevMsg = msg;\n                    msg = msg.next;\n                } while (msg != null && !msg.isAsynchronous());\n            }\n            if (msg != null) {\n                // 如果分发时间还没到\n                if (now < msg.when) {\n                    // Next message is not ready.  Set a timeout to wake up when it is ready.\n                    // 更新执行时间点\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {\n                    // 时间到了\n                    // Got a message.\n                    mBlocked = false;\n                    if (prevMsg != null) {\n                        prevMsg.next = msg.next;\n                    } else {\n                        mMessages = msg.next;\n                    }\n                    msg.next = null;\n                    if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                    msg.markInUse();\n                    return msg;\n                }\n            } else {\n                // 如果没有其他消息了\n                nextPollTimeoutMillis = -1;\n            }\n\n            // Process the quit message now that all pending messages have been handled.\n            // 正在退出了，返回null。\n            if (mQuitting) {\n                dispose();\n                return null;\n            }\n\n            // If first time idle, then get the number of idlers to run.\n            // Idle handles only run if the queue is empty or if the first message\n            // in the queue (possibly a barrier) is due to be handled in the future.\n            // 判断如果这是第一次循环（只有第一次循环时会小于0）并且队列为空或还没到处理第一个的时间\n            if (pendingIdleHandlerCount < 0\n                    && (mMessages == null || now < mMessages.when)) {\n                pendingIdleHandlerCount = mIdleHandlers.size();\n            }\n            if (pendingIdleHandlerCount <= 0) {\n                // No idle handlers to run.  Loop and wait some more.\n                // 置为阻塞状态\n                mBlocked = true;\n                continue;\n            }\n\n            // 初始化最少四个要被执行的IdleHandler\n            if (mPendingIdleHandlers == null) {\n                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];\n            }\n            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);\n        }\n\n        // Run the idle handlers.\n        // We only ever reach this code block during the first iteration.\n        // 开始循环执行所有的IdleHandler并根据返回值判断是否保留\n        for (int i = 0; i < pendingIdleHandlerCount; i++) {\n            final IdleHandler idler = mPendingIdleHandlers[i];\n            mPendingIdleHandlers[i] = null; // release the reference to the handler\n\n            boolean keep = false;\n            try {\n                keep = idler.queueIdle();\n            } catch (Throwable t) {\n                Log.wtf(TAG, \"IdleHandler threw exception\", t);\n            }\n\n            if (!keep) {\n                synchronized (this) {\n                    mIdleHandlers.remove(idler);\n                }\n            }\n        }\n\n        // IdleHandler只会在消息队列阻塞之前执行一次，之后再不会执行，知道下一次被调用next()。\n        pendingIdleHandlerCount = 0;\n\n        // While calling an idle handler, a new message could have been delivered\n        // so go back and look again for a pending message without waiting.\n        // 当执行了IdleHandler后，会消耗一段时间，刺死可能已经到达执行消息的时间了，所以重置该变量再重新检查时间。\n        nextPollTimeoutMillis = 0;\n    }\n}\n```\n\n### 分析3.2.1 \nnextPollTimeoutMillis是一个变量，用于表示时间。\n* 如果nextPollTimeoutMillis = -1，则一直会阻塞不会超时\n* 如果nextPollTimeoutMillis = 0，不会阻塞，立即返回\n* 如果nextPollTimeoutMillis > 0，最长阻塞nextPollTimeoutMillis毫秒，如果期间有程序唤醒会立即返回\n\n\n## 分析3.2 Handler # dispatchMessage()\n```java\n/**\n * 分析3.2 Handler.dispatchMessage()\n */\npublic void dispatchMessage(@NonNull Message msg) {\n    // 先查看message自己callback有没有被设置，如果有那就交给自己的callback去处理\n    if (msg.callback != null) {\n        handleCallback(msg);\n    } else {\n        // 如果没有message自己的callback，那就看看Handler有没有callback，\n        // 如果有，那就交给Handler的Callback去处理，\n        if (mCallback != null) {\n            if (mCallback.handleMessage(msg)) {\n                return;\n            }\n        }\n        // 如果Handler自己还没有Callback，那就Handler自己处理\n        handleMessage(msg);\n    }\n}\n```\n从上面可以得到以下信息：\n处理消息的方式有3个，分别为Message自己的Callback、Handler的Callback以及Handler自己。\n1. 优先级最高的是Message自己的callback，这是一个Runnable对象，我们用Handler post一个Runnable的时候，其实就是把这个Runnable赋值个一个Message对象的callback，然后把Message对象发送给MessageQueue。\n2. 优先级第二的是Handler自己的mCallback，在我们创建一个Handler对象的使用可以传一个Handler.Callback对象给它并实现Callback里的handleMessage(msg)方法，作为我们的消息处理方法。\n3. 优先级最低的是Handler自己的handleMessage(msg)方法，这也是我们最常用的消息处理方法。\n\n# 流程图\n（图片来自于[此处](https://juejin.im/post/5c74b64a6fb9a049be5e22fc#heading-7)）\n![](http://cdn.littlecorgi.top/mweb/2019-11-17/15739707276639.jpg)\n![](http://cdn.littlecorgi.top/mweb/2019-11-17/15739710069538.jpg)\n\n\n# 延伸\n## 1. 为什么说Handler可能会导致内存泄漏\n只要你用Android Studio，并在Activity里面用过Handler，都会注意到一个地方，就是如果你直接创建Handler对象并重写handleMessage方法的话，AS一把都会报一个warning：\n![](http://cdn.littlecorgi.top/mweb/2019-11-17/15739712887055.jpg)\n```\nThis Handler class should be static or leaks might occur.\n\n该处理程序类应为静态，否则可能发生泄漏\n```\n\n就是说如果直接这样写就可能会导致内存泄漏，但是如果你在不是Activity的类里面这样写又不会报warning，这是为什么呢？\n\n因为Handler允许我们发送延时消息，但是如果在延时期间，用户关闭了Activity。这时Message持有Handler，而又因为Java的特性，内部类会持有外部类，也就是说Handler会持有Activity，这样就导致Activity泄漏了。\n\n解决办法就是把Handler定义为静态内部类，并在内部持有Activity的弱引用，并及时移除所有消息：\n```java\nprivate static class SafeHandler extends Handler {\n    private WeakReference<MainActivity> ref;\n\n    public SafeHandler(MainActivity activity) {\n        this.ref = new WeakReference<>(activity);\n    }\n\n    @Override\n    public void handleMessage(@NonNull Message msg) {\n\n    }\n}\n```\n\n\n## 2. 为什么主线程不需要创建Looper，而且主线程的Looper不许退出\n因为在主线程创建时会自动调用Looper的prepare方法，并调用loop方法。我们就可以直接在主线程使用Handler。\n\n而为什么不能退出，是因为如果Looper退出了，那么主线程就会挂掉。Android也不许你手动退出主线程的Looper。\n\n","tags":["Android","Handler","ThreadLocal","源码"],"categories":["Android"]},{"title":"Android消息机制之ThreadLocal","url":"/posts/64f0a9f6.html","content":"# 简介\nThreadLocal是一个线程内部的数据储存类，通过他可以在指定的线程中存储数据。数据存储以后，只有在指定的线程中可以获取到存储的数据，对于其他线程来说则无法获取。\n\n在源码中是这样写的：\n>This class provides thread-local variables.  These variables differ from\n>their normal counterparts in that each thread that accesses one (via its\n>{@code get} or {@code set} method) has its own, independently initialized\n>copy of the variable.  {@code ThreadLocal} instances are typically private\n>static fields in classes that wish to associate state with a thread (e.g.,\n>a user ID or Transaction ID).\n \n翻译过来，就是说这个类提供线程局部变量，但是他和普通变量不同，他是每个线程都有自己的一个独立初始化的变量副本。而通过`get()`和`set()`方法就能得到和设置当前线程对应的该变量的值。\n\n# 示例\n接下来我们看一下示例代码，在一个Activity的onCreate方法中写入如下代码：\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    // 需要添加的代码\n    private static final String TAG = \"MainActivity\";\n    // 需要添加的代码\n    private ThreadLocal<Boolean> mBooleanThreadLocal = new ThreadLocal<>();\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        // 需要添加的代码\n        mBooleanThreadLocal.set(true);\n        Log.d(TAG, \"[Thread#main]mBooleanThreadLocal=\" + mBooleanThreadLocal.get());\n\n        // 需要添加的代码\n        new Thread(\"Thread#1\") {\n            @Override\n            public void run() {\n                mBooleanThreadLocal.set(false);\n                Log.d(TAG, \"[Thread#1]mBooleanThreadLocal=\" + mBooleanThreadLocal.get());\n            }\n        }.start();\n        \n        // 需要添加的代码\n        new Thread(\"Thread#2\") {\n            @Override\n            public void run() {\n                Log.d(TAG, \"[Thread#2]mBooleanThreadLocal=\" + mBooleanThreadLocal.get());\n            }\n        }.start();\n    }\n}\n```\n\n根据我们上面说的ThreadLocal的特性，就可以猜出应该会输出：\n```java\n[Thread#main]mBooleanThreadLocal=true\n[Thread#1]mBooleanThreadLocal=false\n[Thread#2]mBooleanThreadLocal=null\n```\n\n然后运行输出的结果，不出所料，果然和上面一样。\n\n# 使用场景\n一般来说，当某些数据是以线程作为作用域并且不同线程具有不同的数据副本的时候，就可以考虑使用ThreadLocal。比如对于Handler来说，它需要获取当前线程的Looper，很显然Looper的作用域就是线程并且不同线程具有不同的Looper，这个时候通过ThreadLocal就可以轻松实现Looper在线程中的存取，如果不采用ThreadLocal，那么系统就必须提供一个全局的哈希表供Handler查找指定线程的Looper，这样一来就必须提供一个类似于LooperManager的类了，但是系统并没有这么做而是选择了ThreadLocal，这就是ThreadLocal的好处。\n\n另一个使用场景就是复杂逻辑下的对象传递。比如监听器的传递，有些时候一个线程中的任务过于复杂，这可能表现为函数调用栈比较深以及代码入口的多样性，在这种情况下，我们又需要监听器能够贯穿整个线程的执行过程，这个时候可以怎么做呢？其实就可以采用ThreadLocal，采用ThreadLocal可以让监听器作为线程内的全局对象而存在，在线程内部只要通过get方法就可以获取到监听器。而如果不采用ThreadLocal，那么我们能想到的可能是如下两种方法：第一种方法是将监听器通过参数的形式在函数调用栈中进行传递，第二种方法就是将监听器作为静态变量供线程访问。上述这两种方法都是有局限性的。第一种方法的问题时当函数调用栈很深的时候，通过函数参数来传递监听器对象这几乎是不可接受的，这会让程序的设计看起来很糟糕。第二种方法是可以接受的，但是这种状态是不具有可扩充性的，比如如果同时有两个线程在执行，那么就需要提供两个静态的监听器对象，如果有10个线程在并发执行呢？提供10个静态的监听器对象？这显然是不可思议的，而采用ThreadLocal每个监听器对象都在自己的线程内部存储，根据就不会有方法2的这种问题。\n\n# 源码\n作为一个存储数据的类，关键点就在get和set方法。\n## ThreadLocal # set\n\n```java\npublic void set(T value) {\n    // 获取当前线程\n    Thread t = Thread.currentThread();\n    // 实际上存储数据的结构类型\n    // ->> 分析1\n    ThreadLocalMap map = getMap(t);\n    // 如果存在Map就直接set，没有就创建map并set\n    if (map != null)\n        map.set(this, value);\n    else\n        // ->> 分析2\n        createMap(t, value);\n}\n\n\n/**\n * 分析1：getMap()方法\n */\nThreadLocalMap getMap(Thread t) {\n    // 返回传入线程的ThreadLocalMap\n    return t.threadLocals;\n}\n\n/**\n * 分析2：createMap()方法\n */\nvoid createMap(Thread t, T firstValue) {\n    // 创建一个新的ThreadLocalMap并将值传入\n    t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n```\n当你调用set方法时，就会拿到当前线程并得到当前线程的ThreadLocalMap，如果map不为空，那就直接把值传入map；如果map为空那就新建一个再传值。\n\n这块我们就能懂为啥ThreadLocal能只操作自己线程里面的东西了，因为所有ThreadLocal都与他线程中的ThreadLocalMap有关。\n\n那我们再来看看ThreadLocalMap。\n## ThreadLocalMap\n### 属性变量\n先来看下ThreadLocalMap的一些变量。\n```java\n// 存储数据的结构为Entry，而且key是弱引用\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n    Object value;\n\n    Entry(ThreadLocal<?> k, Object v) {\n        super(k);\n        value = v;\n    }\n}\n\n// table的初始容量\nprivate static final int INITIAL_CAPACITY = 16;\n\n// table用于存储数据\nprivate Entry[] table;\n\n// \nprivate int size = 0;\n\n// 负载因子，用于扩容\nprivate int threshold; // Default to 0\n\n// 设置负载因子，默认为当前大小的2/3\nprivate void setThreshold(int len) {\n    threshold = len * 2 / 3;\n}\n\n// 下一个索引\nprivate static int nextIndex(int i, int len) {\n    return ((i + 1 < len) ? i + 1 : 0);\n}\n\n// 上一个索引\nprivate static int prevIndex(int i, int len) {\n    return ((i - 1 >= 0) ? i - 1 : len - 1);\n}\n\n// 构造函数\nThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {\n    table = new Entry[INITIAL_CAPACITY];\n    int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);\n    table[i] = new Entry(firstKey, firstValue);\n    size = 1;\n    setThreshold(INITIAL_CAPACITY);\n}\n```\n\n### ThreadLocalMap # set()\n```java\nprivate void set(ThreadLocal<?> key, Object value) {\n\n    Entry[] tab = table;\n    int len = tab.length;\n    // 根据哈希算法找到对应节点\n    int i = key.threadLocalHashCode & (len-1);\n\n    //判断当前位置是否有数据，如果key值相同，就替换，如果不同则找空位放数据。\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal<?> k = e.get();\n        //判断key值相同否，如果是直接覆盖 （第一种情况）\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n        //如果当前Entry对象对应Key值为null,则清空所有Key为null的数据（第二种情况）\n        if (k == null) {\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n    }\n    //以上情况都不满足，直接添加（第三种情况）\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    if (!cleanSomeSlots(i, sz) && sz >= threshold)\n        rehash();\n}\n```\n先根据key通过哈希算法得到对应的i，然后再开始从这个i开始遍历，进行判断，由于下面三个判断比较复杂，所以我们分开来讲。\n\n#### 第一种情况\n这种情况下，key值相同，就需要将value替换掉。\n![第一种情况](http://cdn.littlecorgi.top/mweb/2019-11-08/%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5.jpg)\n\n#### 第二种情况\n这种情况比较复杂，先看下代码：\n```java\nprivate void replaceStaleEntry(ThreadLocal<?> key, Object value,\n                               int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n    Entry e;\n    \n    int slotToExpunge = staleSlot;\n    // 先往前进行判断，看是否能找到空的节点，找到了就更新slotToExpunge\n    for (int i = prevIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = prevIndex(i, len))\n        if (e.get() == null)\n            slotToExpunge = i;\n\n    // 再往后遍历\n    for (int i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal<?> k = e.get();\n\n        // 如果当前i节点的key和传入的key相同，那就进行替换\n        if (k == key) {\n            e.value = value;\n\n            tab[i] = tab[staleSlot];\n            tab[staleSlot] = e;\n\n            /*\n             * 如果在整个扫描过程中（包括函数一开始的向前扫描与i之前的向后扫描）\n             * 找到了之前的无效slot则以那个位置作为清理的起点，\n             * 否则则以当前的i作为清理起点\n             */\n            if (slotToExpunge == staleSlot)\n                slotToExpunge = i;\n            // 进行一次连续段的清理，再做一次启发式清理\n            // ->> 分析1\n            // ->> 分析2\n            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n            return;\n        }\n\n        // 如果当前的slot已经无效，并且向前扫描过程中没有无效slot，则更新slotToExpunge为当前位置\n        if (k == null && slotToExpunge == staleSlot)\n            slotToExpunge = i;\n    }\n\n    // 如果key在table中不存在，则在原地放一个即可\n    tab[staleSlot].value = null;\n    tab[staleSlot] = new Entry(key, value);\n\n    // 在探测过程中如果发现任何无效slot，则做一次清理（连续段清理+启发式清理）\n    // ->> 分析1\n    // ->> 分析2\n    if (slotToExpunge != staleSlot)\n        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n}\n\n\n/**\n * 分析1：expungeStaleEntry()\n * 作用：把连续段内所有无效的slot都清理一遍\n */\nprivate int expungeStaleEntry(int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    tab[staleSlot].value = null;\n    tab[staleSlot] = null;\n    size--;\n\n    Entry e;\n    int i;\n    for (i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal<?> k = e.get();\n        if (k == null) {\n            e.value = null;\n            tab[i] = null;\n            size--;\n        } else {\n            int h = k.threadLocalHashCode & (len - 1);\n            if (h != i) {\n                tab[i] = null;\n\n                while (tab[h] != null)\n                    h = nextIndex(h, len);\n                tab[h] = e;\n            }\n        }\n    }\n    return i;\n}\n\n/**\n * 分析2：cleanSomeSlots()\n * 作用：遍历删除所有位置下key==null的数据\n */\nprivate boolean cleanSomeSlots(int i, int n) {\n    boolean removed = false;\n    Entry[] tab = table;\n    int len = tab.length;\n    do {\n        i = nextIndex(i, len);\n        Entry e = tab[i];\n        if (e != null && e.get() == null) {\n            n = len;\n            removed = true;\n            // ->> 分析3\n            i = expungeStaleEntry(i);\n        }\n    } while ( (n >>>= 1) != 0);\n    return removed;\n}\n```\n\n示意图如下：\n![第二种情况](http://cdn.littlecorgi.top/mweb/2019-11-08/%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%83%85%E5%86%B5.jpg)\n\n\n#### 第三种情况\n第三种情况就是上面两种情况都不满足的情况，也就是需要插入的位置为null的时候，就直接扩大ThreadLocalMap，然后再插入：\n![第三种情况](http://cdn.littlecorgi.top/mweb/2019-11-08/%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5.jpg)\n\n\n```java\ntab[i] = new Entry(key, value);\nint sz = ++size;\n// ->> cleanSomeSlots见上面第二种情况的分析2\nif (!cleanSomeSlots(i, sz) && sz >= threshold)\n    // ->> 分析1\n    rehash();\n\n\n/**\n * 分析1：rehash()\n */\nprivate void rehash() {\n    // ->> expungeStaleEntries见上面第二种情况的分析1\n    expungeStaleEntries();\n\n    if (size >= threshold - threshold / 4)\n        // ->> 分析2\n        resize();\n}\n\n/**\n * 分析2：resize()\n */\nprivate void resize() {\n    Entry[] oldTab = table;\n    int oldLen = oldTab.length;\n    int newLen = oldLen * 2;\n    Entry[] newTab = new Entry[newLen];\n    int count = 0;\n\n    for (int j = 0; j < oldLen; ++j) {\n        Entry e = oldTab[j];\n        if (e != null) {\n            ThreadLocal<?> k = e.get();\n            if (k == null) {\n                e.value = null; // Help the GC\n            } else {\n                int h = k.threadLocalHashCode & (newLen - 1);\n                while (newTab[h] != null)\n                    h = nextIndex(h, newLen);\n                newTab[h] = e;\n                count++;\n            }\n        }\n    }\n\n    setThreshold(newLen);\n    size = count;\n    table = newTab;\n}\n```\n\n### ThreadLocalMap # getEntry()\n```java\nprivate Entry getEntry(ThreadLocal<?> key) {\n    int i = key.threadLocalHashCode & (table.length - 1);\n    Entry e = table[i];\n    if (e != null && e.get() == key)\n        return e;\n    else\n        // ->> 分析1\n        return getEntryAfterMiss(key, i, e);\n}\n\n\n/**\n * 分析1：getEntryAfterMiss()\n */\nprivate Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    // 从当前往后一个个进行遍历，直至找到和key相等的然后返回\n    while (e != null) {\n        ThreadLocal<?> k = e.get();\n        if (k == key)\n            return e;\n        if (k == null)\n            expungeStaleEntry(i);\n        else\n            i = nextIndex(i, len);\n        e = tab[i];\n    }\n    return null;\n}\n```\n\n### ThreadLocalMap # remove()\n```java\nprivate void remove(ThreadLocal<?> key) {\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode & (len-1);\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        if (e.get() == key) {\n            // 显式断开弱引用\n            e.clear();\n            expungeStaleEntry(i);\n            return;\n        }\n    }\n}\n```","tags":["Android","Handler","ThreadLocal","源码"],"categories":["Android"]},{"title":"View的事件分发","url":"/posts/bfb9e8a9.html","content":"从我刚进实验室的时候，学长学姐就说View的事件分发机制是Android里面一个很重要的内容，要我们好好学。\n\n但是随着自己对Android了解的深入，越发觉得这个东西很有必要了解下，正好Android艺术开发探索也看到了View这块，也看了[郭霖大神的博客](https://blog.csdn.net/guolin_blog/article/details/9097463)和[另一位大神的博客](https://www.jianshu.com/p/ea0108d8510e)，所以就好好学习了一番，并写了此博客。\n\n\n# 1. MotionEvent\n在开始讲View事件分发之前，我们先来了解下MotionEvent。\n\n这个就是手指解除到屏幕后所产生的一系列事件，主要为一下三个典型事件：\n- ACTION_DOWM——手指刚接触屏幕\n- ACTION_MOVE——手指在屏幕上移动\n- ACTION_UP——手指从屏幕上松开\n- ACTION_CANCEL——结束事件（非人为）\n\n正常情况下，一次手指触摸屏幕然后离开可能触发一下两种情况：\n- 点击屏幕然后松开：ACTION_DOWN -> ACTION_UP\n- 点击屏幕然后滑动再松开：ACTION_DOWN -> ACTION_MOVE -> ACTION_UP\n\n下面一个图片来概括下：\n![MotionEvent](http://cdn.littlecorgi.top/mweb/2019-10-31/MotionEvent.png)\n\n# 2. 事件分发传递规则\n众所周知，AndroidUI是由Activity、ViewGroup、View及其派生类组成的。\n\n大致示意图如下：\n![AndroidUI](http://cdn.littlecorgi.top/mweb/2019-10-31/AndroidUI.jpg)\n\n其中：\n- Activity：控制生命周期或者处理事件\n- ViewGroup：一组View或者多个View的集合。也是布局Layout的基类。但是特别的是，他也集成自View。\n- View：所有UI组件的基类\n\n从上图我们就可以看出来，事件分发的顺序就是：Activity -> ViewGroup -> View。也就是说一个点击事件产生，先交由Activity，再传到ViewGroup，再传到View。这个过程中只要有一个部分说要拦截，就不会再继续往下传递。\n\n# 3. 事件分发的核心方法\n其实时间分发的核心方法很简单，就由三个方法组成：\n\n- public boolean dispatchTouchEvent(MotionEvent ev)\n用来进行事件的分发。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示是否消耗当前事件。\n- public boolean onInterceptTouchEvent(MotionEvent event)\n在dispatchTouchEvent方法内部调用，用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一事件序列当中，此方法不会再次被调用，返回结果表示是否拦截当前事件。（只有ViewGroup中才有此方法，View中没有）\n\n- public boolean onTouchEvent(MotionEvent event)\n在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件。\n\n三个方法间的关系可以按下面一段伪代码表示：（[参考](https://www.jianshu.com/p/ea0108d8510e)的代码）\n```java\n\n/**\n  * 点击事件产生后 \n  */ \n  // 步骤1：调用dispatchTouchEvent（）\n  public boolean dispatchTouchEvent(MotionEvent ev) {\n\n    boolean consume = false; //代表 是否会消费事件\n\n    // 步骤2：判断是否拦截事件\n    if (onInterceptTouchEvent(ev)) {\n      // a. 若拦截，则将该事件交给当前View进行处理\n      // 即调用onTouchEvent (）方法去处理点击事件\n        consume = onTouchEvent (ev) ;\n\n    } else {\n\n      // b. 若不拦截，则将该事件传递到下层\n      // 即 下层元素的dispatchTouchEvent（）就会被调用，重复上述过程\n      // 直到点击事件被最终处理为止\n      consume = child.dispatchTouchEvent (ev) ;\n    }\n\n    // 步骤3：最终返回通知 该事件是否被消费（接收 & 处理）\n    return consume;\n}\n```\n对于一个根ViewGroup，点击事件产生后，就会传递给他，这时他的dispatchTouchEvent就会被调用，然后就开始判断他是否拦截。如果拦截，那么点击事件就会给ViewGroup去处理，如果不拦截，就调用child.dispatchTouchEvent (ev) 传给子控件的dispatchTouchEvent方法。然后继续循环，直到到最底层view，也就是没有child的时候，或者直到事件被拦截。\n\n# 4. 源码分析\n## 4.1 Activity事件分发\n首先先来看dispatchTouchEvent方法：\n### 源码\n```java\npublic boolean dispatchTouchEvent(MotionEvent ev) {\n    if (ev.getAction() == MotionEvent.ACTION_DOWN) {\n        onUserInteraction();\n        // ->> 分析1\n    }\n    if (getWindow().superDispatchTouchEvent(ev)) {\n    // ->> 分析2\n        return true;\n    }\n    return onTouchEvent(ev);\n    // ->> 分析5\n}\n\n/**\n  * 分析1：onUserInteraction()\n  * 这个方法就是个空方法，但是我是在没搞懂这个方法是干嘛的，所以就直接粘贴了carson这位大神的说明\n  * 作用：实现屏保功能\n  * 注：\n  *    a. 该方法为空方法\n  *    b. 当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法\n  */\npublic void onUserInteraction() {\n}\n\n/**\n  * 分析2：getWindow().superDispatchTouchEvent(ev)\n  * 点开之后进入Window类，\n  * 但是发现这个类是个抽象类，这个方法是个抽象方法。\n  * \n  * 了解过View的同学都知道，Window的唯一实现类就是PhoneWindow\n  * 那我们进入PhoneWindow看下他的superDispatchTouchEvent方法\n  */\npublic abstract boolean superDispatchTouchEvent(MotionEvent event);\n// ->> 分析3\n\n/**\n  * 分析3：PhoneWindow.superDispatchTouchEvent()\n  * 实际上又调用了DecorView的superDispatchTouchEvent方法，DecorView是最顶层的View\n  */\n@Override\npublic boolean superDispatchTouchEvent(MotionEvent event) {\n    return mDecor.superDispatchTouchEvent(event);\n    // ->> 分析4\n}\n\n/**\n * 分析4：DecorView.superDispatchTouchEvent()\n * 注：\n *     a. DecorView继承自FrameLayout，而FrameLayout继承自ViewGroup，也就是说DecorView就是ViewGroup。\n *     b. DecorView调用了父类的dispatchTouchEvent方法，也就相当于ViewGroup的dispatchTouchEvent方法，就把事件交给了ViewGroup去处理，这块后面再说\n */\npublic boolean superDispatchTouchEvent(MotionEvent event) {\n    return super.dispatchTouchEvent(event);\n}\n\n/**\n * 分析5：return onTouchEvent(ev)\n * 当触摸屏事件未由其下的任何视图处理时调用\n * \n */\npublic boolean onTouchEvent(MotionEvent event) {\n    if (mWindow.shouldCloseOnTouch(this, event)) {\n    // ->> 分析6\n        finish();\n        return true;\n    }\n\n    return false;\n    // 只有在点击事件在Window边界外才会返回true，一般情况都返回false，分析完毕\n}\n\n/** \n * 分析6：Window.shouldCloseOnTouch()\n * \n * 返回：\n *         返回true：说明事件在边界外，即 消费事件\n *         返回false：未消费（默认）\n */\npublic boolean shouldCloseOnTouch(Context context, MotionEvent event) {\n    final boolean isOutside =\n            event.getAction() == MotionEvent.ACTION_DOWN && isOutOfBounds(context, event)\n            || event.getAction() == MotionEvent.ACTION_OUTSIDE;\n    // 主要是对于处理边界外点击事件的判断：是否是DOWN事件，event的坐标是否在边界内等\n    if (mCloseOnTouchOutside && peekDecorView() != null && isOutside) {\n        // peekDecorView是返回PhoneWindow的mDecor\n        return true;\n    }\n    return false;\n}\n```\n\n### 流程\n![Activity事件分发流程](http://cdn.littlecorgi.top/mweb/2019-10-31/Activity%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B.jpg)\n\n## 4.2 ViewGroup事件分发\n### 源码\n由于此部分代码过长，我们将代码拆分成两部分：\n#### part1\n```java\n@Override\npublic boolean dispatchTouchEvent(MotionEvent ev) {\n    ...// 仅贴出关键代码\n    \n    boolean handled = false;\n    /**\n     * onFilterTouchEventForSecurity(ev)\n     * 筛选touch事件，进去之后的判断核心就是当前视图是否被其它窗口遮挡或者隐藏\n     */\n    if (onFilterTouchEventForSecurity(ev)) {\n        final int action = ev.getAction();\n        final int actionMasked = action & MotionEvent.ACTION_MASK;\n\n        // Handle an initial down.\n        // ->> 分析1\n        if (actionMasked == MotionEvent.ACTION_DOWN) {\n            // Throw away all previous state when starting a new touch gesture.\n            // The framework may have dropped the up or cancel event for the previous gesture\n            // due to an app switch, ANR, or some other state change.\n            cancelAndClearTouchTargets(ev);\n            resetTouchState();\n        }\n\n        // Check for interception.\n        final boolean intercepted;\n        /**\n         * 分析2\n         * 可以看到会有两种情况下拦截事件：事件类型为DOWN，或者mFirstTouchTarget != null。\n         * 那么这个mFirstTouchTarget是什么呢？\n         * 从后面的代码我们可以得知，当ViewGroup不拦截事件交给子元素处理的时候，mFirstTouchTarget不为null。\n         * 所以，也就是说当MotionEvent为UP或者MOVE的时候，都进不去这个方法，也就是不调用ViewGroup的onInterceptTouchEvent，他不拦截事件\n         */\n        if (actionMasked == MotionEvent.ACTION_DOWN\n                || mFirstTouchTarget != null) {\n            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;\n            if (!disallowIntercept) {\n                intercepted = onInterceptTouchEvent(ev);\n                ev.setAction(action); // restore action in case it was changed\n            } else {\n                intercepted = false;\n            }\n        } else {\n            // There are no touch targets and this action is not an initial down\n            // so this view group continues to intercept touches.\n            intercepted = true;\n        }\n        \n/**\n * 分析1\n * 事件开始时会调用resetTouchState()来清空mFirstAndClearTouchTarget\n */\nif (actionMasked == MotionEvent.ACTION_DOWN) {\n    cancelAndClearTouchTargets(ev);\n    // 核心目的就是清空mFirstAndClearTouchTarget\n    resetTouchState();\n}\n```\n\n#### part2\n```java\n        ...//省略中间代码\n        // 进入if语句，判断条件为没有对事件进行拦截，同时事件没有结束。对ViewGroup的子元素进行遍历\n        if (!canceled && !intercepted) {\n        \n            ...//继续省略中间代码\n            \n                    // 得到所有的子View\n                    final View[] children = mChildren;\n                    // 对子View进行遍历\n                    for (int i = childrenCount - 1; i >= 0; i--) {\n                        final int childIndex = getAndVerifyPreorderedIndex(\n                                childrenCount, i, customOrder);\n                        final View child = getAndVerifyPreorderedView(\n                                preorderedList, children, childIndex);\n\n                        // If there is a view that has accessibility focus we want it\n                        // to get the event first and if not handled we will perform a\n                        // normal dispatch. We may do a double iteration but this is\n                        // safer given the timeframe.\n                        // 该viewgroup设置事件了指向焦点View并且焦点View在前面已经找到了\n                        if (childWithAccessibilityFocus != null) {\n                            // 判断遍历的此View是否是焦点View，如果不是就直接下一遍循环\n                            if (childWithAccessibilityFocus != child) {\n                                continue;\n                            }\n                            // 如果是的话就将找到的焦点view置空\n                            // i回到到数第一个下标\n                            // 这样做的目的是先让该焦点view尝试进行下面的普通分发操作\n                            // 如果成功了，会在下面跳出循环。\n                            // 如果不成功，就将记录的焦点view置空，\n                            // 从最后一个开始重新遍历，不再进入这个判断。\n                            childWithAccessibilityFocus = null;\n                            i = childrenCount - 1;\n                        }\n\n                        // 判断当前子View是否能获取焦点或者是否正在做动画\n                        if (!canViewReceivePointerEvents(child)\n                                || !isTransformedTouchPointInView(x, y, child, null)) {\n                            ev.setTargetAccessibilityFocus(false);\n                            continue;\n                        }\n\n                        newTouchTarget = getTouchTarget(child);\n                        if (newTouchTarget != null) {\n                            // Child is already receiving touch within its bounds.\n                            // Give it the new pointer in addition to the ones it is handling.\n                            newTouchTarget.pointerIdBits |= idBitsToAssign;\n                            break;\n                        }\n\n                        resetCancelNextUpFlag(child);\n                        // ->> 分析1\n                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {\n                            // Child wants to receive touch within its bounds.\n                            mLastTouchDownTime = ev.getDownTime();\n                            if (preorderedList != null) {\n                                // childIndex points into presorted list, find original index\n                                for (int j = 0; j < childrenCount; j++) {\n                                    if (chifcldren[childIndex] == mChildren[j]) {\n                                        mLastTouchDownIndex = j;\n                                        break;\n                                    }\n                                }\n                            } else {\n                                mLastTouchDownIndex = childIndex;\n                            }\n                            mLastTouchDownX = ev.getX();\n                            mLastTouchDownY = ev.getY();\n                            // ->> 分析2\n                            newTouchTarget = addTouchTarget(child, idBitsToAssign);\n                            alreadyDispatchedToNewTouchTarget = true;\n                            break;\n                        }\n\n                        // The accessibility focus didn't handle the event, so clear\n                        // the flag and do a normal dispatch to all children.\n                        ev.setTargetAccessibilityFocus(false);\n                    }\n                  \n                  ... //省略\n        }\n\n/**\n * 分析1 dispatchTransformedTouchEvent()\n * \n * 核心就是那个if (child == null)。\n * 如果child不为空，那么事件就交给子View处理\n */\nprivate boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,\n        View child, int desiredPointerIdBits) {\n    final boolean handled;\n\n    // Canceling motions is a special case.  We don't need to perform any transformations\n    // or filtering.  The important part is the action, not the contents.\n    final int oldAction = event.getAction();\n    if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {\n        event.setAction(MotionEvent.ACTION_CANCEL);\n        if (child == null) {\n            handled = super.dispatchTouchEvent(event);\n        } else {\n            handled = child.dispatchTouchEvent(event);\n        }\n        event.setAction(oldAction);\n        return handled;\n    }\n    ...//省略\n}\n\n/**\n * 分析2\n * 如果子View能处理点击事件，那么就调用addTouchTarget方法，对mFirstTouchTarget方法进行复制，然后再进入part1中分析2。\n */\nprivate TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {\n    final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);\n    target.next = mFirstTouchTarget;\n    mFirstTouchTarget = target;\n    return target;\n}\n```\n\n#### part3\n```java\n        // Dispatch to touch targets.\n        // 如果part2开头的那个if没有进，也就是对事件进行拦截的话，直接到这来\n        // 并且如果没有进入part2，那么mFirstTouchTarget仍然为空，那么就进入if\n        if (mFirstTouchTarget == null) {\n            // No touch targets so treat this as an ordinary view.\n            // 此处在上面分析过了，但是不同的是由于child直接传入了null，那么就执行super.dispatchTouchEven。\n            // 那么super是谁呢？我们在前面说过，ViewGroup是继承自View的，那么他就是执行View的dispatchTouchEvent。\n            handled = dispatchTransformedTouchEvent(ev, canceled, null,\n                    TouchTarget.ALL_POINTER_IDS);\n        } else {\n            ... //省略\n        }\n\n        // Update list of touch targets for pointer up or cancel, if needed.\n        if (canceled\n                || actionMasked == MotionEvent.ACTION_UP\n                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {\n                // ->> 分析1\n            resetTouchState();\n        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {\n            final int actionIndex = ev.getActionIndex();\n            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);\n            removePointersFromTouchTargets(idBitsToRemove);\n        }\n    }\n    \n    ...//省略\n    \n}\n\n/**\n * 分析1\n * 在同一事件系列结束后调用resetTouchState();\n */\nprivate void resetTouchState() {\n    // 对mFirstTouchTarget清空还原\n    clearTouchTargets();\n    resetCancelNextUpFlag(this);\n    mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;\n    mNestedScrollAxes = SCROLL_AXIS_NONE;\n}\n```\n\n### 流程\n此图搬自[Carson_Ho大佬的博客](https://www.jianshu.com/p/38015afcdb58)\n![](http://cdn.littlecorgi.top/mweb/2019-10-31/15725314562031.jpg)\n\n## 4.3 View事件分发\n### 源码\n#### dispatchTouchEvent\n```java\npublic boolean dispatchTouchEvent(MotionEvent event) {\n    ...//省略\n\n    boolean result = false;\n\n    ...//省略\n\n    // 和ViewGroup一样的判断，判断当前视图是否被遮挡或者不可见\n    if (onFilterTouchEventForSecurity(event)) {\n        if ((mViewFlags & ENABLED_MASK) == ENABLED && handleScrollBarDragging(event)) {\n            result = true;\n        }\n        //noinspection SimplifiableIfStatement\n        ListenerInfo li = mListenerInfo;\n        // 检测有没有设置OnTOuchListener，如果有，并且onTouch方法返回true那么进入if，结果导致onTouchEvent不被执行\n        if (li != null && li.mOnTouchListener != null\n                && (mViewFlags & ENABLED_MASK) == ENABLED\n                && li.mOnTouchListener.onTouch(this, event)) {\n                \n            result = true;\n        }\n\n        // 如果没进入上面的if，也就相当于没有设置OnTouchListener，那么执行onTOuchEvent\n        if (!result && onTouchEvent(event)) {\n            result = true;\n        }\n    }\n\n    ...//省略\n\n    return result;\n}\n```\n\n从上面可以看出，**onTouch的优先级高于onTouchEvent**。\n\n#### onTouchEvent\n```java\npublic boolean onTouchEvent(MotionEvent event) {\n    final float x = event.getX();\n    final float y = event.getY();\n    final int viewFlags = mViewFlags;\n    final int action = event.getAction();\n\n    /**\n     * 注释1 \n     * 只有在Click、LongClick、contextClick都不可用的时候才为false\n     */\n    final boolean clickable = ((viewFlags & CLICKABLE) == CLICKABLE\n            || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)\n            || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;\n\n    // 首先判断是不是不可用，如果是，则进入if\n    if ((viewFlags & ENABLED_MASK) == DISABLED) {\n        if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {\n            setPressed(false);\n        }\n        mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;\n        // A disabled view that is clickable still consumes the touch\n        // events, it just doesn't respond to them.\n        // ->> 注释1（见上面👆）\n        return clickable;\n    }\n    // 如果View有代理会执行这个方法\n    if (mTouchDelegate != null) {\n        if (mTouchDelegate.onTouchEvent(event)) {\n            return true;\n        }\n    }\n    \n    // 这块我们只调出ACTION_UP来看\n    // 只要clickable为true(见上面注释1👆)或者TOOLTIP(可能是Android8.0新出的提示功能吧)\n    if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {\n        switch (action) {\n            case MotionEvent.ACTION_UP:\n\n                ...//省略\n                \n                    if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {\n                        // This is a tap, so remove the longpress check\n                        removeLongPressCallback();\n\n                        // Only perform take click actions if we were in the pressed state\n                        if (!focusTaken) {\n                            // Use a Runnable and post this rather than calling\n                            // performClick directly. This lets other visual state\n                            // of the view update before click actions start.\n                            if (mPerformClick == null) {\n                                mPerformClick = new PerformClick();\n                            }\n                            if (!post(mPerformClick)) {\n                                // ->> 分析1\n                                performClickInternal();\n                            }\n                        }\n                    }\n\n                    ... //省略\n                    \n                }\n                mIgnoreNextUpEvent = false;\n                break;\n            \n            ... //省略其它几种MotionEvent\n        }\n\n        return true;\n    }\n    // 由代码可知只要上面的if语句成立，不管进入switch中的任何ACTION或是都不进入，返回值都是true，即事件消费了。\n    return false;\n}\n\n/**\n  * 分析1：performClick（）\n  */\npublic boolean performClick() {  \n\n    if (mOnClickListener != null) {  \n        playSoundEffect(SoundEffectConstants.CLICK);  \n        mOnClickListener.onClick(this);  \n        return true;  \n        // 只要我们通过setOnClickListener（）为控件cvView注册1个点击事件\n        // 那么就会给mOnClickListener变量赋值（即不为空）\n        // 则会往下回调onClick（） & performClick（）返回true\n    }  \n    return false;  \n} \n```\n\n### 流程\n![](http://cdn.littlecorgi.top/mweb/2019-10-31/15725337657670.jpg)\n","tags":["Android","View","源码","事件分发"],"categories":["Android"]},{"title":"OpenGL ES 2.0笔记2——顶点、坐标、图元","url":"/posts/268eb1c2.html","content":"\n> 上节我们对OpenGL做了一个大致的介绍，并写了一个基本框架，在这节中我们将会介绍顶点、坐标系和图元\n\n<!--More-->\n\n# 顶点\n在OpenGL中，所有的东西的结构都是从一个顶点开始的。\n\n所谓顶点，就是一个几何图形的拐点。在介绍顶点之前，我们首先介绍下OpenGL坐标。\n\n## OpenGL坐标系\n如果有会Android开发的朋友，一定会默认为从屏幕的左上角开始，水平往右是x轴，竖直向下是y轴。\n\n但是在OpenGL中是不同的，OpenGL是从显示视窗的正中心是中心，也就是$(0, 0)$，而屏幕最左边的x轴坐标是-1，屏幕最右边的x轴坐标是1，屏幕最上面的y轴坐标是1，屏幕最下面的y轴坐标是-1，也就是下面这幅图：\n\n![opengl_coordinate](http://cdn.littlecorgi.top/mweb/2019-10-18/opengl_coordinate.png)\n\n## 在代码中定义顶点\n在OpenGL中定义顶点有点特殊，我们第一反应都是直接拿数组将顶端存起来就行了，但是在OpenGL中，你除了要将顶点的坐标用数组存起来以外，还得定义一个常量，用来标记一个顶点有两个分量：\n```java\nprivate static final int POSITION_COMPONENT_COUNT = 2;\nfloat[] tableVerticesWithTriangles = {\n    // Triangle 1\n    -0.5f, -0.5f, \n    0.5f,  0.5f,\n    -0.5f,  0.5f,\n\n    // Triangle 2\n    -0.5f, -0.5f, \n    0.5f, -0.5f, \n    0.5f,  0.5f,\n\n    // Line 1\n    -0.5f, 0f, \n    0.5f, 0f,\n\n    // Mallets\n    0f, -0.25f, \n    0f,  0.25f\n};\n```\n\n我们采用浮点数的顺序列表定义顶点数据，这个数组通常被成为顶点属性。\n\n# 图元\n在OpenGL中，只能绘制点、直线和三角形，这三个也被称为图元。\n\n也就意味着，其它所有的图形都得通过这三个基本图元来实现。\n\n如果我们需要绘制一个点，那么一个坐标就可以了，但是如果我们需要绘制一条直线，就需要两个坐标，如果绘制一个三角形，就需要三个坐标。\n\n那么我们就以绘制一个正方形举例：\n\n```java\nfloat[] squareVerticesWithTriangles = {\n    -0.5f, -0.5f, \n    0.5f,  0.5f,\n    -0.5f,  0.5f,\n    0.5f, -0.5f\n};\n```\n\n![坐标](http://cdn.littlecorgi.top/mweb/2019-10-18/%E5%9D%90%E6%A0%87.png)\n\n\n如果我要在这个正方形中间加一个横线的话，那么就直接在上面的数组里面去加，到时候要将顶点着色器加载到图形中的时候再去处理：\n```java\nfloat[] squareVerticesWithTriangles = {\n    // Square\n    -0.5f, -0.5f, \n    0.5f,  0.5f,\n    -0.5f,  0.5f,\n    0.5f, -0.5f,\n    \n    // Line\n    -0.5f, 0,\n    0.5f, 0\n};\n```\n\n![线正方形坐标](http://cdn.littlecorgi.top/mweb/2019-10-18/%E7%BA%BF%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%9D%90%E6%A0%87.png)\n\n\n# 让数据可以被OpenGL读取\n在上面，我们已经完成了顶点的定义，但是现在OpenGL尚还不能读取他们。其原因是这些代码的运行环境与OpenGL运行环境使用了不一样的语言。\n\n当我们运行Java语言的时候，并不是直接运行在硬件上的，而是运行在JVM(纯Java)或者Dalvik(Android)虚拟机上的，并且运行在这些虚拟机上的时候，并不能直接访问本地环境；其次，虚拟机还采用的垃圾回收机制，当检测到变量、对象不再被使用时，就自动释放掉这些内存。\n\n但是本地环境不能这样，因为他是直接运行在硬件上的，他不希望内存会被移来移去或者自动释放。\n\n所以我们就需要一个方案，让Android程序与OpenGL进行通信。\n其实Android代码与硬件通信有两种方法：\n1. 通过JNI技术；\n2. 通过调用android.opengl.GLES20包里面的方法。\n\n我们这块主要是通过第二种方法。\n\nJava中有一种特殊的集合，可以分配本地的内存块，并将Java的数据复制到本地内存。代码如下：\n```java\n// 因为Java中国一个Float型数据占4个字节\nprivate static final int BYTES_PER_FLOAT = 4;\n// 声明一个字节缓冲区\nprivate final FloatBuffer vertexData;\n \nvertexData = ByteBuffer\n    // 分配一块本地内存，所以是数组长度 * 类型所占字节\n    .allocateDirect(tableVerticesWithTriangles.length * BYTES_PER_FLOAT)\n    // 按照本地字节序组织内容\n    .order(ByteOrder.nativeOrder())\n    .asFloatBuffer();\n    // 将数据存入\n    .put(tableVerticesWithTriangles);\n```","tags":["Android","OpenGL","图像处理"],"categories":["OpenGL"]},{"title":"OpenGL ES 2.0笔记1——简介","url":"/posts/a92b4a54.html","content":"# OpenGL是什么？OpenGL ES又是什么？\n## 简介\nOpenGL是一个跨平台的软件接口语言，用于调用硬件的2D、3D图形处理器。\n\n然而受限于现在的移动设备性能，如果将OpenGL直接用在他们上面将会特别卡，于是就出现了OpenGL ES。 OpenGL ES是OpenGL的分支，他专门作用于嵌入式设备，去掉了OpenGL很多不必要的功能。\n\n<!--More-->\n\n## 应用场景\n- 游戏\n- 视频播放器\n- 视频编辑应用\n- 图片编辑应用\n\n等对图像处理的及时性要求较高的应用场景。\n\n## Android对OpenGL ES 的支持\n|OpenGL ES 版本|基于OpenGL的版本|Android引入的版本|兼容性|功能、特色|\n|:-:|:-:|:-:|:-:|:-:|\n|1.0&1.1|1.3&1.5|Android 1.0|-|固定的图像管道，开发难度相比2.0低|\n|2.0|2.0|Android 2.2|不兼容1.x|可编程的渲染管道，性能效率更高，开发难度更高|\n|3.0|3.x|Android 4.3|兼容2.0|性能更高，支持ETC2格式的透明纹理压缩|\n|3.1|4.x|Android 5.0|兼容2.0/3.0|新增计算着色器、单独的着色器对象等新特性|\n\n## 版本的选择\n由于此篇博客是学习阶段写的，而我在网上找到的大部分博客都是2.0，所以就以2.0为主。\n\n其实我觉得应该是3.0，2.0确实太老了，现在Android4.3的手机都较少见了，而3.1又太新了。\n\n## 导入\n首先你得在AndroidManifest.xml中加入\n`<uses-feature android:glEsVersion=\"0x00020000\" android:required=\"true\" />`\n\n其中不同版本对应值：\n\n|OpenGL ES 版本|glEsVersion 版本|\n|:-:|:-:|\n|2.0|0x00020000|\n|3.0|0x00030000|\n|3.1|0x00030001|\n\n# 基本框架\nAndroid框架里面提供了两个类来给你使用OpenGL ES API创建和操作图形：`GLSrufaceView`和`GLSurfaceView.Renderer`。\n\n## GLSrufaceView\n这是一个视图类，你可以通过OpenGL ES API来绘制和操作图形对象，他在功能上很类似与`SurfaceView`。你可以通过创建一个`SurfaceView`的实例并添加你的渲染器来使用这个类。\n\n他的常用方法有：\n- `setEGLContextClientVersion`：设置OpenGL ES版本，2.0则设置2\n- `onPause`：暂停渲染，最好是在`Activity`、`Fragment`的`onPause()`方法内调用，减少不必要的性能开销，避免不必要的崩溃\n- `onResume`：恢复渲染，用法类比`onPause()`\n- `setRenderer`：设置渲染器\n- `setRenderMode`：设置渲染模式\n- `requestRender`: 请求渲染，由于是请求异步线程进行渲染，所以不是同步方法，调用后不会立刻就进行渲染。渲染会回调到`Renderer`接口的`onDrawFrame()`方法。\n- `queueEvent`：插入一个`Runnable`任务到后台渲染线程上执行。相应的，渲染线程中可以通过`Activity`的`runOnUIThread`的方法来传递事件给主线程去执行\n\n其中，GLSurfaceView的渲染模式有：\n- `RENDERMODE_CONTINUOUSLY`：不停地渲染\n- `RENDERMODE_WHEN_DIRTY`：只有调用了`requestRender()`之后才会触发渲染回调onDrawFrame方法\n\n## GLSurfaceView.Renderer\n此接口定义了在GLSurfaceView中绘制图形所需的方法。必须将此接口的实现作为单独的类提供，并使用GLSurfaceView.setRenderer()将其添加到GLSurfaceView的实现类中。\n\n他的主要方法有三个：\n- `onSurfaceCreated(GL10 gl, EGLConfig config)`：GLSurfaceView内的Surface被创建时会被调用到\n- `onSurfaceChanged(GL10 gl, int width, int height)`：Surface尺寸改变时调用到\n- `onDrawFrame(GL10 gl)`：渲染绘制每一帧时调用到\n\n一般情况下，首次创建GLSurfaceView时，会顺序调用`onSurfaceCreated()` -> `onSurfaceChanged()` -> `onDrawFrame()`。然后每绘制一帧，都会不停地回调`onDrawFrame()`方法。\n\n# 编写流程\n首先我们来写一个基本框架。\n\n创建一个Android项目，然后Activity选择EmptyActivity。\n\n**注意：本项目某些类或者方法通过AndroidStudio导入的时候会让你选择是从哪个包里面导入，一致选择`android.opengl.GLES20`**\n\n## 编写Activity\n打开我们项目的MainActivity，你就能看到熟悉的onCreate方法，接下来我们要对这个Activity进行一些更改。\n\n首先，我们要创建一个GLSurfaceView的对象,并添加一个新的成员变量：\n```java\nprivate GLSurfaceView glSurfaceView;\nprivate boolean rendererSet = false;\n```\n\n接下来将`setContentView()`移除，并对glSurfaceView进行初始化：\n```java\n@Override\npublic void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    glSurfaceView = new GLSurfaceView(this);\n}\n```\n\n由于我们是在写OpenGL ES2.0的代码，所以我们需要检测当前运行APP的系统支不支持OpenGL ES2.0。我们将下面几行代码添加到onCreate()里面去:\n```java\nfinal ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);\nfinal ConfigurationInfo configurationInfo = activityManager.deviceConfigurationInfo();\nfinal boolean supportsEs2 = configurationInfo.reqGlEsVersion >= 0x20000;\n```\n\n但是这段代码在模拟器上不能工作，因为GPU模拟部分有缺陷。为了使代码在模拟器上运行，我们要按如下代码修改检查条件：\n```java\nfinal boolean supportsEs2 = configurationInfo.reqGlEsVersion >= 0x20000\n    || (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1\n    && (Build.FINGERPRINT.startsWith(\"generic\")\n    || Build.FINGERPRINT.startsWith(\"unknown\")\n    || Build.MODEL.contains(\"google_sdk\")\n    || Build.MODEL.contains(\"Emulator\")\n    || Build.MODEL.contains(\"Android SDK build for x86\")))\n```\n\n接下来就是配置渲染表面：\n```java\nif (supportsEs2) {\n    // 配置这个surface视图\n    glSurfaceView.setEGLContextClientVersion(2);\n\n    // 配置Renderer\n    glSurfaceView.setRenderer(FirstOpenGLProjectRenderer());\n    rendererSet = true;\n} else {\n    Toast.makeText(this, \"This device does not support OpenGL ES 2.0\", Toast.LENGTH_SHORT).show();\n    return;\n}\n\nsetContentView(glSurfaceView);\n```\n\n最后我们还得处理下Activity的生命周期，也就是将GLSurfaceView的生命周期跟Activity的生命周期绑定起来：\n```java\n@Override\nvoid onPause() {\n    super.onPause();\n\n    if (rendererSet)\n        glSurfaceView.onPause();\n}\n\n@Override\nvoid onResume() {\n    super.onResume();\n\n    if (rendererSet)\n        glSurfaceView.onResume();\n}\n```\n\n## 编写Renderer\n创建一个新的文件，命名为FirstOpenGLProjectRenderer，让让这个类继承自GLSurfaceView.Renderer。\n\n接着就实现三个必备方法:\n- `onSurfaceCreate()`：创建时被调用\n\n```java\n@Override\npublic void onSurfaceCreated(GL10 glUnsed, EGLConfig config) {\n    glClearColor(1.0f, 0.0f, 0.0f, 0.0f); //设置一个清空屏幕用的颜色\n}\n```\n\n- `onSurfaceChanged()`：创建后每当Surface尺寸改变时，都调用此方法\n\n```java\n@Override\npublic void onSurfaceChanged(GL10 glUnsed, int width, int height) {\n    glViewport(0, 0, width, height); //设置视窗尺寸\n}\n```\n\n- `onDrawFrame()`：绘制每一帧时调用\n\n```java\n@Override\npublic void onDrawFrame(GL10 glUnsed) {\n    glClear(GL_COLOR_BUFFER_BIT); //清空屏幕\n}\n```\n\n然后就可以运行程序了，你就可以看到整个屏幕都成了红色，这是为啥呢？\n因为我们在onSurfaceCreated方法里面设置了glClearColor(1.0f,0.0f,0.0f,0.0f)。这个方法的参数对应的是RGBA，然后我们又在onDrawFrame方法中设置了清屏，所以这样你就会看到的是红色了。","tags":["Android","OpenGL","图像处理"],"categories":["OpenGL"]},{"title":"Flutter入门并开发天气预报APP(8)——天气预报第二步-选择省、市、区界面及网络请求","url":"/posts/f0e3723.html","content":"\n> 项目Github地址：[a1203991686/CoolWeather_Flutter](https://github.com/a1203991686/CoolWeather_Flutter)\n\n在第六章中我们写了天气预报的页面， 但是你作为天气预报肯定能选择城市吧。所以我们现在来写选择省、市、区的界面。\n\n我们使用的是郭霖大神在第一行代码最后面酷欧天气的API。\n\n<!-- More -->\n\n# 1. 实现界面\n既然是一个选择省市区的界面，那么我们就用`ListView`。\n\n首先看一下大致界面：\n![Screenshot_1570967184](http://cdn.littlecorgi.top/mweb/2019-10-14/Screenshot_1570967184.png)\n\n\n就直接使用`ListView`的`builder()`方法，忘了的同学可以看前面第5章。\n\n\n\n## 省\n在`view`文件夹下新建一个类`provinces_page.dart`，接下来就在这个文件里面写代码：\n```java\nclass ProvincesPageWidget extends StatefulWidget {\n    ProvincesPageWidget({Key key}) : super(key: key);\n\n    @override\n    ProvincesPageStateWidget createState() => new ProvincesPageStateWidget();\n}\n\nclass ProvincesPageStateWidget extends State<ProvincesPageWidget> {\n    @override\n    Widget build(BuildContext context) {\n        return Scaffold(\n            appBar: new AppBar(\n                title: Text(\n                    \"省份\",\n                    style: TextStyle(fontSize: 25.0),\n                ),\n            ),\n            body: ListView.builder(\n                itemCount: 30,\n                itemBuilder: (context, index) {\n                    return ListTile(\n                            title: Text(\"$index\"),\n                    );\n                },\n            ),\n        );\n    }\n}\n```\n\n\n## 市\n和省一样。在`view`文件夹下新建一个类`city_page.dart`，接下来就在这个文件里面写代码。照着省的依葫芦画瓢，写一个`ListView`。\n\n## 区\n和省一样。在`view`文件夹下新建一个类`counties_page.dart`，接下来就在这个文件里面写代码。照着省的依葫芦画瓢，写一个`ListView`。\n\n# 2. 网络请求\n网络请求可以看下之前第7章的内容。主要是通过`Dio`进行网络请求。大家可以看下第7章网络请求的内容。\n\n我们网络请求主要需要以下几个API：\n- 请求省份列表：`http://guolin.tech/api/china`\n- 请求对应市列表：`http://guolin.tech/api/china/provinceID`\n- 请求对应区县列表：`http://guolin.tech/api/china/provinceID/cityID`\n\n由于我们在之前文章中使用的省作为例子，这块我们就用区县作为例子：\n\n## 转为Dart类\n首先使用网站[https://caijinglong.github.io/json2dart/](https://caijinglong.github.io/json2dart/)来讲Json数据转为Dart实体类：\n![Json](http://cdn.littlecorgi.top/mweb/2019-10-14/Json.png)\n\n然后在项目`lib`目录新建一个文件夹。名为`bean`。这个文件夹主要存放实体类的代码。然后在这个文件夹下面新建一个dart文件，命名为`Counties`。然后把生成的Dart代码复制粘贴进去。但是你会发现复制进去后会报错，这个不用急，接下来我们来处理错误。\n\n## 生成.g.dart文件\n接下来在项目根目录的`pubspec.yaml`文件的`dependencies`项下面添加依赖`json_annotation`、`dev_dependencies`项下面添加`build_runner`和`json_serializable`。\n\n接着打开终端，定位到项目根目录，输入\n`flutter packages pub run build_runner build`，运行即可。运行完毕你就会发现你项目的存实体类的`lib/bean`目录多了一个文件，名为`Counties.g.dart`。同时你`Counties.dart`里面的错误也没有了。\n\n## 网络请求\n最后你就可以通过Dio来进行网络请求了。\n```java\nDio().get(http://guolin.tech/api/china/$_provinceID/$_cityID);\n```\n\n那么到这有的同学可能就会问了，你网址里面有`provinceID`和`cityID`，那这两个怎么获取，这个时候就得用上带值路由跳转了。\n\n我们一般都是这样的一个逻辑:先选择省份、再选择城市、最后选择区和县。所以我们这个`CountyPageWidget`肯定是由`CityPageWidget`调用的。那么我们可以在`CityPageWidget`的`ListView`里面将`Text`通过`GestureDetector`包起来，然后将`GestureDetector`的`onTap`方法设置为跳转到`CountyPageWidget`。`CityPageWidget`的`ListView`代码如下：\n```java\nListView.builder(\n    itemCount: _cityList.cities.length,\n    itemBuilder: (context, index) {\n        return GestureDetector(\n            child: ListTile(\n                title: Text(\"${_cityList.cities[index].name}\"),\n            ),\n            onTap: () {\n                Navigator.push(context,\n                    MaterialPageRoute(builder: (context) {\n                        return CountiesPageWidget(\n                            provinceID: _provinceID, //由CityWidget的上一级ProvinceWidget传过来，\n                            cityID: _cityList.cities[index].id, // 由网络请求回来的数据传入\n                        );\n                    }));\n            },\n        );\n    },\n);\n```\n\n这样`CountyPageWidget`所需的`provinceID`和`cityID`都是由`CityPageWidget`传入的，那么我们怎么对他传入的值进行处理呢，怎么把它添加到网址里去？接下来大家看代码就行了：\n```java\nclass CountyPageWidget extends StatefulWidget {\n  //在Widget中定义两个，方便由其他Widget传入\n  final int provinceID;\n  final int cityID;\n\n  // 设置构造方法，在构造方法中传入两个变量\n  CountyPageWidget({Key key, this.provinceID, this.cityID}) : super(key: key);\n\n  @override\n  CountyPageWidgetState createState() => CountyPageWidgetState();\n}\n\nclass CountyPageWidgetState extends State<CountyPageWidget> {\n  // 在State中定义两个变量\n  int _provinceID;\n  int _cityID;\n  List<County> _county;\n\n  @override\n  void initState() {\n    // 在此将Widget中的两个变量赋值给State中的变量\n    _provinceID = widget.provinceID;\n    _cityID = widget.cityID;\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: new AppBar(\n        title: Text(\n          \"区县\",\n          style: TextStyle(fontSize: 25.0),\n        ),\n      ),\n      body: FutureBuilder( // UI异步更新组件\n        // 这块就可以调用了\n        future: Dio().get(\"http://guolin.tech/api/china/$_provinceID/$_cityID\"),\n        builder: (BuildContext context, AsyncSnapshot snapshot) {\n        ...省略后面所有代码\n}\n```\n\n# 3. UI异步更新\n与异步更新相关的知识大家也可以看我们之前的第7章博客，这块只讲应用。\n\n## 省\n将Scaffold的body参数设置为FutureBuilder，并在FutureBuilder里面调用ListView:\n```java\nFutureBuilder(\n    future: Dio().get(\"http://guolin.tech/api/china\"),\n    builder: (BuildContext context, AsyncSnapshot snapshot) {\n        if (snapshot.connectionState == ConnectionState.done) {\n            Response response = snapshot.data;\n            //发生错误\n            if (snapshot.hasError) {\n                return Text(snapshot.error.toString());\n            }\n\n            provinceList = getProvinceList(response.data);\n            //请求成功，通过项目信息构建用于显示项目名称的ListView\n            return ListView.builder(\n                itemCount: provinceList.length,\n                itemBuilder: (context, index) {\n                    return GestureDetector(\n                        child: ListTile(\n                            title: Text(\"${provinceList[index].name}\"),\n                        ),\n                        onTap: () {\n                            Navigator.push(context, MaterialPageRoute(builder: (context) {\n                                return CityPageWidget(\n                                    provinceID: provinceList[index].id,\n                                );\n                            }));\n                        },\n                    );\n                },\n            );\n        }\n        // 请求未完成时弹出loading\n        return CircularProgressIndicator();\n    },\n)\n```\n\n\n## 市\n与省同理:\n```java\nFutureBuilder(\n    future: Dio().get(\"http://guolin.tech/api/china/$_provinceID\"),\n    builder: (BuildContext context, AsyncSnapshot snapshot) {\n        if (snapshot.connectionState == ConnectionState.done) {\n            Response response = snapshot.data;\n            //发生错误\n            if (snapshot.hasError) {\n                return Text(snapshot.error.toString());\n            }\n\n            _cityList = getCityList(response.data);\n            //请求成功，通过项目信息构建用于显示项目名称的ListView\n            return ListView.builder(\n                itemCount: _cityList.length,\n                itemBuilder: (context, index) {\n                    return GestureDetector(\n                        child: ListTile(\n                            title: Text(\"${_cityList[index].name}\"),\n                        ),\n                        onTap: () {\n                            Navigator.push(context, MaterialPageRoute(builder: (context) {\n                                return CountiesPageWidget(\n                                    provinceID: _provinceID,\n                                    cityID: _cityList[index].id,\n                                );\n                            }));\n                        },\n                    );\n                },\n            );\n        }\n        // 请求未完成时弹出loading\n        return CircularProgressIndicator();\n    },\n)\n```\n\n\n\n## 区县\n与省同理:\n```java\nFutureBuilder(\n    future: Dio().get(\"http://guolin.tech/api/china/$_provinceID/$_cityID\"),\n    builder: (BuildContext context, AsyncSnapshot snapshot) {\n        if (snapshot.connectionState == ConnectionState.done) {\n            Response response = snapshot.data;\n            //发生错误\n            if (snapshot.hasError) {\n                return Text(snapshot.error.toString());\n            }\n\n            _county = getCountyList(response.data);\n            //请求成功，通过项目信息构建用于显示项目名称的ListView\n            return ListView.builder(\n                itemCount: _county.length,\n                itemBuilder: (context, index) {\n                    return GestureDetector(\n                        child: ListTile(\n                            title: Text(\"${_county[index].name}\"),\n                        ),\n                        onTap: () {\n                            _saveCityID(_county[index].weatherId);\n                            Navigator.push(context, MaterialPageRoute(builder: (context) {\n                                return MainPage(\n                                    cityID: _county[index].weatherId,\n                                );\n                            }));\n                        },\n                    );\n                },\n            );\n        }\n        // 请求未完成时弹出loading\n        return CircularProgressIndicator();\n    },\n)\n```\n","tags":["Android","Flutter"],"categories":["Flutter"]},{"title":"Flutter入门并开发天气预报APP(7)——Http网络请求、Json转Dart实体类及异步更新UI","url":"/posts/163d319c.html","content":"\n> 相关Demo源码可见Github [a1203991686/CoolWeather_Flutter](https://github.com/a1203991686/CoolWeather_Flutter)\n\n<!--More-->\n# Flutter Http 网络请求\nFlutter网络请求可分为两种方式，一种为`Dart:IO`库中为我们提供的`HttpClient`，另一种为Dart第三方库`Dio`。\n\n## HttpClient\n`HttpClient`是`Dart:IO`库自带的一个类，通过他来实现网络请求最底层、也可以完完全全的自定义设置，但是相对于其他人封装好的第三方库来说显得复杂。\n\n### 引入\n导入`Dart:IO`库：\n```java\nimport 'dart:io';\n```\n\n### 创建一个HttpClient:\n```java\n HttpClient httpClient = new HttpClient();\n```\n\n### 创建一个Uri\n如果你是`Http`请求：\n```java\nvar uri = new Uri.http(\n    host,\n    queryParameters: {\n        \"xx\":\"xx\",\n        \"yy\":\"dd\"\n    }\n);\n```\n如果你是`Https`请求：\n```java\nvar uri = new Uri.https(\n    host,\n    queryParameters: {\n        \"xx\":\"xx\",\n        \"yy\":\"dd\"\n    }\n);\n```\n### 根据uri获取返回数据\n```java\nHttpClientRequest request = await httpClient.getUrl(uri);\nHttpClientResponse response = await request.close();\n```\n\n### 读取内容\n进行这一步得导入`dart:convert`库：\n```java\nimport 'dart:convert';\n\n... //省略中间代码 \n\nString responseBody = await response.transform(Utf8Decoder()).join();\n\nprint(respinseBody)\n```\n### 最后关闭Client\n```java\nhttpClient.close();\n```\n\n## Dio\n`Dio`是Dart社区上别人上传的第三方库，他封装了`HttpClient`，相较来说更为简单、方便。\n\n### 引入\n在项目的`pubspec.yaml`文件的`dependencies`中导入`Dio`：\n```java\ndependencies:\n  dio: \n  // 如果冒号后面不带具体版本信息则表示自动下载最新版\n```\n\n接着在需要使用的代码文件里面，`import`导入他：\n```java\nimport 'package:dio/dio.dart';\n```\n接着我们就可以使用`Dio`了。\n\n### 示例\n首先得创建一个`Dio`对象。\n```java\nDio dio =  Dio();\n```\n\n发起`GET`请求：\n```java\nResponse response;\nresponse=await dio.get(uri)\nprint(response.data.toString());\n```\n\n发起`POST`请求：\n```java\nresponse=await dio.post(uri);\n```\n\n# Json转Dart\n##  手动生成Dart实体类\n首先得大家安利一个网站，因为Dart实体类比Java实体类多了几个方法，所以相对来说麻烦，通过这个网站就可以自动生成json数据对应的实体类:\n[https://caijinglong.github.io/json2dart/](https://caijinglong.github.io/json2dart/)\n\n![json2dart](http://cdn.littlecorgi.top/mweb/2019-10-12/json2dart.png)\n\n比方说我们使用这个链接(http://guolin.tech/api/china)，并让他自动转dart：\n![Province](http://cdn.littlecorgi.top/mweb/2019-10-12/Province.png)\n\n接下来只需要创建dart文件，然后再把代码复制进去就行了。\n\n不出意外，代码肯定会报错。\n![dart实体类](http://cdn.littlecorgi.top/mweb/2019-10-12/dart%E5%AE%9E%E4%BD%93%E7%B1%BB.png)\n\n报错信息为:\n```java\nerror: Target of URI hasn't been generated: 'province.g.dart'. (uri_has_not_been_generated at [cool_weather] lib/bean/province.dart:3)\n\nerror: The method '_$ProvinceFromJson' isn't defined for the class 'Province'. (undefined_method at [cool_weather] lib/bean/province.dart:31)\n\nerror: The method '_$ProvinceToJson' isn't defined for the class 'Province'. (undefined_method at [cool_weather] lib/bean/province.dart:33)\n```\n\n这是因为我们项目下还没有`province.g.dart`这个文件，这个文件是根据dart实体类自动生成的，那么我们该怎么生成他呢？\n\n这个时候我们需要在`pubspec.yaml`文件中导入三个依赖包：\n![转dart](http://cdn.littlecorgi.top/mweb/2019-10-12/%E8%BD%ACdart.png)\n我们重点只需要管三个写着需要导入的。输入之后点击`pubspec.yaml`文件右上角的`packages get`，就会自动下载包了。\n\n然后在终端中，转到项目根目录下，输入\n```\nflutter packages pub run build_runner build\n```\n接着你就会惊喜的发现，在你的dart实体类下面多了一个文件，也就是你所缺失的~.g.dart文件，并且实体类中那些报错也都没了。\n![dart.g.dart](http://cdn.littlecorgi.top/mweb/2019-10-12/dart.g.dart.png)\n\n## 将请求回来的Response转为Dart实体类\n\n接着HttpClient返回来的responseBody或者Dio返回的response\n\n```java\nList<Province> provinceList;\nprovinceList = ProvinceList.getProvinceList(jsonResponse);\n```\n\nprovinceList就是返回来的数据转成的实体类的对象了。\n\n# 异步更新UI\n在此处介绍两种方法，第一种是我自己想出来的沙雕方法，第二种是通过Flutter提供的专门用于异步更新UI的组件FutureBuilder。\n## 沙雕方法\n在此说一下我这个方法的想法。\n\n大家可以回顾下我之前讲Widget的时候说过，Widget有一个方法initState可以用来加载UI，以及一个setState方法可用来提醒Flutter重新加载UI。\n\n说到这很多同学一定想到了，我们可以在获取到数据之后通过setState方法来更新UI。\n\n### 获取到数据\n这个不同多说，上面讲的全都是获取数据。\n\n### 设置一个空的实体类\n此处我还是拿上面的Province.dart来做例子。我们正常情况下获取到的数据转成的实体类的对象是`List<Province> provinceList`。所以我们此处先设置一个空的对象:`List<Province> _provinceList`。\n\n接着在initState里面调用网络请求的方法：\n```java\n@override\nvoid initState() {\n    getProvince();\n    super.initState();\n}\n```\n\n然后在getProvince方法里面获取数据，并将数据provinceList传给_provinceList：\n\n```java\nvoid getProvince() async {\n    var response = await Dio().get(\"http://guolin.tech/api/china\");\n    provinceList = ProvinceList.getProvinceList(response);\n    setState(() {\n        _provinces = provinceList;\n    });\n}\n```\n\n这样就可以当获取到数据的时候就通知Flutter更新状态了。这个时候有的同学可能会问我，你这个也只是获取到数据的时候才更新啊，那当还没获取到数据的时候呢？\n\n这块就体现到了为什么我们要设置一个_provinces了。\n\n我们完全可以在build方法设置下，判断下_provinces为不为空:如果为空，就证明没数据，就加载其它页面；如果不为空，就证明有数据了，那就加载数据。\n```java\nbody: _provinces == null\n          ? new Text(\"正在请求\")\n          : new ListView.builder(\n          ... //省去代码，总的来说就是将_provinces的数据加载ListView里面，一个ListView的基本构造方法\n          )\n```\n\n## FutureBuilder\n回归正题，我上面那个方法真的是有够沙雕的。\n\n那我们来看看这个名正言顺的Flutter亲生儿子FutureBuilder。\n\n首先我们看下定义：\n```java\nFutureBuilder({\n  this.future,\n  this.initialData,\n  @required this.builder,\n})\n```\n- future：异步任务；\n- initialData：初始化数据；\n- builder：builder方法。\n\n### 示例\n```java\nbody: FutureBuilder(\n    future: Dio().get(\"http://guolin.tech/api/china\"),\n    builder: (BuildContext context, AsyncSnapshot snapshot) {\n        if (snapshot.connectionState == ConnectionState.done) {\n            Response response = snapshot.data;\n            print(response.toString());\n            //发生错误\n            if (snapshot.hasError) {\n                return Text(snapshot.error.toString());\n            }\n\n            provinceList = ProvinceList.fromJson(response.data);\n            //请求成功，通过项目信息构建用于显示项目名称的ListView\n            return ListView.builder(\n                itemCount: provinceList.provinces.length,\n                itemBuilder: (context, index) {\n                    return GestureDetector(\n                        child: ListTile(\n                            title: Text(\"${provinceList.provinces[index].name}\"),\n                        ),\n                        onTap: () {\n                            Navigator.push(context,\n                                MaterialPageRoute(builder: (context) {\n                                    return CityPageWidget(\n                                        cityID: provinceList.provinces[index].id);\n                                }));\n                        },\n                    );\n                },\n            );\n        }\n        // 请求未完成时弹出loading\n        return CircularProgressIndicator();\n    },\n)\n```","tags":["Android","Flutter"],"categories":["Flutter"]},{"title":"Flutter入门并开发天气预报APP(6)——天气预报第一步-界面","url":"/posts/15395a84.html","content":"\n经过前面的对于Flutter的介绍，我们现在已经可以开始写我们的天气预报APP的界面了。\n\n\n项目Github地址：[a1203991686/CoolWeather_Flutter](https://github.com/a1203991686/CoolWeather_Flutter)\n\n<!--More-->\n# 1. 大致界面\n最终写成的大致界面如图：\n\n<img src=\"http://cdn.littlecorgi.top/mweb/2019-10-11/Screenshot_1570712111.png\" width = 50% />\n\n我们可以把这个界面拆分成如下部分：\n\n<img src=\"http://cdn.littlecorgi.top/mweb/2019-10-11/Screenshot_1570711214.png\" width = 50% />\n\n可以看到我们APP主要有最上面用来显示地点和刷新时间的`Title`、显示温度和天气的两个`Text`、显示3天预报的`ListView`、显示空气质量的`GridView`、以及最后显示生活建议的`ListView`。\n\n此处会用到我们前面学过的所有知识，如果有同学没有看过前面内容的，可以看下本系列前面的文章。\n\n# 2. 创建项目\n首先我们创建一个新的Flutter项目：\n1. 在AndroidStudio点击`File`->`New Flutter Project`；\n2. 接着选择`Flutter Application`->`NEXT`。接着填写你的项目名称等一系列信息后点击`next`； ![New Flutter Project](http://cdn.littlecorgi.top/mweb/2019-10-11/New%20Flutter%20Project.png)\n3. 接着输入你的组织/公司名称作为包名，最后点击`Finish`即可，这样就新建了一个Flutter项目，并且Flutter会自动为你生成一个计数器Demo；\n    ![package ne](http://cdn.littlecorgi.top/mweb/2019-10-11/package%20new.png)\n4. 让我们把`mian.dart`里面的所有注释以及`_MyHomePageState`里面的`build`方法里面的代码都删掉；\n5. 接着在`lib`文件夹下新建一个文件夹，名叫`view`，到时候我们把所有与界面有关的代码文件都放在这个文件夹下面；\n6. 然后我们在`view`文件夹下面新建一个dart文件，命名为`main_page`。这个就是我们的天气详情页。\n\n \n# 3. 设计好天气详情页框架\n首先我们需要导入`material`包，我们项目主要用material风格UI来写。\n\n在开头输入`import 'package:flutter/material.dart';`，这样就导入了`material`包。接着创建我们的界面类`MainPage`。\n\n由于我们在到时候写好网络请求后，所有的数据都得从网络获取，并且使用了异步的方法，也就是说我们先把页面加载了然后等获取的数据回来了在通知Flutter更新状态，所以这块我们得使用`StatefulWidget`。\n```java\nclass MainPage extends StatefulWidget {\n  MainPage({Key key}) : super(key: key);\n\n  @override\n  MainPageState createState() => new MainPageState();\n}\n\nclass MainPageState extends State<MainPage> {\n  @override\n  Widget build(BuildContext context) {\n  \n  }\n}\n```\n\n接着我们就得开始写`build()`里面的内容了。由于我们需要一个全屏的背景图片，所以我们就使用`Container`作为我们最外层的Widget，并使用`BoxDecoration`装饰容器配合`DecorationImage`来放置图片：\n```java\n@override\nWidget build(BuildContext context) {\n  return Container(\n    decoration: BoxDecoration(\n      image: DecorationImage(\n        image: NetworkImage(\"http://blog.mrabit.com/bing/today\"), //必应每日一图背景\n        fit: BoxFit.cover, // 设置为全屏\n      ),\n    ),\n    child: _weatherBody(),\n  );\n}\n```\n\n这个时候我们的运行结果如图(①你背景图片多半和我不一样，因为上面那个Uri获取的是必应的每日一图，每天图片都不一样；②运行的时候记得把`child: _weatherBody(),`给注释掉，因为我们还没有定义`_weatherBody()`这个方法):\n\n<img src=\"http://cdn.littlecorgi.top/mweb/2019-10-11/Screenshot_1570797585.png\" width = 50% />\n\n\n# 4. 设计title\n为了方便我就直接把剩下的布局单领出来放到`_weatherBody()`这个方法:\n```java\nWidget _weatherBody() {\n  return\n}\n```\n由于我们需要实现一个有Title的页面，所以最外层我选用了Scaffold：\n```java\nWidget _weatherBody() {\n  return Scaffold(\n    backgroundColor: Colors.transparent, //背景透明\n    appBar: AppBar(\n      centerTitle: true,\n      title: Text(\n        \"北京\",\n        style: TextStyle(fontSize: 25.0),\n      ),\n      backgroundColor: Colors.transparent, //背景透明\n      actions: <Widget>[ //右侧Widget，相当于Android Toolbar中的menu\n        Container(\n          alignment: Alignment.center, //向中间对齐\n          child: Text(\n            \"12:10\",\n            textAlign: TextAlign.center, //文字向中间对齐\n          ),\n        )\n      ],\n    ),\n    body: SingleChildScrollView( // 由于到时候整个页面一个屏幕可能放不下，就放置了一个滚动布局\n    \n    ),\n  );\n}\n```\n\n这个时候的运行结果是：\n\n<img src=\"http://cdn.littlecorgi.top/mweb/2019-10-11/Screenshot_1570797746.png\" width = 50% />\n\n\n# 5. 设计下面天气预报页面\n接下来可以开始下下面的天气显示页面了。\n## 当前温度和天气情况\n首先写一个纵向线性布局`Column`:\n```java\nbody: SingleChildScrollView(\n  child: Column(\n    children: <Widget>[\n      \n    ]\n  )\n),\n```\n由于我们要显示在屏幕最右边，所以使用Align:\n```java\nbody: SingleChildScrollView(\n  child: Column(\n    children: <Widget>[\n      Align(\n        alignment: Alignment.centerRight,\n        child:Text(\n          \"26°C\",\n          style: TextStyle(\n            fontSize: 50.0,\n            color: Colors.white,\n          ),\n        ),\n      ),\n      Align(\n        alignment: Alignment.centerRight,\n        child:Text(\n          \"阴\",\n          style: TextStyle(\n            fontSize: 20.0,\n            color: Colors.white,\n          ),\n        ),\n      ),\n    ]\n  )\n),\n```\n\n运行结果是：\n\n<img src=\"http://cdn.littlecorgi.top/mweb/2019-10-11/Screenshot_1570797847.png\" width = 50% />\n\n\n接下来我们需要显示3天天气预报、天气质量以及生活建议的三个子控件，同样为了方便我们也把他们给单领出来，于是上面的Column接下来可以这样写：\n```java\nbody: SingleChildScrollView(\n  child: Column(\n    children: <Widget>[\n      ... //上面的两个Text\n      Padding(\n        padding: EdgeInsets.only(\n          left: 15.0,\n          right: 15.0,\n          bottom: 15.0,\n        ),\n        child: Container(\n          color: Colors.black54,\n          child: _weatherList(), //3天天气预报\n        ),\n      ),\n      Padding(\n        padding: EdgeInsets.only(\n          left: 15.0,\n          right: 15.0,\n        ),\n        child: Container(\n          color: Colors.black54,\n          child: _atmosphereList(), //空气质量\n        ),\n      ),\n      Padding(\n        padding: EdgeInsets.only(\n          top: 15.0,\n          left: 15.0,\n          right: 15.0,\n          bottom: 15.0,\n        ),\n        child: Container(\n          color: Colors.black54,\n          child: _lifestyleList(), //生活建议\n        ),\n      ),\n    ]\n  )\n),\n```\n\n## 3天天气预报\n对于3天天气预报我们主要通过ListView来实现，由于到时候数据比较灵活，所以我们就直接使用ListView.Builder来实现：\n```java\nList<String> dates = [\"2019/10/01\", \"2019/10/02\", \"2019/10/03\"];\nList<String> temperatures = [\"29/14\", \"30/18\", \"29/18\"];\nList<String> texts = [\"阴\", \"晴\", \"雨\"];\n\nWidget _weatherList() {\n    return Column(\n        children: <Widget>[\n            Align(\n                alignment: Alignment.centerLeft,\n                child: Text(\n                    \"预报\",\n                    style: TextStyle(\n                        color: Colors.white,\n                        fontSize: 20.0,\n                    ),\n                ),\n            ),\n            ListView.builder(\n                shrinkWrap: true, //这个是指根据ListView所有子Widget的长度来设定ListView的长度\n                physics: NeverScrollableScrollPhysics(), //禁止ListView自己的滑动，因为我们在外面用了个SingleChildScrollView，我们通过他的滑动就可以了\n                itemCount: dates.length, //ListView子项个数\n                itemBuilder: (BuildContext context, int index) {\n                    return ListTile(\n                        title: Row(\n                            mainAxisAlignment: MainAxisAlignment.spaceBetween, //这个是Row的主轴的子项的分布格式，spaceBetween是指平均分布\n                            mainAxisSize: MainAxisSize.max,\n                            children: <Widget>[\n                                Text(\n                                    \"${dates[index]}\",\n                                    style: TextStyle(color: Colors.white),\n                                ),\n                                Text(\n                                    \"${temperatures[index]}\",\n                                    style: TextStyle(color: Colors.white),\n                                ),\n                                Text(\n                                    \"${texts[index]}\",\n                                    style: TextStyle(color: Colors.white),\n                                ),\n                            ],\n                        ),\n                    );\n                }),\n        ],\n    );\n}\n```\n\n这个时候运行结果是：\n\n<img src=\"http://cdn.littlecorgi.top/mweb/2019-10-11/Screenshot_1570798505.png\" width = 50% />\n\n\n## 空气质量\n这块我们需要用到GridView，由于只有两个显示内容，而且我们后期也没有需要动态添加的需求，所以我们就直接使用GridView构造方法，而不去使用GridView的builder方法：\n```java\nList<String> atmospheres = [\"16\", \"56\"];\n\nWidget _atmosphereList() {\n    return Column(\n        children: <Widget>[\n            Align(\n                alignment: Alignment.centerLeft,\n                child: Text(\n                    \"空气质量\",\n                    style: TextStyle(\n                        color: Colors.white,\n                            fontSize: 20.0,\n                    ),\n                ),\n            ),\n            GridView(\n                shrinkWrap: true, //见上面3天天气预报的ListView处\n                physics: NeverScrollableScrollPhysics(), //见上面3天天气预报的ListView处\n                gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(\n                    crossAxisCount: 2, //横轴三个子widget\n                    childAspectRatio: 2 //显示区域宽高相等\n                ),\n                children: <Widget>[\n                    Column(\n                        children: <Widget>[\n                            Text(\n                                \"${atmospheres[0]}\",\n                                style: TextStyle(\n                                    color: Colors.white,\n                                    fontSize: 40.0,\n                                ),\n                            ),\n                            Text(\n                                \"能见度\",\n                                style: TextStyle(\n                                    color: Colors.white,\n                                    fontSize: 20.0,\n                                ),\n                            ),\n                        ],\n                    ),\n                    Column(\n                        children: <Widget>[\n                            Text(\n                                \"${atmospheres[1]}\",\n                                style: TextStyle(\n                                    color: Colors.white,\n                                    fontSize: 40.0,\n                                ),\n                            ),\n                            Text(\n                                \"湿度\",\n                                style: TextStyle(\n                                    color: Colors.white,\n                                    fontSize: 20.0,\n                                ),\n                            ),\n                        ],\n                    ),\n                ],\n            ),\n        ],\n    );\n}\n```\n\n运行后的效果是：\n\n<img src=\"http://cdn.littlecorgi.top/mweb/2019-10-11/Screenshot_1570799107.png\" width = 50% />\n\n## 生活建议\n这块和3天天气预报一样，而且数据比3天天气预报更多，所以他更适合用ListView.builder：\n```java\nList<String> _lifestyleWeatherBrf = [\n    \"较舒适\",\n    \"较舒适\",\n    \"适宜\",\n    \"适宜\",\n    \"弱\",\n    \"较适宜\",\n    \"中\"\n];\nList<String> _lifestyleWeatherTxt = [\n    \"白天天气晴好，早晚会感觉偏凉，午后舒适、宜人。\",\n    \"建议着薄外套、开衫牛仔衫裤等服装。年老体弱者应适当添加衣物，宜着夹克衫、薄毛衣等。\",\n    \"各项气象条件适宜，无明显降温过程，发生感冒机率较低。\",\n    \"天气较好，赶快投身大自然参与户外运动，尽情感受运动的快乐吧。\",\n    \"天气较好，但丝毫不会影响您出行的心情。温度适宜又有微风相伴，适宜旅游。\",\n    \"紫外线强度较弱，建议出门前涂擦SPF在12-15之间、PA+的防晒护肤品。\",\n    \"较适宜洗车，未来一天无雨，风力较小，擦洗一新的汽车至少能保持一天。\",\n    \",气象条件对空气污染物稀释、扩散和清除无明显影响，易感人群应适当减少室外活动时间。\"\n];\n\nWidget _lifestyleList() {\n    return Column(\n        children: <Widget>[\n            Align(\n                alignment: Alignment.centerLeft,\n                child: Text(\n                    \"生活建议\",\n                    style: TextStyle(\n                        color: Colors.white,\n                        fontSize: 20.0,\n                    ),\n                ),\n            ),\n            ListView.builder(\n                shrinkWrap: true,\n                physics: NeverScrollableScrollPhysics(),\n                itemCount: _lifestyleWeatherBrf.length,\n                itemBuilder: (BuildContext context, int index) {\n                    return ListTile(\n                        title: Column(\n                            mainAxisAlignment: MainAxisAlignment.start,\n                            crossAxisAlignment: CrossAxisAlignment.start,\n                            children: <Widget>[\n                                Text(\n                                    \"${_lifestyleWeatherBrf[index]}\",\n                                    style: TextStyle(\n                                        color: Colors.white,\n                                    ),\n                                ),\n                                Text(\n                                    \"${_lifestyleWeatherTxt[index]}\",\n                                    style: TextStyle(\n                                        color: Colors.white,\n                                    ),\n                                ),\n                            ],\n                        ),\n                    );\n                },\n            ),\n        ],\n    );\n}\n```\n\n运行结果是:\n\n<img src=\"http://cdn.littlecorgi.top/mweb/2019-10-11/Screenshot_1570799686.png\" width = 50% />\n","tags":["Android","Flutter"],"categories":["Flutter"]},{"title":"Flutter入门并开发天气预报APP(5)——SingleChildScrollView、ListView和GridView","url":"/posts/30ff421d.html","content":"下面我们来介绍下Flutter中的滑动控件`SingleChildScrollView`、列表`ListView`和表格`GridView`。\n<!--More-->\n# SingleChildScrollView\n`SingleChildScrollView`类似于Android中的`ScrollView`，我使用的较浅，在我目前看来，他和`ScrollView`的唯一区别就是它还可以横向滚动。\n\n我们先来看下他的定义：\n```java\nSingleChildScrollView({\n  this.scrollDirection = Axis.vertical, //滚动方向，默认是垂直方向\n  this.reverse = false, \n  this.padding, \n  bool primary, \n  this.physics, \n  this.controller,\n  this.child,\n})\n```\n\n- `scrollDirection`：设定滚动的方向，可以设定`Axis.vertical`或者`Axis.horizon`；\n- `reverse`：是否按照阅读方向的反方向滑动，emmm这个可能有点觉得莫名其妙，但是如阿拉伯语言地区，他们阅读和我国古时候一样是从右向左的，所以如果`reverse`为`true`，且滚动方向是水平滚动的话，如果系统时阿拉伯语等从右向左阅读的语言时，方向是从右向左的；\n- `padding`：留白的大小，和`Padding`的用法一样，通过`EdgeInsets`来设定，具体可以看前几章将Flutter基础Widget；\n- `primary`：指是否使用widget树中默认的`PrimaryScrollController`；当滑动方向为垂直方向（`scrollDirection`值为`Axis.vertical`）并且没有指定`controller`时，`primary`默认为`true`；\n- `physics`：用于控制滚动方式，这个等会重点讲解；\n- `controller`：用于滚动监听及控制；\n- `child`：子Widget。\n\n## physics\n这个参数是用于控制滚动方式，有几种参数：\n- `NeverScrollablePhysics`：呈现不可滚动状态；\n- `BouncingScrollPhysics`：当列表滑动结束时，会回弹列表，类似于iOS的列表滑动效果；\n ![BouncingScrollPhysics](http://cdn.littlecorgi.top/mweb/2019-10-10/BouncingScrollPhysics.gif)\n\n- `ClampingScrollPhysics`：滑动结束时会显示水波纹阴影，类似于Android的列表滑动效果；\n ![ClampingScrollPhysics](http://cdn.littlecorgi.top/mweb/2019-10-10/ClampingScrollPhysics.gif)\n\n- `FixedExtentScrollPhysics`：可以自己制作滑动效果，但是我也不会，所以在此不做解释😝。\n\n# ListView\n`ListView`可以沿一个方向上线性排布所有子组件（不仅局限于竖直方向）。\n\n让我们来看下他的定义：\n```java\nListView({\n  ...  \n  //可滚动widget公共参数\n  Axis scrollDirection = Axis.vertical,\n  bool reverse = false,\n  ScrollController controller,\n  bool primary,\n  ScrollPhysics physics,\n  EdgeInsetsGeometry padding,\n\n  //ListView各个构造函数的共同参数  \n  double itemExtent,\n  bool shrinkWrap = false,\n  bool addAutomaticKeepAlives = true,\n  bool addRepaintBoundaries = true,\n  double cacheExtent,\n\n  //子widget列表\n  List<Widget> children = const <Widget>[],\n})\n```\n公共属性我们就不讲了，上面`SingleChildScrollView`已经讲过了，我们现在只讲他特有的：\n- `itemExtent`：用于控制`ListView`的长度，如果不为`null`，则强制所有子Widget合起来的长度小于设定的值：如果`ListView`是横向的，则所有子Widget横向长度的和小于它；如果`ListView`是纵向的，则所有子Widget纵向长度的和小于它；\n- `shrinkWrap`：该属性表示是否根据子组件的总长度来设置`ListView`的长度，默认值为`false` 。默认情况下，`ListView`的会在滚动方向尽可能多的占用空间。当`ListView`在一个无边界(滚动方向上)的容器中时，`shrinkWrap`必须为`true`；\n- `addAutomaticKeepAlives`：该属性表示是否将列表项（子组件）包裹在`AutomaticKeepAlive`组件中；典型地，在一个懒加载列表中，如果将列表项包裹在`AutomaticKeepAlive`中，在该列表项滑出视口时它也不会被`GC（垃圾回收）`，它会使用`KeepAliveNotification`来保存其状态。如果列表项自己维护其`KeepAlive`状态，那么此参数必须置为`false`；\n- `addRepaintBoundaries`：该属性表示是否将列表项（子组件）包裹在`RepaintBoundary`组件中。当可滚动组件滚动时，将列表项包裹在`RepaintBoundary`中可以避免列表项重绘，但是当列表项重绘的开销非常小（如一个颜色块，或者一个较短的文本）时，不添加`RepaintBoundary`反而会更高效。和`addAutomaticKeepAlive`一样，如果列表项自己维护其`KeepAlive`状态，那么此参数必须置为`false`；\n- `cacheExtent`：设定缓存大小。\n\n默认情况下一个一个设定`children`很麻烦，所以为了方便，Flutter还提供了一个`builder`构造方法：\n\n## ListView.builder\n```java\nListView.builder({\n  // ListView公共参数已省略  \n  ...\n  @required IndexedWidgetBuilder itemBuilder,\n  int itemCount,\n  ...\n})\n```\n- `itemCount`：是需要加载子Widget的长度；\n- `itemBuilder`：列表项的构造器，当列表滚动到具体的`index`位置时，会调用该构建器构建列表项。\n\n看例子：\n```java\nListView.builder(\n  itemCount: _provinces.length,\n  itemBuilder: (context, index) {\n    return GestureDetector(\n      child: ListTile(\n        title: Text(\"$index\"),\n      ),\n      onTap: () {}));\n      },\n    );\n  },\n)\n```\n![ListViewBUilde](http://cdn.littlecorgi.top/mweb/2019-10-10/ListViewBUilder.png)\n\n\n## ListView.separated\n用于添加分割线。相较于`ListView.builder`多了一个`separatorBuilder`参数，该参数是一个分割组件生成器。\n\n下面我们看一个例子：奇数行添加一条蓝色下划线，偶数行添加一条绿色下划线。\n```java\nclass ListView3 extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    //下划线widget预定义以供复用。  \n    Widget divider1=Divider(color: Colors.blue,);\n    Widget divider2=Divider(color: Colors.green);\n    return ListView.separated(\n        itemCount: 100,\n        //列表项构造器\n        itemBuilder: (BuildContext context, int index) {\n          return ListTile(title: Text(\"$index\"));\n        },\n        //分割器构造器\n        separatorBuilder: (BuildContext context, int index) {\n          return index%2==0?divider1:divider2;\n        },\n    );\n  }\n}\n```\n![-w160](https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action/docs/imgs/6-3.png)\n\n# GridView\n`GridView`可以构造一个网格列表，定义如下:\n```java\nGridView({\n  Axis scrollDirection = Axis.vertical,\n  bool reverse = false,\n  ScrollController controller,\n  bool primary,\n  ScrollPhysics physics,\n  bool shrinkWrap = false,\n  EdgeInsetsGeometry padding,\n  @required SliverGridDelegate gridDelegate, //控制子widget layout的委托\n  bool addAutomaticKeepAlives = true,\n  bool addRepaintBoundaries = true,\n  double cacheExtent,\n  List<Widget> children = const <Widget>[],\n})\n```\n大部分参数和`ListView`都相同，我们只关注`gridDelegate`这个参数：\n`gridDelegate`作用是控制`GridView`子组件如何排列，Flutter中提供了两个类`SliverGridDelegateWithFixedCrossAxisCount`和`SliverGridDelegateWithMaxCrossAxisExtent`，我们可以直接使用，下面我们分别来介绍一下它们。\n\n## SliverGridDelegateWithFixedCrossAxisCount\n该子类实现了一个横轴为固定数量子元素的layout算法，其构造函数为：\n```java\nSliverGridDelegateWithFixedCrossAxisCount({\n  @required double crossAxisCount, \n  double mainAxisSpacing = 0.0,\n  double crossAxisSpacing = 0.0,\n  double childAspectRatio = 1.0,\n})\n```\n- `crossAxisCount`：横轴子元素的数量。此属性值确定后子元素在横轴的长度就确定了，即`ViewPort`横轴长度除以`crossAxisCount`的商。\n- `mainAxisSpacing`：主轴方向的间距。\n- `crossAxisSpacing`：横轴方向子元素的间距。\n- `childAspectRatio`：子元素在横轴长度和主轴长度的比例。由于`crossAxisCount`指定后，子元素横轴长度就确定了，然后通过此参数值就可以确定子元素在主轴的长度。\n\n## SliverGridDelegateWithMaxCrossAxisExtent\n该子类实现了一个横轴子元素为固定最大长度的layout算法，其构造函数为：\n```java\nSliverGridDelegateWithMaxCrossAxisExtent({\n  double maxCrossAxisExtent,\n  double mainAxisSpacing = 0.0,\n  double crossAxisSpacing = 0.0,\n  double childAspectRatio = 1.0,\n})\n```\n`maxCrossAxisExtent`为子元素在横轴上的最大长度，之所以是“最大”长度，是因为横轴方向每个子元素的长度仍然是等分的。其它参数和`SliverGridDelegateWithFixedCrossAxisCount`相同。\n\n## GridView.builder\n和`ListView`一样，当子Widget数量较多时，也提供了`builder`方法:\n```java\nGridView.builder(\n ...\n @required SliverGridDelegate gridDelegate, \n @required IndexedWidgetBuilder itemBuilder,\n)\n```\n\n这个就不在这举例了，`gridDelegate`和前面一样的，`itemBuilder`和`ListView`的一样的。","tags":["Android","Flutter"],"categories":["Flutter"]},{"title":"Flutter入门并开发天气预报APP(4)——基础Widget","url":"/posts/a3b37eac.html","content":"到这章我们就差不多可以开始写天气预报了。首先我们来看一下一些基础简单的Widget。\n\n<!--More-->\n\n# 基础组件\n## 文本\n`Text`用于显示简单的文本，包含一些控制文本显示的属性。\n```java\nText(\n    \"1234\",\n),\nText(\n    \"1234\",\n    style: TextStyle(\n        color: Colors.purple,\n        fontSize: 32.0,\n        fontWeight: FontWeight.bold,\n    ),\n),\n```\n![Text示例](http://cdn.littlecorgi.top/mweb/2019-10-10/Text%E7%A4%BA%E4%BE%8B.png)\n\n- 需要显示的文本信息直接放到一个双引号里面就可以了；\n- `textAlign`：文本对齐方式；\n- `maxLines`：文本显示的最大行数；\n- `overflow`：指定多余文本的截断方式；\n- `textScaleFactor`：指定文本相对于当前字体大小的缩放因子；\n- `TextStyle`：设置显示文本的字体、颜色、粗细等样式：\n    - `height`：指定行高，但是不是绝对值，而是一个因子，相当于`fontsize * height`；\n    - `fontFamily`：设置字体；\n    - `fontSize`：设置字体大小\n\n## 按钮\n不同的组件库有不同的按钮，我们现在只拿Material组件库中的按钮举例。\n\n### RaisedButton\n漂浮按钮，带有阴影和灰色背景。按下后阴影会变大。\n```java\nRaisedButton(\n  child: Text(\"1234\"),\n  onPressed: () {},\n);\n```\n<figure class=\"half\">\n    <img src=\"http://cdn.littlecorgi.top/mweb/2019-10-10/RaisedButton%E6%9C%AA%E6%8C%89%E4%B8%8B.png\">\n    <img src=\"http://cdn.littlecorgi.top/mweb/2019-10-10/RaisedButton%E6%8C%89%E4%B8%8B.png\">\n</figure>\n\n### FlatButton\n扁平化按钮，背景透明且不带阴影，按下后会有背景色。\n```java\nFlatButton(\n  child: Text(\"1234\"),\n  onPressed: () {},\n)\n```\n<figure class=\"half\">\n    <img src=\"http://cdn.littlecorgi.top/mweb/2019-10-10/FlatButton%E6%9C%AA%E6%8C%89%E4%B8%8B.png\">\n    <img src=\"http://cdn.littlecorgi.top/mweb/2019-10-10/FlatButton%E6%8C%89%E4%B8%8B.png\">\n</figure>\n\n### IconButton\n可点击的Icon，默认没有背景，按下后出现阴影\n```java\nIconButton(\n  icon: Icon(Icons.thumb_up),\n  onPressed: () {},\n)\n```\n![-w88](http://cdn.littlecorgi.top/mweb/2019-10-10/15706115387455.png)\n\n## 图片\n我们通过`Image`来显示图片，来源可以是`asset`、网络等位置。\n\n### 从asset加载图片\n1. 现在项目根目录(也就是和android、ios、lib等目录同级)新建一个`images`目录，并把图片`main.png`拷进去；\n2. 在`pubspec.yaml`中的flutter部分添加一下内容：\n    ![assets](http://cdn.littlecorgi.top/mweb/2019-10-10/assets.png)\n3. 加载该图片\n\n```java\nImage(\n  image: AssetImage(\"images/amoled.png\"),\n);\n```\n\n`Image`也提供了一个快速构造函数：\n```java\nImage.asset(\n  \"images/amoled.png\",\n)\n```\n\n### 从网络加载图片\n```java\nImage(\n  image: NetworkImage(\n      \"https://s2.ax1x.com/2019/05/27/VZrQ3V.png\"),\n)\n```\n或者\n```java\nImage.network(\n  \"https://s2.ax1x.com/2019/05/27/VZrQ3V.png\",\n)\n```\n\n### 参数\n`Image`有一些基本参数\n```java\nconst Image({\n  ...\n  this.width, //图片的宽\n  this.height, //图片高度\n  this.fit,//缩放模式\n  this.alignment = Alignment.center, //对齐方式\n  this.repeat = ImageRepeat.noRepeat, //重复方式\n  ...\n})\n```\n\n- `width`和`height`：宽和高；\n- `fit`：缩放模式：\n    - `fill`：拉伸图片知道填满；\n    - `cover`：按原图长宽比放大图片来填满，多余的部分舍去；\n    - `contain`：在保证图片长宽比不变的情况下尽可能去填满；\n    - `fitWidth`：宽度会缩放到显示空间的宽度，高度会按比例缩放，如果有多余的部分会被舍去；\n    - `fitHeight`：与`fitWidth`同理；\n    - `none`：没有适应策略，图片多大就显示多大，如果图片原尺寸小于显示空间就只显示原尺寸；如果大于则舍弃多余部分只显示中间部分；\n- `repeat`：当图片小于显示空间时，会将图片重复显示。\n\n# 布局组件\n## 线性布局(Row、Column)\n线性布局就相当于Android里面的`LinearLayout`，但是不同的是Flutter将竖直和水平布局单独拿了出来。\n\n线性布局分为竖直布局`Column`和水平布局`Row`。他两属性都是一样的。\n再说属性之前我们先熟悉两个概念：主轴和交叉轴。如果是`Column`，主轴是竖直轴，交叉轴是水平轴；如果是`Row`，主轴是水平轴，交叉轴是竖直轴。\n```java\nRow({\n  ...  \n  MainAxisSize mainAxisSize = MainAxisSize.max,    \n  MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,\n  CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,\n  List<Widget> children = const <Widget>[],\n})\n```\n\n- `mainAxisSize`：主轴占用空间。默认是`MainAxisSize.max`，是指占用全部主轴空间。如果设置为`MainAxisSize.min`，那就只占用所有子组件所需要的空间；\n- `mainAxisAlignment`：子Widget在主轴的对其方向；\n- `crossAxisAlignment`：子Widget在交叉轴的对其方向；\n- `children`：所有的子Widget。\n\n## 弹性布局(Flex)\n其实这个布局和线性布局很有渊源，为什么这么说呢，因为`Row`和`Column`都继承自它。\n因此关于他和线性布局重复的地方我们现在就不再讲了，我们直说他“弹性”的部分。\n\n### Expanded\n可以按比例“拉伸”`Row`、`Column`和`Flex`子组件所占的空间。\n\n```java\nconst Expanded({\n  int flex = 1, \n  @required Widget child,\n})\n```\n`flex`为弹性系数，如果为`0`或者`null`，则`child`不会阔伸占用的控件。如果大于`0`，则会按照`flex`的比例来分隔主轴全部空闲空间。其实说白了，就和Android里面`LinearLayout`的`weight`一样的。但是我们还是来举个例子吧。\n\n```java\nreturn Scaffold(\n      appBar: new AppBar(\n        title: Text(\"$_title\"),\n      ),\n      body: Center(\n        child: Flex(\n          children: <Widget>[\n            Flex(\n              direction: Axis.horizontal,\n              children: <Widget>[\n                Expanded(\n                  flex: 1,\n                  child: Container(\n                    color: Colors.blue,\n                    child: Text(\"1234\"),\n                  ),\n                ),\n                Expanded(\n                  flex: 2,\n                  child: Container(\n                    color: Colors.red,\n                    child: Text(\"1234\"),\n                  ),\n                ),\n              ],\n            ),\n            Flex(\n              direction: Axis.horizontal,\n              children: <Widget>[\n                Expanded(\n                  flex: 3,\n                  child: Container(\n                    color: Colors.blue,\n                    child: Text(\"1234\"),\n                  ),\n                ),\n                Expanded(\n                  flex: 1,\n                  child: Container(\n                    color: Colors.red,\n                    child: Text(\"1234\"),\n                  ),\n                ),\n              ],\n            ),\n            Flex(\n              direction: Axis.horizontal,\n              children: <Widget>[\n                Expanded(\n                  flex: 1,\n                  child: Container(\n                    color: Colors.blue,\n                    child: Text(\"1234\"),\n                  ),\n                ),\n                Expanded(\n                  flex: 1,\n                  child: Container(\n                    color: Colors.red,\n                    child: Text(\"1234\"),\n                  ),\n                ),\n              ],\n            ),\n          ],\n          direction: Axis.vertical,\n        ),\n      ),\n);\n```\n![Flex示例](http://cdn.littlecorgi.top/mweb/2019-10-10/Flex%E7%A4%BA%E4%BE%8B.png)\n\n## 流式布局(Wrap、Flow)\n如果使用线性布局的话，当需要显示的内容超出屏幕边界的时候就会报错。\n![超出屏幕边界](http://cdn.littlecorgi.top/mweb/2019-10-10/%E8%B6%85%E5%87%BA%E5%B1%8F%E5%B9%95%E8%BE%B9%E7%95%8C.png)\n\n为了避免这种情况，我们就可以使用流式布局。当需要显示的内容超出屏幕边界的时候，就自动折行来继续显示。\n\nFlutter中通过`Wrap`和`Flow`来实现流式布局。\n\n### Wrap\n我们来看下`Wrap`主要的一些参数：\n```java\nWrap({\n  ...\n  this.direction = Axis.horizontal,\n  this.alignment = WrapAlignment.start,\n  this.spacing = 0.0,\n  this.runAlignment = WrapAlignment.start,\n  this.runSpacing = 0.0,\n  this.crossAxisAlignment = WrapCrossAlignment.start,\n  this.textDirection,\n  this.verticalDirection = VerticalDirection.down,\n  List<Widget> children = const <Widget>[],\n})\n```\n\n其中很多参数`Row`和`Column`中都有，就不再介绍了，主要介绍点不同的：\n- `spacing`：主轴方向子widget的间距\n- `runSpacing`：纵轴方向的间距\n- `runAlignment`：纵轴方向的对齐方式\n\n下面有一个示例：\n```java\nWrap(\n  spacing: 8.0, // 主轴(水平)方向间距\n  runSpacing: 4.0, // 纵轴（垂直）方向间距\n  alignment: WrapAlignment.center, //沿主轴方向居中\n  children: <Widget>[\n    new Chip(\n      avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('A')),\n      label: new Text('Hamilton'),\n    ),\n    new Chip(\n      avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('M')),\n      label: new Text('Lafayette'),\n    ),\n    new Chip(\n      avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('H')),\n      label: new Text('Mulligan'),\n    ),\n    new Chip(\n      avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('J')),\n      label: new Text('Laurens'),\n    ),\n  ],\n)\n```\n![Wrap示例](http://cdn.littlecorgi.top/mweb/2019-10-10/Wrap%E7%A4%BA%E4%BE%8B.png)\n\n### Flow\n`Flow`较复杂，需要自己实现子Widget的位置转换，一般不推荐使用`Flow`。但是如果需要自定义布局策略，或者对性能要求较高，这个时候就得用`Flow`了。\n\n但是由于太过于复杂，我也没咋用过，我就不在这讲了😝，大家有需要的可以百度，或者看我推荐的这篇：[4.4 流式布局-《Flutter实战》](https://book.flutterchina.club/chapter4/wrap_and_flow.html)\n\n## 层叠布局(Stack)\n这个布局类似于Android中的`Frame`，允许在父布局的任意地方放置布局。\n```java\nStack({\n  this.alignment = AlignmentDirectional.topStart,\n  this.textDirection,\n  this.fit = StackFit.loose,\n  this.overflow = Overflow.clip,\n  List<Widget> children = const <Widget>[],\n})\n```\n- `alignment`：决定如何去对齐；\n- `textDirection`：确定`alignment`的参考系；\n- `fit`：没有定位的子Widget如何去适应`Stack`的大小；\n- `overflow`：决定超出`Stack`显示空间的子Widget如何去显示，如果`Overflow.clip`，则超出部分会隐藏，`Overflow.visible`则不会。\n\n## 对齐与相对定位(Align)\n\nAlign可以调整子Widget的位置，并且可以根据子Widget的宽高来确定自身的宽高。\n```java\nAlign({\n  Key key,\n  this.alignment = Alignment.center,\n  this.widthFactor,\n  this.heightFactor,\n  Widget child,\n})\n```\n- alignment：代表子Widget在父Widget的起始位置；\n- widthFactor和heightFactor确定Align本身的宽高。\n\n来看一个简单的例子：\n```java\nContainer(\n  height: 120.0,\n  width: 120.0,\n  color: Colors.blue[50],\n  child: Align(\n    alignment: Alignment.topRight,\n    child: FlutterLogo(\n      size: 60,\n    ),\n  ),\n)\n```\n运行结果：\n![-w100](http://cdn.littlecorgi.top/mweb/2019-10-10/15706312811307.png)\n\n# 3. 容器类组件\n## 填充(Padding)\n用过Android的同学一定熟悉，Padding就是负责留白的嘛。\n但是跟Android里面不同的是，在Android里面我们一般是在一个View里面添加Padding，但是在Flutter里面，Padding直接变成了一个Widget、一个布局。\n\n使用方法：\n```java\nPadding ({\n  EdgeInsetsGeometry padding,\n  Widget child,\n})\n```\n对于EdgeInsetsGeometry我们一般使用EdgeInsets类。\n\n### EdgeInsets\nEdgeInsets类提供了几个便捷的方法：\n- fromLTRB(double left, double top, double right, double bottom)：分别指定四个方向的填充；\n- all(double value) : 所有方向均使用相同数值的填充；\n- only({left, top, right ,bottom })：可以设置具体某个方向的填充(可以同时指定多个方向)；\n- symmetric({ vertical, horizontal })：用于设置对称方向的填充，vertical指top和bottom，horizontal指left和right；\n\n示例：\n```java\nbody: Column(\n  children: <Widget>[\n    Padding(\n      padding: EdgeInsets.only(left: 12.0, bottom: 10.0),\n      child: Text(\"1234\"),\n    ),\n    Padding(\n      padding: EdgeInsets.fromLTRB(0.0, 0.0, 10.0, 10.0),\n      child: Text(\"1234\"),\n    ),\n    Padding(\n      padding: EdgeInsets.symmetric(vertical: 10.0),\n      child: Text(\"1234\"),\n    ),\n  ],\n),\n```\n运行结果：\n![Padding示例](http://cdn.littlecorgi.top/mweb/2019-10-10/Padding%E7%A4%BA%E4%BE%8B.png)","tags":["Android","Flutter"],"categories":["Flutter"]},{"title":"Flutter入门并开发天气预报APP(3)——Widget","url":"/posts/fc77cdce.html","content":"\n# 简介\n在Flutter中，Widget是个非常基本的东西，我在上一章就说过，Flutter中只要是界面都是Widget，你可以把它就理解成是控件，但是又和Android的View控件不同的是，在Flutter中，包括`Padding`、`Align`、手势检测的`GestureDetector`等等，都算是`Widget`。\n\n其实大多数时候，你就可以把Widget直接理解成UI控件就行了，因为`Padding`、`Align`、`GestureDetector`等等也都是为UI服务的，你就可以理解成Flutter中只要与UI有关的属性都可以算是控件。\n\n<!--More-->\n\n# Widget的状态\n在Android中，我们可以直接通过更新数据来达到刷新UI的目的。但是如果使用Flutter，就像我们前面说的计数器的Demo，如果直接通过`StatelessWidget`也就是无状态Widget的话，是没法进行刷新UI的，只能写一个死界面，也就是说如果在Flutter中界面写出来的就是一个死界面，只有通过刷新状态才能更新UI。\n\nWidget有两个直接子类：`StatelessWidget`和`StatefulWidget`：\n- `StatelessWidget`：这个是无状态Widget，实现`build()`方法后，就不可再变化，哪怕他的状态改变了。这句话可能有点矛盾，但是我来举个例子，比方说现在有一个`StatelessWidget`，他的内容就是一个`Text`，而这个`Text`的内容则显示了`counter`这个变量。当这个页面出现的时候，取了当时`counter`的值并显示了出来，但是我们后续不管`counter`这个值怎么改变，界面都是不会显示出来的。\n- `StatefulWidget`：这个是有状态Widget，当你有状态需要改变的时候就可以通过他来改变状态。\n\nState的几种状态：\n\n|名称|状态|\n|:-:|:-:|\n|initState|create之后被insert到渲染树时调用的，只会调用一次|\n|didChangeDependencies|state依赖的对象发生变化时调用|\n|didUpdateWidget|Widget状态改变时候调用，可能会调用多次|\n|build|构建Widget时调用|\n|deactivate|当移除渲染树的时调用|\n|dispose|Widget即将销毁时调用|\n\n# StatelessWidget\n这个类相对简单，只需要实现`build()`方法就可以了。\n\n`StatelessWidget`用于不需要维护状态的场景，也就是说如果他需要显示的某一个参数的值发生变化了他也不变。\n\n```java\nclass Test extends StatelessWidget {\n  Test({Key key, this.title}) : super(key: key);\n\n  final String title;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: new AppBar(\n        title: Text(\"$title\"),\n      ),\n      body: Text(\"1234\"),\n    );\n  }\n}\n```\n上面代码就演示了一个`StatelessWidget`的例子，功能是根据传入的`title`在界面的`title`了上显示出来。只实现了`build()`方法和构造方法。其中构造方法参数`Key`是必须得有的，而且如果该Widget还有其他状态的话，也需要写入构造方法。接着调用`build()`方法，将传入的`title`在界面的`title`上显示出来。\n\n例如，如果我们调用它：\n```java\n@override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: Test(title: 'Flutter Demo Home Page'),\n    );\n  }\n```\n结果是：\n![Screenshot_20191009-112644](http://cdn.littlecorgi.top/mweb/2019-10-09/Screenshot_20191009-112644.jpg)\n\n# StatefulWidget\n与`StatelessWidget`相对的就是`StatefulWidget`。它的重点在于可以根据状态来更新。\n\n他较于`StatelessWidget`，少了我们常用的`build()`方法，多了`createState()`方法。下面我就来讲一下他的用法，我还是拿上面的`Test`做例子。\n\n```java\nclass Test extends StatefulWidget {\n  Test({Key key, this.title}) : super(key: key);\n\n  final String title;\n\n  @override\n  _TestState createState() => _TestState();\n}\n\nclass _TestState extends State<Test> {\n  String _title;\n\n  @override\n  void initState() {\n    setState(() {\n      _title = widget.title;\n    });\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: new AppBar(\n        title: Text(\"$_title\"),\n      ),\n      body: Text(\"1234\"),\n    );\n  }\n}\n```\n先看`Test`类，他继承自`StatefulWidget`，由于这个页面需要根据传入的参数来显示`title`，所以有一个状态`title`，并在构造方法中写入了他。接着调用了`createState()`方法。这个方法是所有`StatefulWidget`必须的，主要是为这个Widget创建他对应的State。\n\n于是我们就在下面创建一个新的类，类名叫`_TestState`，继承自`State<Test>`。由于Widget有`title`这个状态，并且需要在界面中显示出来，所以为了降低他们的耦合度，我们在State类中也创建一个叫`_title`的状态，并`_title = widget.title;`。\n接下来是一个`initState()`方法，这个方法也是State必须的，在上面Widget的状态中我们讲到过，这个是初始化State的，同时在`initSate()`里面，我们写了一个`setState()`，也就是说我们告诉Flutter说这个方法里面的参数改变了接着Widget的状态也得改变。最后就是`build()`方法。\n\n接下来我们调用它：\n```java\n@override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: Test(title: '1234'),\n    );\n  }\n```\n结果是：\n![Screenshot_20191009-114316](http://cdn.littlecorgi.top/mweb/2019-10-09/Screenshot_20191009-114316.jpg)\n","tags":["Android","Flutter"],"categories":["Flutter"]},{"title":"Flutter入门并开发天气预报APP(2)——Flutter计数器Demo","url":"/posts/956d1e66.html","content":"\n本文样例都是使用的AndroidStudio，如果你使用Xcode或者vscode，代码都是一样的，只是IDE创建项目的方式以及运行按键位置不同而已。\n\n<!-- More -->\n\n# 创建Flutter项目\nAndroidStudio中选择`File`->`New`->`New Flutter Project`->`Flutter Application`->`NEXT`。接着填写你的项目名称等一系列信息后就创建成功了，我们就会看到AndroidStudio已经为我们创建好了一个Demo，接着连上你的手机或者打开你的虚拟机，按下AndroidStudio的运行键，不一会儿，你就会惊喜的发现你的手机上就有一个Flutter计数器Demo了。\n![计数器运行Demo](http://cdn.littlecorgi.top/mweb/2019-10-09/%E8%AE%A1%E6%95%B0%E5%99%A8%E8%BF%90%E8%A1%8CDemo.png)\n\n# 介绍下AndroidStudio界面\n![AndroidStudio界面](http://cdn.littlecorgi.top/mweb/2019-10-09/AndroidStudio%E7%95%8C%E9%9D%A2.png)\n这是我的AndroidStudio界面，接下来我分三个部分介绍下AndroidStudio的大致界面。\n\n## 控制区\n![控制区](http://cdn.littlecorgi.top/mweb/2019-10-09/%E6%8E%A7%E5%88%B6%E5%8C%BA.png)\n\n一次介绍每一个按钮的功能。\n1. 第一个是用来选择运行设备的，比方说我现在就选的是我的虚拟机，然后我按下运行后就可以将项目运行到我的虚拟机上而不会运行到连着我的电脑的手机上去；\n2. 第二个是选择运行哪个Flutter module，如果你同一个项目里面有多个module，你就可以在此选择你想要运行的module；\n3. 第三个灰色的选项框我也没弄懂她是干嘛的，我至今都没能选择过，一直都是灰的；\n4. 绿色的三角形，大家熟知，运行键；\n5. 红色的瓢虫，大家熟知，debug键；\n6. 不知道干嘛的；\n7. FlutterAPP的性能监视器；\n8. 闪电，这个是重点，也是Flutter的一大特性，热重载键，他能做到不需要重新编译代码就能将你修改的代码的效果在你的APP上显示出来；\n9. 不知道干嘛的；\n10. 红色的正方形，停止运行按钮。\n\n## Run运行区\n![Run运行区](http://cdn.littlecorgi.top/mweb/2019-10-09/Run%E8%BF%90%E8%A1%8C%E5%8C%BA.png)\n就是Flutter的信息显示区，类似于AndroidStudio的Logcat，能显示FlutterAPP运行中的一些信息。\n\n## Flutter Outline/Flutter Inspector区\n![Flutter Outline](http://cdn.littlecorgi.top/mweb/2019-10-09/Flutter%20Outline.png)\n![Flutter Inspecto](http://cdn.littlecorgi.top/mweb/2019-10-09/Flutter%20Inspector.png)\n用于显示当前界面的一些构建信息。\n\n# Flutter项目结构\n![Flutter项目结构](http://cdn.littlecorgi.top/mweb/2019-10-09/Flutter%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png)\n\n我们挑一些重要的说一下：\n1. .idea文件夹，AndroidStudio识别项目的必备文件夹，不用管；\n2. Android文件夹，存放Flutter构建的Android项目的文件夹；\n3. ios文件夹，存放Flutter构建的iOS项目的文件夹；\n4. lib文件夹，存放Flutter项目和资源的文件夹；\n5. pubspec.yaml文件，存放Flutter项目相关信息，如项目名称、版本、依赖等等，类似于Android项目的build.gradle文件。\n\n# main.dart文件\n我们通过讲这个文件来给大家大致介绍下Flutter项目代码结构。\n\n全部源代码在此\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: MyHomePage(title: 'Flutter Demo Home Page'),\n    );\n  }\n}\n\nclass MyHomePage extends StatefulWidget {\n  MyHomePage({Key key, this.title}) : super(key: key);\n  final String title;\n\n  @override\n  _MyHomePageState createState() => _MyHomePageState();\n}\n\nclass _MyHomePageState extends State<MyHomePage> {\n  int _counter = 0;\n\n  void _incrementCounter() {\n    setState(() {\n      _counter++;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(widget.title),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text(\n              'You have pushed the button this many times:',\n            ),\n            Text(\n              '$_counter',\n              style: Theme.of(context).textTheme.display1,\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _incrementCounter,\n        tooltip: 'Increment',\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n\n```\n\n## import\n首先我们看最开始的`import`区。\n\n这块相当于C/C++的`include`，反而不像java的`import`。我为什么这么说呢，你想一下，你写java程序的时候，你是需要哪个类就直接在代码中输入类名，然后IDE会自动给你显示有这个类的所有的包，然后让你选包去导入；而写dart是需要你先导入包，才能在代码中写这个包中的类，如果你没有先导入包而直接到下面写的话，IDE是不会提示你这个类可能会在哪个包中，而是直接报错，这点和C/C++比较类似。\n\n那我们为什么导入的是`flutter/material.dart`这个包呢？我在第一节里面说过，Flutter他内置了Android的Material Design风格和iOS的Cupertino风格的UI；所以这块就是导入Material Design风格UI文件，而如果你要使用Cupertino风格UI文件的话，把它改成Cupertino就行了。\n\n## main()\n```dart\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ), \n      home: MyHomePage(title: 'Flutter Demo Home Page'),\n    );\n  }\n}\n```\n- 第一行，指明项目的入口就是`MyApp()`。固定格式，可以不用管。\n\n- 第二行就定义了一个类`MyApp`继承自`StatelessWidget`，并重写了父类的`build()`方法。`Widget`可以看成Flutter中的页面，只要是Flutter中的页面，都必须继承自`Widget`。他有点类似于Android中的`View`，但是不同于`View`的是，Flutter中的`padding`、`align`、`layout`等居然也是`Widget`。\n\n- 如果是`StatelessWidget`，则代表她是一个“状态少”的`Widget`，我的理解就是状态相当于`Widget`的一些数值，比方说页面要显示计数器的计数`count`，那么这个`count`就是一个状态，只要有状态就使用`StatefulWidget`。像`MyApp`它没有状态，于是就用`StatelessWidget`。\n\n- 继承自`StatelessWidget`的类必须实现`build()`方法，相当于这个类是一个死页面，只需要展示固定的内容，也就是不需要状态，所以直接通过`build()`直接写入界面就行。\n\n- `build()`方法必须同样返回一个`Widget`，所以我们就使用`MaterialApp`，其中我们给他的`title`、`theme`、`home`进行了赋值，同学们应该都能大致读懂啥意思，首页`home`则给了`MyHomePage`.\n\n## MyHomePage\n```dart\nclass MyHomePage extends StatefulWidget {\n  MyHomePage({Key key, this.title}) : super(key: key);\n  final String title;\n\n  @override\n  _MyHomePageState createState() => _MyHomePageState();\n}\n\nclass _MyHomePageState extends State<MyHomePage> {\n  int _counter = 0;\n\n  void _incrementCounter() {\n    setState(() {\n      _counter++;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(widget.title),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text(\n              'You have pushed the button this many times:',\n            ),\n            Text(\n              '$_counter',\n              style: Theme.of(context).textTheme.display1,\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _incrementCounter,\n        tooltip: 'Increment',\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n```\n\n### MyHomePage\n我们在前面说过，如果一个页面有数据也就是“状态”的话，那么他就得继承自`StatefulWidget`。\n\n如果一个类继承自`StatefulWidget`，那这个类会很简单，只需要创建一个构造方法，构造方法中写入`key`以及该`Widget`需要的数据。然后重写`createState()`方法。\n\n### MyHomePageState\n如果一个类继承自`StatefulWIdget`，那么一定会有一个他的`State`类并继承自`State<该类>`，就像`class _MyHomePageState extends State<MyHomePage>`一样。\n\n那我们来看看State类里面有些啥东西:\n\n首先先定义“状态”：由于我们这个APP主要的功能是用来计数，所以必须定义一个int型变量来计数：\n```dart\nint _counter = 0;\n```\n接着如果我们这个_counter变量变了，那就得通知flutter说状态变了，需要更新UI：\n```dart\nvoid _incrementCounter() {\n  setState(() {\n     _counter++;\n  });\n}\n```\n其中，`setState()`方法就是用来通知`Flutter`这个状态改变了，要去更新UI的。\n\n最后重写`build()`方法来写入界面：\n\n- `Scaffold`是一个组件，它提供了默认的导航栏、标题和包含主屏幕`widget`树（后同“组件树”或“部件树”）的`body`属性。\n- `body`后面是一个`Center`组件，它的作用是将它的子`Widget`定位到父`Widget`的中间。\n- `Center`后面是一个`Column`组件，这个组件类似于Android中的`LinearLayout`的`orientation: Vertical`，也就是垂直向的线性布局。同时Flutter也提供了`Row`这个水平向的线性布局。他们的子`Widget`是`children`属性，也就是可以写多个`Widget`。\n- `Column`里面是两个`Text`，这个没啥讲的\n- 接下来是一个`FloatingActionButton`，这就是一个浮动按钮，Android里面有这个控件，核心是他的`onPressed`属性，这个就相当于`onClick()`，用于处理点击事件。\n\n# 体验热重启\n首先先让项目在虚拟机或者手机上运行着，然后我们把页面Text中的\"You have pushed the button this many times:\"改为\"You have clicked the button this many times:\"，然后按热重启键（macOS版AndroidStudio默认是commond+s键），接着你就能里面在虚拟机或者手机上看到修改之后的结果。\n![flutter热重启](http://cdn.littlecorgi.top/mweb/2019-10-09/%E6%9C%AA%E5%91%BD%E5%90%8D%20-2-.gif)\n","tags":["Android","Flutter"],"categories":["Flutter"]},{"title":"Flutter入门并开发天气预报APP(1)——Flutter安装","url":"/posts/4bf666bf.html","content":"# Flutter是什么\nFlutter是由谷歌推出的一个移动UI框架，可以让开发者快速的在Android和iOS上构建高质量的原生用户界面。\n\n<!-- More -->\n\n通过它来编写APP的好处在于：\n- 它内置了Android的Material Design风格和iOS的Cupertino风格的UI；\n- 它通过Dart语言编写，只需要编写一份代码就能在Android和iOS设备上得到同样的运行效果；\n- 他有热重载功能，只需要运行APP后，代码更改一点然后点击热重载键就能快速显示出修改后的界面。\n\n# 使用镜像安装\n由于一些众所周知的原因，Flutter在国内访问有时候会受到限制，因此Flutter官方为国内开发者搭建了临时镜像，大家可以将下面的环境变量添加到系统中：\n```bash\nexport PUB_HOSTED_URL=https://pub.flutter-io.cn\nexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn\n```\n由于我用的是macOS，因此我就只演示macOS的。\n如果有Linux的用户则和macOS 的安装方式类似，甚至可以说一样；\n但是对于Windows用于，需要大家桌面右键此`电脑->属性->弹出页面左侧栏的高级系统设置->环境变量`，在下面的系统环境变量栏中点击新建，变量名输入上面等号左边的大写内容，不要export，值输入等号右边的内容，输入一组之后再点击新建接着输入下一组。\n![Windows下的环境变量配置](https://img-blog.csdn.net/20180616140532293?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ExMjAzOTkxNjg2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n接下来我们开始说macOS。\n## 首先你得确定你用的是什么shell\n如果你没更改过你macOS终端设置，那么你默认就是`bash`，但是如果你更改过，比方说我就换成了`zsh`，那么我觉得你应该知道在哪设置环境变量。\n## 如果你是bash\n首先打开你macOS的终端，在启动台里面可以找到，接着对`bash`的环境变量进行设置，输入\n```\nvim ~/.bash_profile\n```\n回车，进入`.bash_profile`文件的编辑页面，然后按下键盘`I键`，进入vim的编辑模式，然后直接把上面的export环境变量赋值粘贴进去。然后按下`Esc键`退出vim的编辑模式，然后直接输入`:wq`回车保存并退出。\n接着输入\n```\nsource ~/.bash_profile\n```\n让刚刚配置的环境变量生效即可。\n![bash配置环境变量](http://cdn.littlecorgi.top/mweb/2019-10-08/bash%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png)\n\n## 如果你是zsh\n首先打开你macOS的终端，在启动台里面可以找到，接着对`zsh`的环境变量进行设置，输入\n```\nvim ~/.zshrc\n```\n回车，进入`.zshrc`文件的编辑页面，找到如图所示部分（重点在于有`# export MANPATH=\"/Usrs/......`的地方，因为我还有其它的环境变量，所以你的可能和我的不同）：\n![zshr](http://cdn.littlecorgi.top/mweb/2019-10-08/zshrc.png)\n\n\n在`# export`下面，按下键盘`I键`，进入vim的编辑模式，然后直接把上面的export环境变量赋值粘贴进去。\n见我图中最下面标红的那地方，至于最后一行`export PATH=~/development/flutter/bin:$PATH`先不管。然后按下`Esc键`退出vim的编辑模式，然后直接输入`:wq`回车保存并退出。\n接着输入\n```\nsource ~/.zshrc\n```\n让刚刚配置的环境变量生效即可。\n![zsh配置环境变量](http://cdn.littlecorgi.top/mweb/2019-10-08/zsh%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png)\n\n# 下载Flutter SDK\n## 先去Flutter的官网去下载你对应系统的Flutter SDK\n1. 打开官网下载页：[Flutter SDK release](https://flutter.dev/docs/development/tools/sdk/releases)\n2. 选择你的系统对应的目录，然后默认选择Stable channel下载。(*Master channel这个是直接从github获取的github上的最新版，也就是说Flutter的开发者他写了点什么改了点什么都会里面在这个版本上显示出来，所以这个版本意味着非常不稳定，可能bug很多；Dev channel是开发版，Master channel经过一定测试之后的版本会发布到Dev channel上，但是不是大量的测试，所以可能还是不太稳定；Beta channel是测试版，每月发布一次，会把上个月所释放的所有Dev channel中最稳定的版本释放到Beta channel上，但是相对来说还是有点不稳定，适合想尝鲜的开发者；State channel是标准版，当Flutter维护人员认为某个版本足够稳定之后，就会发送到这个版本上去，一般开发者最好还是使用这个版本)\n\n## 解压安装包到你想要的目录\n例如\n```\n// Linux/macOS\ncd ~/development\nunzip ~/Downloads/flutter_macos_v0.5.1-beta.zip\n```\n\n## 添加Fluuter路径到环境变量中\n回顾第2项，把如下内容添加到环境变量中去\n```bash\nexport PATH=/你上一步flutter解压的目录/flutter/bin:$PATH\n```\n## 运行Flutter doctor\n如果是macOS/Linux，直接在终端中输入`flutter doctor`即可。\n如果是Windows，则右键开始，选择PowerShell，然后输入`flutter doctor`即可。\n\n这个命令的功能是检查你的Flutter是否正常安装。\n\n如果正常安装的话会出现如下信息：\n```bash\nDoctor summary (to see all details, run flutter doctor -v):\n[✓] Flutter (Channel stable, v1.9.1+hotfix.4, on Mac OS X 10.13.6 17G65, locale zh-Hans-CN)\n \n[✓] Android toolchain - develop for Android devices (Android SDK version 29.0.1)\n[✗] Xcode - develop for iOS and macOS\n    ✗ Xcode installation is incomplete; a full installation is necessary for iOS development.\n      Download at: https://developer.apple.com/xcode/download/\n      Or install Xcode via the App Store.\n      Once installed, run:\n        sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer\n    ✗ CocoaPods not installed.\n        CocoaPods is used to retrieve the iOS and macOS platform side's plugin code that responds to\n        your plugin usage on the Dart side.\n        Without CocoaPods, plugins will not work on iOS or macOS.\n        For more info, see https://flutter.dev/platform-plugins\n      To install:\n        sudo gem install cocoapods\n        pod setup\n[✓] Android Studio (version 3.5)\n[!] IntelliJ IDEA Community Edition (version 2019.2.3)\n    ✗ Flutter plugin not installed; this adds Flutter specific functionality.\n    ✗ Dart plugin not installed; this adds Dart specific functionality.\n[✓] VS Code (version 1.38.1)\n[✓] Connected device (1 available)\n\n! Doctor found issues in 2 categories.\n```\n\n我的电脑运行之后会出现两个错误，因为Flutter doctor会自动检查电脑中所有能运行Flutter的编辑器或者IDE，然后判断他们配没配置Flutter。我的电脑是因为没有安装Xcode以及我没有在IDEA中配置Flutter，所以我这两项出错。\n\n其实你只要保证除了IDE之外的项目都是正常的就行了，如果有错的话直接把报错信息放到百度里面进行搜索就可以了。至于IDE项目，如果你是iOS开发者，则保证Xcode或者是AppCode啥的前面是✔️就行了的，至于你电脑上的其它例如IDEA或者vscode啥的可以不用管；如果你是Android开发者，则保证你常用的IDE如Android Studio前面是✔️就行了的，至于你电脑上的其它例如IDEA或者vscode啥的可以不用管。\n\n总而言之，确保除了IDE之外的其它项前面是对勾，然后确定一个你常用的写代码的工具前面有对勾就行了，如果你除了IDE之外的其它项有问题，就把错误信息直接百度；如果是你常用的IDE前面没对勾，那就百度你常用的IDE+Flutter来参考别人的配置教程。\n\n---\n*由于我没有用过xcode所以就不讲xcode如何配置Flutter了，就分别讲如何在AndroidStudio和vscode配置Flutter。*\n\n---\n\n# Android Studio配置Flutter\n1. 打开你Android Studio的`设置/首选项/Preferences`，然后选择`Plugins`，在`Marketplace`里面搜索`Flutter`：     ![Androidstudio Flutte](http://cdn.littlecorgi.top/mweb/2019-10-08/Androidstudio%20Flutter.png)\n\n2. 接着点击`INSTALL`安装就行了，并且安装Flutter插件会自动顺带安装Dart插件，如果没有安装Dart插件，你就一样的搜索`Dart`然后安装即可；\n3. 安装完成并重启Android Studio之后，仍然打开`设置/首选项/Preferences`，选择`Languages & Frameworks`->`Flutter`，在最上面的SDK中的`Flutter SDK path`选择你第三步Flutter SDK解压缩的路径，不出意外的话下面`Version`会自动显示你Flutter SDK的版本，并且`Languages & Frameworks`->`Dart`里面的`Dart SDK path`也会自动出现。\n    ![Android Studio Flutter Setting](http://cdn.littlecorgi.top/mweb/2019-10-08/Android%20Studio%20Flutter%20Setting.png)\n4. 接着和之前一样运行`flutter doctor`,看看Android Studio前面有没有✔️，正常情况下是会有的。\n\n# vscode 配置Flutter\n1. 在vscode拓展里面搜索Flutter和Dart，安装； ![vscode Flutte](http://cdn.littlecorgi.top/mweb/2019-10-08/vscode%20Flutter.png)\n\n2. 接着和之前一样运行`flutter doctor`,看看vscode前面有没有✔️，正常情况下是会有的。","tags":["Android","Flutter"],"categories":["Flutter"]},{"title":"操作系统6--死锁","url":"/posts/68dc89d4.html","content":"# 6.1 死锁的引入\n\n在之前我们或多或少都涉及到了死锁，最直接的例子就是哲学家就餐筷子，如果每一个哲学家都拿起了他的右手的筷子，现在都在等左边的筷子。这样一直绕下去，从而产生了死锁。\n\n<!--More-->\n\n## 6.1.1 资源问题\n在系统中存在着很多不同类型的资源，其中可以引起的死锁的主要是需要采用互斥访问方法的、不可以被抢占的资源、\n\n### 6.1.1.1 可重用性资源和消耗性资源\n\n#### 可重用性资源\n可重用性资源是一种可供用户重复使用多次的资源，它具有以下性质：\n1. 每一个可重用性资源中的单位只能分配给一个进程使用，不允许多个进程共享\n2. 进程在使用可重用性资源时，须按照这样的顺序：请求资源 -> 使用资源 -> 释放资源\n3. 系统中每一类可重用性资源中的单元数目是相对固定的，进程在运行期间既不能创建也不能删除它\n\n#### 可消耗性资源\n可消耗性资源又称为临时性资源，它是在进程运行期间，由进程动态的创建和消耗的，它具有以下性质：\n1. 每一类可消耗性资源的单元数目在进程运行期间是可以不断变化的，有时它可以有很多，有时可能为0\n2. 进程在运行过程中，可以不断地创造可消耗性资源的单元，将它们放入该资源类的缓冲区中，以增加该资源类的单元数目\n3. 进程在运行过程中，可以请求若干个可消耗性资源单元，用于进程自己的消耗，不再将它们返回给该资源类中\n\n### 6.1.1.2 可抢占性资源和不可抢占性资源\n#### 可抢占性资源 \n可把系统中的资源分为两类，一类是可抢占性资源，是指某进程在获得这类资源后，该资源可以再被其它进程或系统抢占\n\n#### 不可抢占性资源\n另一类资源是不可抢占资源，一旦系统把某资源分配给该进程之后，就不能将它强行回收，只能在进程用完后自行释放\n\n## 6.1.2 死锁的起因\n### 6.1.2.1 竞争不可抢占性资源引起的死锁\n通常系统中所拥有的不可抢占性资源其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局。\n\n一个很简单的例子，进程$P_1$和$P_2$在并发执行，他们都要写两个文件$F_1$和$F_2$。其中$P_1$和$P_2$的代码分别为：\n``` C\n   P1\n  ....\nOpen(f1, w);\nOpen(f2, w);\n\n   P2\n  ....\nOpen(f2, w);\nOpen(f1, w);\n```\n\n如果这两个进程在并发执行的时候，如果$P_1$先打开$F_1$和$F_2$，然后$P_2$才去打开$F_1$(或$F_2$)，由于文件$F_1$(或$F_2$)已经被打开，因此$P_2$会被阻塞。当$P_1$使用完$F_1$(或$F_2$)，这时$P_2$才可以去打开$F_1$(或$F_2$)，这样程序继续运行下去。\n\n但是如果在$P_1$打开$F_1$的同时，$P_2$去打开$F_2$，每个进程都占有一个打开的文件，此时就可能出现问题。因为当$P_1$试图去打开$F_2$,而$F_2$试图去打开$F_1$时，这两个进程都会因文件已被打开而阻塞，因此这两个进程将会无限期地等待下去，从而形成死锁。\n![共享文件时的死锁情况](http://cdn.littlecorgi.top/mweb/2019-09-19/%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E6%97%B6%E7%9A%84%E6%AD%BB%E9%94%81%E6%83%85%E5%86%B5.png)\n\n\n### 6.1.2.2 竞争可消耗资源引起的死锁\n![进程之间通信时的死锁](http://cdn.littlecorgi.top/mweb/2019-09-19/%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%97%B6%E7%9A%84%E6%AD%BB%E9%94%81.png)\n如图所示，$m_1$、$m_3$、$m_3$是可消耗资源。进程$P_1$一方面产生消息$m_1$，利用`send(p2,m1)`将它发送给$P_2$，另一方面，有要求从$P_3$接受消息$m_2$；而$P_2$、$P_3$依次类推。\n\n如果三个进程按以下顺序进行：\n```c\nP1:   ...send(p2, m1);    receive(p3, m3);...\nP2:   ...send(p3, m2);    receive(p1, m1);...\nP3:   ...send(p1, m3);    receive(p2, m2);...\n```\n这三个进程都可以先将消息发送给下一个进程，相应地他们也都能都接收到从上一个进程发来的消息，因此三个进程都可以顺利的进行下去，不会发生死锁。\n\n但是如果三个进程都先执行receive，在执行send，按下面的顺序运行：\n```c\nP1:   ...receive(p3, m3);    send(p2, m1);...\nP2:   ...receive(p1, m1);    send(p3, m2);...\nP3:   ...receive(p2, m2);    send(p1, m3);...\n```\n那么这三个进程就会永远阻塞在它们的receive操作上，就会产生死锁。\n\n\n# 6.2 死锁的定义、必要条件和处理方法\n## 6.2.1 死锁的定义\n如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的。\n\n## 6.2.2 产生死锁的必要条件\n产生死锁必须同时具备下面四个必要条件，只要其中任一个条件不成立，死锁就不会发生：\n1. 互斥条件。进程对所分配的资源进行排他性使用。即该资源只允许一个进程使用，其他进程如果请求该资源只能等待。\n2. 请求和保持条件。进程已经保持一至少一个资源，但又提出了新的资源请求，而新资源已被其他进程占有，导致进程被阻塞。\n3. 不可抢占条件。 进程已获得的资源在为使用完之前不能被抢占，只有进程在使用完之后才能释放。\n4. 循环等待条件。发生死锁时，必然存在一个进程资源循环链，即进程集合$[P_0, P_1, P_2, ···, P_n]$中$P_0$正在等待一个$P_1$占用的资源，$P_1$正在等待一个$P_2$占用的资源，……，$P_n$正在等待一个$P_0$占用的资源\n\n## 6.2.3 处理死锁的办法\n目前处理死锁的方法可归结为四种：\n1. 预防死锁。通过设置某些限制，去破坏产生死锁四个必要条件中的一个或几个来预防死锁。\n2. 避免死锁。在资源的动态分配过程中，用某种方法阻止系统进入不安全状态，从而避免发生死锁。\n3. 检测死锁。该方法允许进程在运行过程中发生死锁，但可通过检测机构及时地检测出死锁的发生，然后采取适当措施，把进城从死锁中解脱出来。\n4. 解除死锁。当检测到系统中已发生死锁时，就采取相应措施，将进程从死锁状态中解脱出来。\n\n# 6.3 预防死锁\n预防死锁时通过破坏产生死锁四个必要条件中的一个或几个，以避免发生死锁。\n\n## 6.3.1 破坏“请求和保持”条件\n当一个进程在请求资源时，他不能持有不可抢占资源。可通过一下两种不同的协议实现：\n\n### 6.3.1.1 第一种协议\n所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源。此时若系统中有足够的资源分配给某进程，便可把其需要的所有资源分配给它。这样，该进程在整个运行期间，便不会再提出资源要求，从而破坏了“请求”条件。系统在分配资源时，只要有一种资源不能满足进程的要求，即使其所需的其他资源都空闲也不分配给它，而让该进程等待。由于该进程在等待期间未占有任何资源，于是破坏了“保持”条件，从而可以预防死锁的发生。\n\n这种协议的优点是简单、易行且安全。但是缺点也极其明显：\n1. 资源被严重浪费，严重的恶化了资源的利用率。\n2. 使进程经常的发生饥饿现象。\n\n### 6.3.1.2 第二种协议\n该协议是对第一种协议的改进，它允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行的过程中再逐步释放已分配给自己的、且已用毕的全部资源，然后再请求新的所需资源。\n\n## 6.3.2 破坏“不可抢占”条件\n为了能破坏“不可抢占”条件，协议中规定，当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，他必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着进程已占有的资源会被暂时地释放，或者说是被抢占了，从而破坏了“不可抢占”条件。\n\n## 6.3.3 破坏“循环等待”条件\n一个能保证“循环等待”条件不成立的方法是，对系统所有资源类型进行线性排序，并赋予不同的序号。排序后，便可以采用这样的预防协议：规定每个进程必须按照序号的地址顺序来请求资源。一个进程在开始时，可以请求资源$R_i$的单元，以后，当且仅当$F(R_j)>F(R_i)$，进程才可以请求资源$R_j$。如果需要多个同类资源单元，则必须一起请求。\n\n- 优点：资源利用率和系统吞吐量都有比较明显的改善。\n- 缺点：\n    1. 系统中各类资源所规定的序号必须稳定，这就限制了新类型设备的增加\n    2. 可能会发生作业使用各类资源的顺序与系统规定的不同，造成资源的浪费。\n    3. 这种按照规定次序申请资源的方法会限制用户简单，自主的编程。\n\n# 6.4 避免死锁\n\n## 6.4.1 系统安全状态\n在死锁避免方法中，把系统的状态分为安全状态和不安全状态。当系统处于安全状态时，可避免发生死锁。反之，当系统处于不安全状态时，则可能进入到死锁状态。\n\n在该方法中，允许进程动态的申请资源吗，但系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，才可将资源分配给进程，否则，另进程等待。\n\n安全状态是指系统能按某种进程推进顺序为每个进程分配其所需资源，直至满足每个进程对资源的最大需求。如果无法找到这样一个序列，则称系统处于不安全状态。\n\n## 6.4.2 利用银行家算法避免死锁\n为实现银行家算法，每一个新进程在进入系统时，他必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给进程。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不会，才分配资源。\n\n### 6.4.2.1 银行家算法中的数据结构\n1. 可利用资源向量Available。代表系统中目前已有的可分配的该种资源的最大数。\n2. 最大需求矩阵Max。代表该进程对该资源的最大需求数。\n3. 分配矩阵Allocation。代表目前已经分配给该进程的该资源的数目。\n4. 需求矩阵Need。代表该进程还需要该资源的数目。\n\n### 6.4.2.2 银行家算法\n设$Request_i$是进程$P_i$的请求向量，如果$Request_i[j]=K$，表示进程$P_i$需要$K$个$R_j$类型的资源。当$P_i$发出资源请求后，系统按下述步骤进行检查：\n1. 如果$Request_i[j] \\le Need[i, j]$，便转向步骤2；否则任务出错，因为它所需要的资源数已超过它所宣布的最大值。\n2. 如果$Request_i[j] \\le Available[j]$，便转向步骤3；否则，表示尚无足够资源，$P_i$需等待。\n3. 系统试探着把资源分配给进程$P_i$，并修改下面数据结构中的数值： $Available[j] = Available[j] - Request_i[j]$\n    $Allocation[i,j] = Allocation[i,j] + Request_i[j]$\n    $Need[i,j] = Need[i,j] - Request_i[j]$\n4. 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程$P_i$，已完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程$P_i$等待。\n\n### 6.4.2.3 安全性算法\n1. 设置两个向量：①工作向量Work，他表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，$Word = Available$；②FInish：他表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做$Finish[i] = false$；当有足够资源分配给进程时，再令$Finish[i] = true$。\n2. 从进程集合中找到一个能满足下述条件的进程：①$Finish[i]=false$；②$Need[i,j] \\le Work[j]$；若找到则执行步骤3，否则执行步骤4.\n3. 若进程$P_i$获得资源后，可顺利执行，直至完成，并释放出分配给他的资源，故应执行：\n    $Word[j] = Work[j] + Allocation[i,j];$\n    $Finish[i]=true;$\n    go to step 2;\n4. 如果所有进程的$Finish[i]=true$都满足，则表示系统处于安全状态；否则，系统处于不安全状态。\n\n### 6.4.2.4 银行家算法例子\n#### 题目\n假定系统中有五个进程$\\{P_0, P_1, P_2, P_3, P_4\\}$和三类资源$\\{A, B, C\\}$，各种资源的数量分别为10、5、7，在$T_0$时刻的资源分配情况如图所示：\n![T0时刻的资源分配表](http://cdn.littlecorgi.top/mweb/2019-09-20/T0%E6%97%B6%E5%88%BB%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E8%A1%A8.png)\n\n#### 在$T_0$时刻的安全性\n利用安全性算法对$T_0$时刻的资源分配情况进行分析可知，在$T_0$时刻存在着一个安全序列$\\{P_1,P_3,P_4,P_2,P_0\\}$，故系统是安全的。\n![T0时刻的安全序列](http://cdn.littlecorgi.top/mweb/2019-09-20/T0%E6%97%B6%E5%88%BB%E7%9A%84%E5%AE%89%E5%85%A8%E5%BA%8F%E5%88%97.png)\n\n\n#### $P_1$请求资源\n$P_1$发出请求向量$Request_1(1,0,2)$，系统按银行家算法进行检查：\n①$Request_1(1,0,2) \\le Need_1(1,2,2)$；\n②$Request_1(1,0,2) \\le Available_1(3,3,2)$；\n③系统先假定可为$P_1$分配资源，并修改$Avaliable$，$Allocation_1$和$Need_1$向量，由此形成的资源变化情况如1图中的圆括号所示；\n④再利用安全性算法检查此时系统是否安全，如图所示\n![P1申请资源时的安全性检查](http://cdn.littlecorgi.top/mweb/2019-09-20/P1%E7%94%B3%E8%AF%B7%E8%B5%84%E6%BA%90%E6%97%B6%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%A3%80%E6%9F%A5.png)\n\n有所进行的安全性检查得知，可以找到一个安全序列$\\{P_1,P_3,P_4,P_2,P_0\\}$。因此，系统是安全的，可以立即将$P_1$所申请的资源分配给它。\n#### $P_4$请求资源\n$P_4$发出请求向量$Request_4(3,3,0)$，系统按银行家算法进行检查：\n①$Request_4(3,3,0) \\le Need_4(4,3,1)$；\n②$Request_4(3,3,0) \\ge Available(2,3,0)$，让$P_4$等待。\n\n#### $P_0$请求资源\n$P_0$发出请求向量$Request_0(0,2,0)$，系统按银行家算法进行检查：\n①$Request_0(0,2,0) \\le Need_0(7,4,3)$；\n②$Request_0(0,2,0) \\le Available(2,3,0)$；\n③系统暂时先假定可为$P_0$分配资源，并修改有关数据，如图所示。\n![为P0分配资源后的有关资源数据](http://cdn.littlecorgi.top/mweb/2019-09-20/%E4%B8%BAP0%E5%88%86%E9%85%8D%E8%B5%84%E6%BA%90%E5%90%8E%E7%9A%84%E6%9C%89%E5%85%B3%E8%B5%84%E6%BA%90%E6%95%B0%E6%8D%AE.png)\n\n#### 进入安全性检查\n可用资源$Available(2,1,0)$已不能满足任何进程的需要，故系统进入不安全状态，此时系统不分配资源。","tags":["操作系统"],"categories":["操作系统"]},{"title":"操作系统5--处理机调度","url":"/posts/8b4e2673.html","content":">大家可以看下我使用幕布软件画的[思维导图](https://mubu.com/doc/3Pf0zwzrgw)，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员https://mubu.com/inv/477598\n<!-- More -->\n\n在多道程序中，调度的实质是一种资源分配，处理机调度是对处理机资源进行分配。\n\n# 5.1 处理机调度的层次和调度算法的目标\n在多道批处理系统中，一个作业从提交到获得处理机执行，直至作业运行完成，可能需要经历多次处理机调度。\n\n## 5.1.1 处理机调度的层次\n1. 高级调度\n    高级调度又称为长程调度或作业调度，他的调度对象是作业。主要功能是根据某种算法，决定将外存上处于后备队列中的哪几个作业调入内存、为他们创建进程，分配必要的资源，并将他们放入就绪队列。\n    \n2. 低级调度\n    低级调度又称为短程调度或作业调度，他的调度对象是进程。主要功能是根据某种算法，决定就绪队列中哪个进程应获得处理机，并由分派程序将处理机分配给被选中的进程。\n    \n3. 中级调度\n    中级调度又称为内存调度。主要功能是将那些暂时不能运行的进程，调至外存等待，当他们具备运行条件且内存又稍有空闲时再调入内存。\n\n## 5.1.2 处理机调度算法的目标\n\n### 5.1.2.1 处理机调度算法的共同目标\n1. 资源利用率\n    系统中的处理机和其它所有资源应尽可能保持忙碌状态，其中最重要的处理机利用率可用以下方式计算：\n    $$ CPU的利用率=\\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间} $$\n2. 公平性\n    系统中的所有的进程都应该获得合理的CPU时间，不会发生进程饥饿现象。，对同类型的进程获得相同的服务；不同类型的进程，由于紧急程度不同或者重要性不同，应提供不同的服务。\n3. 平衡性\n    系统中可能具有多种类型的进程，有的是计算型作业，有的是I/O型作业。为了使CPU和资源尽可能的处于忙碌状态，调度算法应尽可能的保持系统资源使用的平衡性。\n\n4. 策略强制执行\n    对所定制的策略，只要需要，就必须准确的执行。\n\n### 5.1.2.2 批处理系统的目标\n1. 平均周转时间段\n    周转时间，是指从作业被提交给系统，直到作业执行完毕所花费的时间。\n    对于每个用户来言，都希望自己的周转时间最短；但是对于系统来言，他要求的是平均周转时间最短，这不仅可以提高系统资源的利用率，而且还可使大多数用户都感到满意。\n    可把周转时间描述为：\n    $$ T=\\frac{1}{n}[\\sum_{i=1}^{n}{T_i}] $$\n    为了进一步反应调度的性能，更清楚的描述各进程在其周转时间中，等待和执行时间的具体分配情况，往往使用带权周转时间，即作业周转时间T与系统为他提供的时间Ts之比，即$ W=\\frac{T}{T_s} $，平均带权周转时间可表示为：\n    $$ W = \\frac{1}{n}\\sum_{i=1}^{n}\\frac{T_i}{T_s} $$\n2. 系统吞吐量高\n\n3. 处理机利用率高\n\n### 5.1.2.3 分时系统的目标\n1. 相应事时间快\n    响应时间是指从用户通过键盘提交一个请求开始，直到屏幕上显示出处理结果为之的一段时间间隔，它包括三部分时间：一是请求信息从键盘输入开始，直至将其传送到处理机的时间；二是处理机对请求信息进行处理的时间；三是将所形成的的响应信息回送到终端显示器的时间。\n    \n2. 均衡性\n    用户对响应时间的要求并非完全相同。通常，用户对于复杂的的作业，响应时间允许较长；对于简单的作业，响应时间则要短。\n\n### 5.1.2.4 实时系统的目标\n1. 截止时间的保证\n    截止时间是指某任务必须开始执行的最迟时间，或者必须完成的最迟时间。\n2. 可预测性\n\n\n# 5.2 作业与作业调度\n我们前面讲到过，在多道批处理系统中，作业由用户提交给系统操作员，再由系统操作员把作业输入给相应的输入设备，并保存在一个后备队列中，然后就由作业调度程序将其从外存调入内存再来进行处理。\n\n## 5.2.1 作业\n### 5.2.1.1 作业和作业步\n1. 作业\n    作业一般包括程序还数据，还应配有一份作业说明书，系统根据该说明书来对程序的运行进行控制。\n    \n2. 作业步\n    在作业运行期间，每个作业都必须经过若干个相对独立，又相互关联的顺序加工步骤才能得到结果。我们把其中的每一个加工步骤称为一个作业步。\n\n### 5.2.1.2 作业控制块JCB\n为了管理和调度作业，在多道批处理系统中，为每个作业设置了一个作业控制块JCB，她是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。\n通常内容有作业标识、用户名称、用户账号、作业类型、作业状态、调度信息、资源需求、资源使用情况等。\n\n### 5.2.1.3 作业运行的三个阶段和三种状态\n1. 收容阶段\n    操作员把用户提交的作业通过某种输入方式或SPOOLing系统输入到硬盘上，再为改作业建立PCB，并把它放入作业后备队列中。作业此时的状态为**后备状态**\n2. 运行阶段\n    当作业被作业调度选中后，变为它分配必要的资源和建立进程，并将它放入就绪队列。一个作业从第一次进入就绪状态开始，知道他运行结束前，都处于**运行状态**\n3. 完成阶段\n    当作业运行完成，或者发生异常情况提前结束时，作业便进入完成阶段，相应的作业状态为“完成状态”。\n\n## 5.2.2 作业调度的主要任务\n作业调度的主要任务就是根据JCB中的内容，检查系统中的资源能否满足作业对资源的需求，以及按照一定的调度算法，从外存的后备队列中选取某些作业调入内存。并为它们创建进程、分配必要的资源。然后再将新创建的进程排在就绪队列上等待调度。因此，也把作业调度称为接纳调度。在每次执行作业调度时，都需要做出以下两个决定：\n1. 接纳多少个作业\n    在每一次作业调度时，应当从后备队列中选取多少作业调入内存，取决于多道程序度，即允许多少个作业同时在内存中运行。\n2. 接纳哪些作业\n    选择哪些作业取决于，作业调度采用哪种算法。\n    \n# 5.3 作业调度算法\n## 5.3.1 先来先服务（FCFS）算法算法\n对于这个算法，八个字——简单粗暴，没啥可讲。你来的早我就先服务你，其他人不管再牛逼你来晚了你就是弟弟，你得等我先把前面这位服务好了再来服务你。\n\n## 5.3.2 短作业优先（SJF）调度算法\n对于这个算法，他也是基于先来先服务，只是多了个考虑范围，就是原则上还是先到先服务，但是当服务完一个之后并且还有很多个再等着被服务时，就从中找一个需要服务时间最短的先来服务，服务完他了，在从剩下的找一个最短的来服务。\n这个算法有几个缺点：\n1. 必须预知作业的运行时间\n2. 对长作业很不利\n3. 人机无法交互\n4. 没有考虑作业执行的紧迫感，对急需服务的作业不管\n\n## 5.3.3 优先级调度算法（PSA）\n在优先级算法中，基于作业的紧迫程度，外部会赋予进程的优先级，然后优先级算法就根据算法的优先级，进行调度。算法实质上类似于短作业优先，你甚至可以把短作业优先级算法也看做是优先级算法，只不过他的优先级是作业长短，而优先级调度算法的优先级是进程的紧迫程度。\n\n## 5.3.4 高响应比优先调度算法（HRRN）\nFCFS算法是考虑了作业的等待时间，却忽略的作业的运行时间；而SJF算法是只考虑了作业的运行时间，却忽略了作业的等待时间。高响应比算法是又考虑运行时间又考虑等待时间，因此既能照顾短作业，又不致使长作业的等待时间过长。\n\n他为每个作业引入了一个动态优先级，即优先级是可以改变的，它随着等待时间的延长而增加，这使得长作业的优先级在等待期间不断地增加，等到足够的时间后，必然有机会获得处理机。这个变化规律可描述为：\n$$ 优先级=\\frac{等待时间+要求服务时间}{要求服务时间} $$\n\n由于等待时间与服务时间之和就是系统对该作业的响应时间，故该优先级又相当于响应比$R_p$。所以，优先级又可表示为：$$ R_p=\\frac{等待时间+要求服务时间}{要求服务时间}=\\frac{响应时间}{要求服务时间} $$\n\n从上面可以看出\n1. 如果作业的等待时间相同，则要求服务的时间越短，优先级越高\n2. 当要求服务时间相同时，作业的优先级决定于其等待时间\n3. 对于长作业的优先级，可以随等待时间的增加而提高\n\n# 5.4 进程调度\n## 5.4.1 进程调度的任务、机制和方式\n### 5.4.1.1 进程调度的任务\n1. 保存处理机的现场信息\n    在进行调度时首先需要保存当前进程处理机的现场信息。\n2. 按某种算法选取进程\n    调度程序按某种算法从就绪队列中选取一个进程，将其状态改为运行状态，并准备把处理机分配给他。\n3. 把处理机分配给进程\n    由分派程序把处理器分配给该进程，此时需要将选中进程的进程控制块内有关处理机现场的信息装入处理器相应的各个寄存器中，把处理器的控制权交予该进程，让它从上次的断点处恢复运行。\n    \n### 5.4.1.2 进程调度机制\n为了实现进程调度，在进程调度机制中，应具有如下三个基本部分：\n![进程调度机制](http://cdn.littlecorgi.top/mweb/进程调度机制.jpg)\n1. 排队器\n为了提高进程调度的效率，应事先将系统中的所有就绪进程按照一定的策略排成一个或多个队列，以便调度程序能最快的找到它。\n2. 分派器\n分派器依据进程调度程序所选定的进程，将其从就绪队列中取出，然后进行从分派器到新选出进程间的上下文切换，将处理机分配给新选出的进程。\n3. 上下文切换器\n在对处理机进行切换时，会发生两对上下文的切换操作\n    1. 对上下文切换时，OS将保存当前进程的上下文，即把当前进程的处理机寄存器的内容保存到该进程的进程控制块中的相应单元，再装入分派程序的上下文，以便分派程序运行\n    2. 对上下文切换是移除分派程序的上下文，而把新选进程的CPU现场信息装入到处理机的各个相应寄存器中，以便新选进程运行\n\n### 5.4.1.3 进程调度方式\n 1. 非抢占方式\n     在这种方式下，一旦处理机分派给一个进程后，就一次性一直处理下去，直到该进程被处理完。\n 2. 抢占方式\n     这种调度方式允许调度程序根据某种原则，去暂停某个正在执行的程序，将已分配给该进程的处理机重新分配给另一进程。\n     它遵循的主要原则有：\n     1. 优先权原则，优先级高的新到进程抢占正在运行的优先级低的进程\n     2. 短进程优先原则，需要运行时间更短的新到进程抢占正在运行的需要运行时间更长的进程\n     3. 时间片原则，各进程按时间片轮转运行，当正在执行的进程的一个时间片用完后，便停止该进程的执行而重新进行调度\n\n## 5.4.2 轮转调度算法\n在分时系统中，最常用也是最简单的就是基于时间片的轮转调度算法。该算法采取了非常公平的处理机分配方式，即让就绪队列上每个进程每次仅运行一个时间片。n个进程每个都运行$\\frac{1}{n}$的处理机时间。\n\n### 5.4.2.1 基本原理\n在RR算法中，系统根据FCFS策略，将所有的就绪进程排成一个就绪队列，并可设置每隔一定时间间隔即产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，令其执行。\n\n### 5.4.2.2 进程切换时机\n1. 如果一个时间片尚未用完但是正在运行的进程已经完成，此时可以切换\n2. 在一个时间片用完，正在执行的进程还未执行完成，这时也可以切换\n\n### 5.4.2.3 时间片大小的确定\n在RR算法中，时间片的大小对系统性能有很大的影响。\n如果选择很小的时间片，有利于短作业，因为他能在该时间片内完成，但时间片小，意味着会频繁调度，这无疑会增加系统开销。\n![时间片小于交互时间](http://cdn.littlecorgi.top/mweb/时间片小于交互时间.jpg)\n\n如果时间片选择太长，这样的话RR可能会退化成FCFS，无法满足短作业和交互式用户的需求。\n![时间片大于交互时间](http://cdn.littlecorgi.top/mweb/时间片大于交互时间.jpg)\n\n## 5.4.3 优先级调度算法\n在RR算法中，我们假设了所有进程的紧迫性是相同的，但是实际情况并非如此。我们为了满足实际情况，在进程调度算法中引入了优先级，而形成的优先级调度算法。\n\n### 5.4.3.1 优先级调度算法的类型\n1. 非抢占式优先级调度算法\n2. 抢占式优先级调度算法\n\n这块和前面调度算法方式一样，在此就不多说。\n\n### 5.4.3.2 优先级类型\n#### 5.4.3.2.1 静态优先级\n静态优先级是在创建进程时确定的，在进程的整个运行期间保持不变。优先级是利用某一范围内的一个整数来表示的。确定进程优先级大小的依据有如下三个：\n1. 进程类型，通常系统进程的优先级一般高于用户进程。\n2. 进程对资源的需求，对资源要求较少的进程应赋予较高的优先级。\n3. 用户要求，根据进程的紧迫程度及用户所付费用的多少确定优先级。\n\n静态优先级法简单易行，系统开销小，但是不够精确，可能会出现优先级低的进程长期没有被调度的情况。\n\n#### 5.4.3.2.2 动态优先级\n动态优先级是指进程创建之初，先赋予一个优先级，然后根据进程的推进或等待时间的增加而改变，以便获得更好的调度性能。\n\n## 5.4.4 多队列调度算法\n之前所述的各种调度算法，在应用于进程调度时，由于系统中仅设置一个进程的就绪队列，即低级调度的算法是单一的，固定的，无法满足系统中不同用户对进程调度策略的不同要求，在多处理机系统中，这种单一调度策略实现机制缺点更加明显。因此多级队列算法能够在一定程度上弥补这一缺点。\n\n多级队列算法将进程就绪队列拆分成若干个，不同的就绪队列采用不同的调度算算法，所以可以很好的满足不同用户对进程调度策略的不同需求，同时也可以满足多处理机系统的需求。\n\n## 5.4.5 多级反馈队列调度算法\n前面的算法都有一定的局限性，如果未指明进程长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而下述的多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，还可以很好地满足各种类型进程的需要，因而他是目前公认的一种较好的进程调度算法。\n\n### 5.4.5.1 调度机制\n1. 设置多个就绪队列。在系统中设置多个就绪队列，并未每个队列赋予不同的优先级。第一个队列的优先级最高，第二次之，其余队列的优先级逐个降低。该算法为不同队列中的进程所赋予的执行时间片的大小也不同，在优先级越高的队列中时间片越小。\n   ![多级反馈队列调度算法](http://cdn.littlecorgi.top/mweb/多级反馈队列调度算法.jpg)\n\n2. 每个队列都采用FCFS算法。当新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则等待调度。当轮到该进程时，如他能在时间片内完成，便可撤离系统，否则，他在一个时间片结束还未完成时，转入第二队列末尾等待，依次类推。\n3. 按队列优先级调度，首先调度最高优先级队列中的诸进程运行，仅当第一队列空闲时才调度第二队列。\n\n### 5.4.5.2 调度算法的性能\n在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互系统所需处理时间时，便能较好的满足各种类型用户的需要。 \n\n## 5.4.6 基于公平原则的调度算法\n### 5.4.6.1 保证调度算法\n保证调度算法是另一种类型的调度算法，它想用户所作出的保证并不是优先运行，而是明确的性能保证，该算法可以做到调度的公平性。一种比较容易的性能保证是处理机的公平性，如果在系统中有n个类型相同的进程同时运行，为了公平期间，每个进程都获得相同的处理机时间$\\frac{1}{n}$。\n\n在实施保证调度算法时，系统必须具备这样一些功能：\n\n1. 跟踪计算每个进程自创建以来已经执行的处理时间。\n2. 计算每个进程应获得的处理机时间，即自创建以来的时间除以n。\n3. 计算进程获得处理机时间的比率，即进程实际执行的处理时间和应获得的处理机时间之比。\n4. 比较各进程获得处理机时间的比率。如进程A的比率最低，为0.5，而进程B的比率为0.8，进程C的比率为1.2等。\n5. 调度程序应选择比率最小的进程将处理机分配给它，并让该进程一直运行，直到超过最接近它的进程比率为止。\n\n### 5.4.6.2 公平分享调度算法\n分配给每个进程相同的处理机时间，显然，这对诸进程而言，是体现了一定程度的公平，但如果各个用户所拥有的进程数不同，就会发生对用户的不公平问题。 在该算法中，调度的公平性是体针对于用户而言。使所有的用户获得相同的处理机时间，或要求的时间比例。\n\n# 5.5 实时调度\n## 5.5.1 实现实时调度的基本条件\n1. 提供必要的信息\n    1. 就绪时间，是指某任务称为就绪状态的时间，在周期任务的情况下，她是实现预知的一串时间序列。\n    2. 开始截止时间和完成截止时间，对于典型的实时应用，只需知道开始截止时间或者完成截止时间\n    3. 处理时间，一个任务从开始执行，直至完成时所需的时间\n    4. 资源要求，任务执行时所需要的一组资源\n    5. 优先级，如果某任务的开始截止时间错过，势必引起故障，则应为该任务赋予“绝对”优先级；如果其开始截止时间的错过，对任务的继续运行无重大影响，则可为其赋予“相对优先级”，供调度程序参考\n2. 系统处理能力强\n    在实时系统中，若处理机的处理能力不够强，则有可能因处理机忙不过，而致使某些实时任务不能得到及时处理，从而导致发生难以预料的后果。\n    假定系统中有m个周期性的硬实时任务HRT，他们的处理时间可表示为$C_i$，周期时间表示为$P_i$，则在单处理机情况下，必须满足下面的限制条件系统才是可调度的：$$ \\sum_{i=1}^{m}\\frac{C_i}{P_i}\\le1 $$\n    提高系统处理能力的途径有二：一是采用单处理机系统，但须增强其处理能力，以显著地减少对每一个任务的处理时间；二是采用多处理机系统。假定系统中的处理机数为N，则应将上述的限制条件改为：$$ \\sum_{i=1}^{m}\\frac{C_i}{P_i}\\le N $$\n3. 采用抢占式调度机制\n    在含有HRT任务的实时系统中，广泛采用抢占机制。这样便可满足HRT任务对截止时间的要求。但这种调度机制比较复杂。 对于一些小的实时系统，如果能够预知任务法开始截止时间，则对于实时任务的调度可以采用非抢占式调度。\n4. 具有快速切换机制\n    为保证硬实时任务能及时运行，在系统中还应具有快速切换机制，使之能进行任务的快速切换。该机制应具有如下两方面的能力：\n    2. 对中断的快速响应能力。对紧迫的外部事件请求中断能及时响应，要求系统具有快速硬件中断机构，还应使禁止中断的时间间隔尽量短，以免耽误时机(其它紧迫任务)。\n    3. 快速的任务分派能力。为了提高分派程序进行任务切换时的速度，应使系统中的每个运行功能单位适当的小，以减少任务切换的时间开销。\n\n## 5.5.2 实时调度算法的分类\n### 5.5.2.1 非抢占式调度算法\n1. 非抢占式轮转调度算法\n    由一台计算机控制若干个相同的对象，为每个被控对象建立一个实时任务。并将他们排成一个轮转队列。调度程序每次选择队列中的第一个任务投入运行，当该任务完成后，便把它挂在轮转队列的末尾等待，调度程序再选择下一个队首任务运行。\n\n2. 非抢占式优先调度算法\n    如果在系统中还含有少数具有一定要求的实时任务，则可采用非抢占式优先调度算法，系统为这些任务赋予了较高的优先级。当这些实时任务到达时，把它们安排在就绪队列的队首，等待当前任务自我终止或运行完成后，便可去调度执行队首的高优先级进程。\n\n### 5.5.2.2 抢占式调度算法\n1. 基于时钟中断的抢占式优先级调度算法。\n    在某实时任务到达后，如果他的优先级高于当前任务的优先级，这是并不立即抢占当前任务的处理机，而是等到时钟中断发生时，调度程序才剥夺大年任务的执行，把处理机分配给新到的高优先级的任务。\n\n2. 立即抢占的优先级调度算法。\n    在这种调度策略中，要求操作系统具有快速响应外部事件中断的能力，一旦出现外部中断，只要当前任务未处于临界区，便能立即剥夺当前任务的执行，把处理机分配给请求中断的紧迫任务。\n    ![实时进程调度](http://cdn.littlecorgi.top/mweb/实时进程调度.png)\n\n\n## 5.5.3 最早截止时间优先\n该算法是根据任务截止时间确定任务的优先级，任务的截止时间越早，其优先级越高，具有最早截止时间的任务排在队首。\n\n### 5.5.3.1 非抢占式调度方式用于非周期实时任务\n![EDF算法用于非抢占式调度方法](http://cdn.littlecorgi.top/mweb/EDF算法用于非抢占式调度方法.jpg)\n\n### 5.5.3.2 抢占式调度方式用于非周期实时任务\n![最早截止时间优先算法用于抢占调度方式之例](http://cdn.littlecorgi.top/mweb/最早截止时间优先算法用于抢占调度方式之例.png)\n\n## 5.5.4 最低松弛度优先LLF算法\n该算法在确定任务的优先级时，根据的是任务的紧急(或松弛)程度。任务紧急程度愈高，赋予该任务的优先级就愈高，以使之优先执行。 \u000b该方式主要用可抢占式调度。\n\n假如在一个实时系统中有两个周期性实时任务A和B，任务A要求每20 ms执行一次，执行时间为10 ms，任务B要求每50 ms执行一次，执行时间为25 ms。由此可知，任务A和B每次必须完成的时间分别为：A1、A2、A3、…和B1、B2、B3、…，如下图\n![A任务和B任务每次必须完成的时间](http://cdn.littlecorgi.top/mweb/A任务和B任务每次必须完成的时间.png)\n\n利用ELLF算法进行调度的情况：\n![利用ELLF算法进行调度的情况](http://cdn.littlecorgi.top/mweb/利用ELLF算法进行调度的情况.png)\n","tags":["操作系统"],"categories":["操作系统"]},{"title":"Android网络请求1--HttpClient与HttpURLConnection","url":"/posts/eb898689.html","content":"在早期的时候，Android上还没有像`Volley`、`OkHttp`、`Retrofit`这些优秀的开源库，如果想要使用网络请求的话，就只能自己封装`HttpClient`和`HttpURLConnection`。现在我们就来看下`Apache`的这两个类。\n<!-- More -->\n\n# 1. HttpClient\n\n## 2.1 导入HttpClient\n由于从Android 6.0 开始，谷歌就将HttpClient从Android中删除了，所以若现在想使用他，还得导入依赖：\n在项目的`build.gradle`的`Android`代码块下加入依赖，示例：\n```java\nandroid {\n    useLibrary 'org.apache.http.legacy'\n    ...\n}\n```\n## 2.2 HttpClient的Get\n首先通过`DefaultHttpClient`来实例化一个`HttpClient`，并配置好参数：\n```java\n //创建HttpClient\nprivate HttpClient createHttpClient() {\n    HttpParams mDefaultHttpParams = new BasicHttpParams();\n    //设置连接超时\n    HttpConnectionParams.setConnectionTimeout(mDefaultHttpParams, 15000);\n    //设置请求超时\n    HttpConnectionParams.setSoTimeout(mDefaultHttpParams, 15000);\n    HttpConnectionParams.setTcpNoDelay(mDefaultHttpParams, true);\n    HttpProtocolParams.setVersion(mDefaultHttpParams, HttpVersion.HTTP_1_1);\n    HttpProtocolParams.setContentCharset(mDefaultHttpParams, HTTP.UTF_8);\n    //持续握手\n    HttpProtocolParams.setUseExpectContinue(mDefaultHttpParams, true);\n    HttpClient mHttpClient = new DefaultHttpClient(mDefaultHttpParams);\n    return mHttpClient;\n}\n```\n接着创建`HttpGet`和`HttpClient`，请求网络并得到`HttpResponse`，并对`HttpResponse`进行处理：\n```java\nprivate void useHttpClientGet(String url) {\n    HttpGet mHttpGet = new HttpGet(url);\n    mHttpGet.addHeader(\"Connection\", \"Keep-Alive\");\n    try {\n        HttpClient mHttpClient = createHttpClient();\n        HttpResponse mHttpResponse = mHttpClient.execute(mHttpGet);\n        HttpEntity mHttpEntity = mHttpResponse.getEntity();\n        int code = mHttpResponse.getStatusLine().getStatusCode();\n        if (null != mHttpEntity) {\n            InputStream mInputStream = mHttpEntity.getContent();\n            String respose = converStreamToString(mInputStream);\n            Log.i(\"wangshu\", \"请求状态码:\" + code + \"\\n请求结果:\\n\" + respose);\n            mInputStream.close();\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n`converStreamToString()`方法将请求结果转换成`String`类型：\n```java\nprivate String converStreamToString(InputStream is) throws IOException {\n    BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n    StringBuffer sb = new StringBuffer();\n    String line = null;\n    while ((line = reader.readLine()) != null) {\n        sb.append(line + \"\\n\");\n    }\n    String respose = sb.toString();\n    return respose;\n}\n```\n最后开启线程访问:\n```java\nnew Thread(new Runnable() {\n    @Override\n    public void run() {\n        useHttpClientGet(\"http://www.baidu.com\");\n    }\n}).start();\n```\n## 1.3 HttpClient的POST\n和GET差不多，只需要修改传递的参数：\n```java\nprivate void useHttpClientPost(String url) {\n    HttpPost mHttpPost = new HttpPost(url);\n    mHttpPost.addHeader(\"Connection\", \"Keep-Alive\");\n    try {\n        HttpClient mHttpClient = createHttpClient();\n        List<NameValuePair> postParams = new ArrayList<>();\n        //要传递的参数\n        postParams.add(new BasicNameValuePair(\"username\", \"moon\"));\n        postParams.add(new BasicNameValuePair(\"password\", \"123\"));\n        mHttpPost.setEntity(new UrlEncodedFormEntity(postParams));\n        HttpResponse mHttpResponse = mHttpClient.execute(mHttpPost);\n        HttpEntity mHttpEntity = mHttpResponse.getEntity();\n        int code = mHttpResponse.getStatusLine().getStatusCode();\n        if (null != mHttpEntity) {\n            InputStream mInputStream = mHttpEntity.getContent();\n            String respose = converStreamToString(mInputStream);\n            Log.i(\"wangshu\", \"请求状态码:\" + code + \"\\n请求结果:\\n\" + respose);\n            mInputStream.close();\n        }\n    } catch (IOException e) {\n            e.printStackTrace();\n    }\n}\n```\n\n# 2. HttpURLConnection\n`HttpURLConnection`较`HttpClient`来说更轻量，而且他`API`也比`HttpClient`简单。特别是`Android 6.0`将`HttpClient`移除之后，现在只能使用`HttpURLConnection`。\n## 2.1 HttpURLConnection的POST请求\n首先我们创建一个UrlConnManager类，然后里面提供getHttpURLConnection()方法用于配置默认的参数并返回HttpURLConnection：\n```java\npublic static HttpURLConnection getHttpURLConnection(String url){\n    HttpURLConnection mHttpURLConnection=null;\n    try {\n        URL mUrl=new URL(url);\n        mHttpURLConnection=(HttpURLConnection)mUrl.openConnection();\n        //设置链接超时时间\n        mHttpURLConnection.setConnectTimeout(15000);\n        //设置读取超时时间\n        mHttpURLConnection.setReadTimeout(15000);\n        //设置请求参数\n        mHttpURLConnection.setRequestMethod(\"POST\");\n        //添加Header\n        mHttpURLConnection.setRequestProperty(\"Connection\",\"Keep-Alive\");\n        //接收输入流\n        mHttpURLConnection.setDoInput(true);\n        //传递参数时需要开启\n        mHttpURLConnection.setDoOutput(true);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    return mHttpURLConnection ;\n}\n```\n因为我们要发送POST请求，所以在UrlConnManager类中再写一个postParams()方法用来组织一下请求参数并将请求参数写入到输出流中：\n```java\npublic static void postParams(OutputStream output,List<NameValuePair>paramsList) throws IOException{\n    StringBuilder mStringBuilder=new StringBuilder();\n    for (NameValuePair pair:paramsList){\n        if(!TextUtils.isEmpty(mStringBuilder)){\n            mStringBuilder.append(\"&\");\n        }\n        mStringBuilder.append(URLEncoder.encode(pair.getName(),\"UTF-8\"));\n        mStringBuilder.append(\"=\");\n        mStringBuilder.append(URLEncoder.encode(pair.getValue(),\"UTF-8\"));\n    }\n    BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(output,\"UTF-8\"));\n    writer.write(mStringBuilder.toString());\n    writer.flush();\n    writer.close();\n}\n```\n接下来我们添加请求参数，调用postParams()方法将请求的参数组织好传给HttpURLConnection的输出流，请求连接并处理返回的结果：\n```java\nprivate void useHttpUrlConnectionPost(String url) {\n    InputStream mInputStream = null;\n    HttpURLConnection mHttpURLConnection = UrlConnManager.getHttpURLConnection(url);\n    try {\n        List<NameValuePair> postParams = new ArrayList<>();\n        //要传递的参数\n        postParams.add(new BasicNameValuePair(\"username\", \"moon\"));\n        postParams.add(new BasicNameValuePair(\"password\", \"123\"));\n        UrlConnManager.postParams(mHttpURLConnection.getOutputStream(), postParams);\n        mHttpURLConnection.connect();\n        mInputStream = mHttpURLConnection.getInputStream();\n        int code = mHttpURLConnection.getResponseCode();\n        String respose = converStreamToString(mInputStream);\n        Log.i(\"wangshu\", \"请求状态码:\" + code + \"\\n请求结果:\\n\" + respose);\n        mInputStream.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n最后开启线程请求网络：\n```java\nprivate void useHttpUrlConnectionGetThread() {\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            useHttpUrlConnectionPost(\"http://www.baidu.com\");\n        }\n    }).start();\n}\n```","tags":["Android","源码","kotlin","Volley"],"categories":["Android"]},{"title":"ijkPlayer编译-Android","url":"/posts/d61d5542.html","content":"# 1. 简介\nijkplayer是哔哩哔哩的一个开源视频播放框架，支持Android、iOS。底层是ffplay。\n\nGithub地址：[bilibili/ijkplayer](https://github.com/bilibili/ijkplayer)\n<!-- More -->\n\n# 2. 编译方法\n由于通过Gradle编译起来很慢而且一旦失败又得重头来，所以这块就使用AndroidNDK的方式来编译。\n\n## 2.1 编译之前\n首先你得配置好等会编译需要的东西。这块我们都会使用[Homebrew](https://brew.sh/index_zh-cn)来安装git和yasm。\nHomebrew类似于Ubuntu的dpkg、RedHat和centOS的yum，他是macOS上的一个软件包管理器。但是后来出了Linux版。\n由于ijkplayer官方说用的它，那咱们就用它吧。\n\n### Ubuntu\n#### 1. 先把目前已有的包更新\n```bash\n// 从镜像站下载软件列表，并检查有没有需要更新的包\nsudo apt update\n\n// 更新需要更新的包\nsudo apt upgrade\n\n// 自动卸载掉当初为了安装其他软件或其他原因而安装但是目前已经没用的包\nsudo apt autoremove\n```\n\n#### 2. 安装Homebrew\n\n\n```bash\n1. 首先确定是否安装ruby  \n    apt install ruby'\n    \n2. 然后通过ruby安装Homebrew  \n    ruby -c \"$(curl -fsSL https://raw.githubusercontent.com/Linuxbrew/install/master/install.sh)\"\n    \n3. 再通过Homebrew安装git和yasm\n    brew install git\n    brew install yasm\n```\n\n#### 3. 配置Android SDK和NDK\n1. Android SDK\n    你可以打开你的AndroidStudio，进入`Preferences -> Appearance & Behavior -> System Settings -> Android SDK`。这块就会显示你SDK安装目录。\n    然后在终端中输入`vim ~/.bash_profile`。然后输入以下内容：\n    \n    ```bash\n    export ANDROID_SDK_HOME=AndroidSDK的目录/android-sdk-linux\n    export PATH=$PATH:${ANDROID_SDK_HOME}/tools\n    export PATH=$PATH:${ANDROID_SDK_HOME}/platform-tools\n    ```\n    保存，然后再在终端输入`source ~/.bash_profile`，就可以了。\n2. Android NDK\n    首先你得到官网下载NDK：[NDK 归档](https://developer.android.com/ndk/downloads/older_releases.html?hl=zh-cn)。而且你只能下载r10e版本的，下载其它版本编译会报错。\n    下载下来解压后，同样和上面一样得配置环境变量：\n    \n    ```bash\n    export ANDROID_NDK_HOME=NDK目录\n    export PATH=$PATH:${ANDROID_SDK_HOME}\n    ```\n    保存，然后再在终端输入`source ~/.bash_profile`，就可以了。\n\n### macOS\n安装Homebrew，由于macOS自带ruby，所以我们直接可以开始安装Homebrew。\n```bash\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\nbrew install git\nbrew install yasm\n```\n然后就是配置你的Android SDK和Android NDK：\n和上面Ubuntu下一样。\n\n## 2.2 编译Android\n\n```bash\ngit clone https://github.com/Bilibili/ijkplayer.git ijkplayer-android\ncd ijkplayer-android\ngit checkout -B latest k0.8.8\n\n./init-android.sh\n\ncd android/contrib\n./compile-ffmpeg.sh clean\n// 这步特慢，耗时很长\n./compile-ffmpeg.sh all\n\ncd ..\n./compile-ijk.sh all\n```\n上面这些执行完就可以了。\n然后你就能在你的`/ijkplayer-android/android/ijkplayer`路径下就能看到编译后的项目了，其中每个`module的/src/mian/libs`里面就是so文件。\n\n# 3. 最后\n你可以直接通过AndroidStudio打开`/ijkplayer-android/android/ijkplayer`，然后在里面的`/ijkplayer-example`下谢你自己的代码就可以了。","tags":["Android","ijkplayer","音视频"],"categories":["Android"]},{"title":"Android网络请求4--解析Retrofit源码","url":"/posts/a2a8de56.html","content":"# 1. Retrofit简介\n- [Retrofit - github](https://github.com/square/retrofit)\n- [Retrofit - Doc](https://square.github.io/retrofit/)\n\n`Retrofit`是Square公司的又一力作，针对Android网络请求的框架，遵循`Restful`设计风格，底层基于`OkHttp`。\n<!-- More -->\n\n他对比其他框架\n- 性能最好\n- 封装程度高，拓展性差\n- 简介易用，代码简单\n- 解耦彻底\n- 可以非常方便的与RxJava连用\n\n# 2. Retrofit用法（异步）\n## 2.1 添加依赖\n可以在Retrofit Github库页面里面找到最新版本号，我写这篇博客时最新版导入方式\n\n在你项目的app的`build.gradle`里面添加\n`implementation 'com.squareup.retrofit2:retrofit:2.6.1'`\n\n同时，如果你需要配套的数据转换器还需要导入以下的依赖\n- Gson: `com.squareup.retrofit2:converter-gson`\n- Jackson: `com.squareup.retrofit2:converter-jackson`\n- Moshi: `com.squareup.retrofit2:converter-moshi`\n- Protobuf: `com.squareup.retrofit2:converter-protobuf`\n- Wire: `com.squareup.retrofit2:converter-wire`\n- Simple XML: `com.squareup.retrofit2:converter-simplexml`\n- Scalars (primitives, boxed, and String): `com.squareup.retrofit2:converter-scalars`\n\n## 2.2 添加网络权限\n在你APP的AndroidManifest.xml里添加\n`<uses-permission android:name=\"android.permission.INTERNET\"/>\n`\n\n## 2.3 创建 接收服务器返回数据 的类\n*Reception.java*\n```java\npuublic class Reception {\n    // 根据返回数据的格式和数据解析方式定义\n    ...\n}\n```\n\n## 2.4 创建 用于描述网络请求 的接口\n*GetRequest_Interface.interface*\n```java\npublic interface GetRequest_Interface {\n    @GET(\"openapi.do?keyfrom=Yanzhikai&key=2032414398&type=data&doctype=json&version=1.1&q=car\")\n    Call<Translation>  getCall();\n    // @GET注解的作用:采用Get方法发送网络请求\n \n    // getCall() = 接收网络请求数据的方法\n    // 其中返回类型为Call<*>，*是接收数据的类（即上面定义的Translation类）\n    // 如果想直接获得Responsebody中的内容，可以定义网络请求返回值为Call<ResponseBody>\n}\n```\n\n## 2.5 创建Retrofit实例\n```java\n Retrofit retrofit = new Retrofit.Builder()\n                .baseUrl(\"http://fanyi.youdao.com/\") // 设置网络请求的Url地址\n                .addConverterFactory(GsonConverterFactory.create()) // 设置数据解析器\n                .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) // 支持RxJava平台\n                .build();\n```\n\n## 2.6 创建网络请求接口实例\n```java\n// 创建 网络请求接口 的实例\nGetRequest_Interface request = retrofit.create(GetRequest_Interface.class);\n\n//对 发送请求 进行封装\nCall<Reception> call = request.getCall();\n```\n\n## 2.7 发送网络请求\n```java\n//发送网络请求(异步)\ncall.enqueue(new Callback<Translation>() {\n    //请求成功时回调\n    @Override\n    public void onResponse(Call<Translation> call, Response<Translation> response) {\n        //请求处理,输出结果\n        response.body().show();\n    }\n\n    //请求失败时候的回调\n    @Override\n    public void onFailure(Call<Translation> call, Throwable throwable) {\n        System.out.println(\"连接失败\");\n    }\n});\n```\n\n## 2.8 处理返回数据\n```java\n//发送网络请求(异步)\ncall.enqueue(new Callback<Translation>() {\n    //请求成功时回调\n    @Override\n    public void onResponse(Call<Translation> call, Response<Translation> response) {\n        // 对返回数据进行处理\n        response.body().show();\n    }\n\n    //请求失败时候的回调\n    @Override\n    public void onFailure(Call<Translation> call, Throwable throwable) {\n        System.out.println(\"连接失败\");\n    }\n});\n```\n\n由于本文的核心不是讲用法，所以关于用法这块，我并没有多讲，大家若想多了解，可以看此博客：[这是一份很详细的 Retrofit 2.0 使用教程（含实例讲解）](https://blog.csdn.net/carson_ho/article/details/73732076)\n\n# 3. Retrofit源码\n## 3.1 Retrofit对象构造源码\n应对一个框架的源码首先从使用它的地方开始，我们先来看`Retrofit`的创建代码：\n```java\n Retrofit retrofit = new Retrofit.Builder()\n        .baseUrl(\"http://fanyi.youdao.com/\")\n        .addConverterFactory(GsonConverterFactory.create())\n        .build();\n```\n\n我们可以把它分为5个部分来分析源码：\n![源码分析步骤](https://user-gold-cdn.xitu.io/2018/3/7/161fdeda6c0120c1?imageslim)\n\n我们首先来看第一步\n\n### 3.1.1 步骤1：Retrofit类\n```java\npublic final class Retrofit {\n    private final Map<Method, ServiceMethod<?>> serviceMethodCache = new ConcurrentHashMap<>();\n  \n    // 网络请求工厂\n    final okhttp3.Call.Factory callFactory;\n    // 请求的Url地址\n    final HttpUrl baseUrl;\n    // 数据转换器工厂的集合\n    final List<Converter.Factory> converterFactories;\n    // 网络请求适配器工厂的集合\n    final List<CallAdapter.Factory> callAdapterFactories;\n    // 回调\n    final @Nullable Executor callbackExecutor;\n    // 是否提前对业务接口中的注解进行验证转换的标志位\n    final boolean validateEagerly;\n\n    Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,\n        List<Converter.Factory> converterFactories, List<CallAdapter.Factory> callAdapterFactories,\n        @Nullable Executor callbackExecutor, boolean validateEagerly) {\n        this.callFactory = callFactory;\n        this.baseUrl = baseUrl;\n        this.converterFactories = converterFactories; // Copy+unmodifiable at call site.\n        this.callAdapterFactories = callAdapterFactories; // Copy+unmodifiable at call site.\n        this.callbackExecutor = callbackExecutor;\n        this.validateEagerly = validateEagerly;\n    }\n    ...// 省略后面的代码\n}\n```\n可以看到，`Retrofit`的构造方法需要一次性把需要的数据全部准备好。\n而且这块有特别多的工厂，使用了工厂模式。这个我们之后再讲，接下来看步骤2：\n\n### 3.1.2 步骤2：Builder()方法\n我们先来看下`Builder()`方法的源码：\n```java\npublic Builder() {\n    this(Platform.get());\n}\n```\n\n这里调用了`Rlatform.get()`方法：\n```java\nstatic Platform get() {\n    return PLATFORM;\n}\n```\n\n`PLATFORM`的定义就在上面：\n```java\nprivate static final Platform PLATFORM = findPlatform();\n```\n\n我们再来看下`findPlatform()`方法：\n```java\nprivate static Platform findPlatform() {\n    try {\n        Class.forName(\"android.os.Build\");\n        if (Build.VERSION.SDK_INT != 0) {\n            return new Android();\n        }\n    } catch (ClassNotFoundException ignored) {\n    }\n    return new Platform(true);\n}\n```\n\n这块创建了一个`Android`对象，接着返回了传入`true`创建的`Platform`对象。我们再来看下`Android`类：\n```java\nstatic final class Android extends Platform {\n    Android() {\n        super(Build.VERSION.SDK_INT >= 24);\n    }\n\n    @Override public Executor defaultCallbackExecutor() {\n        // 返回一个默认的回调方法执行器\n        // 该执行器作用：切换线程（子->>主线程），并在主线程（UI线程）中执行回调方法\n        return new MainThreadExecutor();\n    }\n\n    static class MainThreadExecutor implements Executor {\n        // 获取与Android 主线程绑定的Handler \n        private final Handler handler = new Handler(Looper.getMainLooper());\n\n        @Override public void execute(Runnable r) {\n            // 该Handler是上面获取的与Android 主线程绑定的Handler \n            // 在UI线程进行对网络请求返回数据处理等操作。\n            handler.post(r);\n        }\n    }\n}\n```\n\n### 3.1.3 步骤3：baseUrl()方法\n```java\npublic Builder baseUrl(String baseUrl) {\n    Objects.requireNonNull(baseUrl, \"baseUrl == null\");\n    return baseUrl(HttpUrl.get(baseUrl));\n}\n```\n\n最后还是调用了一个`baseUrl()`方法，我们来看看这个`baseUrl()`方法：\n```java\npublic Builder baseUrl(HttpUrl baseUrl) {\n    Objects.requireNonNull(baseUrl, \"baseUrl == null\");\n    // 把URL参数分割成几个路径碎片\n    List<String> pathSegments = baseUrl.pathSegments();\n    // 检测最后一个碎片来检查URL参数是不是以\"/\"结尾,不是就抛出异常\t\n    if (!\"\".equals(pathSegments.get(pathSegments.size() - 1))) {\n        throw new IllegalArgumentException(\"baseUrl must end in /: \" + baseUrl);\n    }\n    this.baseUrl = baseUrl;\n    return this;\n}\n```\n步骤3用于设置网络请求的`Url`\n\n### 3.1.4 步骤4：addConverterFactory()方法\n我们先来看看`GsonConverterFactory.create()`方法：\n```java\npublic static GsonConverterFactory create() {\n    return create(new Gson());\n}\n```\n\n又调用了另一个`create()`方法：\n```java\npublic static GsonConverterFactory create(Gson gson) {\n    if (gson == null) throw new NullPointerException(\"gson == null\");\n    return new GsonConverterFactory(gson);\n}\n```\n\n如果传入的`gson`为空就报异常，不为空就调用`GsonConverterFactory`的构造方法：\n```java\nprivate GsonConverterFactory(Gson gson) {\n    this.gson = gson;\n}\n```\n\n所以这个方法本质就是返回了一个`gson`对象给了`addConverterFactory()`方法，那我们再来看看这个方法：\n```java\n/** 为对象的序列化和反序列化添加转换器工厂。 */\npublic Builder addConverterFactory(Converter.Factory factory) {\n    converterFactories.add(Objects.requireNonNull(factory, \"factory == null\"));\n    return this;\n}\n```\n步骤4创建了一个含有`Gson`实例的`GsonConverterFactory`对象，并放入了`ConverterFactory`。\n\n### 3.1.5 步骤5：build()方法\n```java\npublic Retrofit build() {\n    if (baseUrl == null) {\n        throw new IllegalStateException(\"Base URL required.\");\n    }\n    // 配置网络请求执行器\n    okhttp3.Call.Factory callFactory = this.callFactory;\n    // 如果没有指定callFactory，则创建OkHttpClient\n    if (callFactory == null) {\n        callFactory = new OkHttpClient();\n    }\n    // 配置回调执行器\n    Executor callbackExecutor = this.callbackExecutor;\n    if (callbackExecutor == null) {\n        callbackExecutor = platform.defaultCallbackExecutor();\n    }\n\n    // 配置网络请求适配器工厂\n    List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>(this.callAdapterFactories);\n    callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));\n\n    // 配置数据转换器工厂\n    List<Converter.Factory> converterFactories = new ArrayList<>(\n        1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());\n\n    // 首先添加内置转换器工厂。这可以防止重写它的行为，但也可以确保在使用使用使用所有类型的转换器时正确的行为。\n    converterFactories.add(new BuiltInConverters());\n    converterFactories.addAll(this.converterFactories);\n    converterFactories.addAll(platform.defaultConverterFactories());\n\n    return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),\n        unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);\n}\n```\n按前面配置的变量，将`Retrofit`所有的变量都配置好，最后完成创建`Retrofit`实例。\n\n到这Retrofit的创建部分就完了。\nRetrofit通过建造者模式创建了一个Retrofit实例：\n- 请求工厂callFactory：默认是OkHttpClient\n- 数据转换器工厂converterFactories\n- 网络请求适配器工厂callAdapterFactories：默认是ExecutorCallAdapterFactory\n- 回调执行器callbackExecutor\n\n![Retrofit对象构建流程](http://cdn.littlecorgi.top/mweb/Retrofit对象构建流程.jpg)\n\n\n## 3.2 创建网络请求接口的实例\n大致创建方法如下：\n```java\n<!-- Reception.java -->\npuublic class Reception {\n    // 根据返回数据的格式和数据解析方式定义\n    ...\n}\n\n<!-- GetRequest_Interface.interface -->\npublic interface GetRequest_Interface {\n    @GET(\"openapi.do?keyfrom=Yanzhikai&key=2032414398&type=data&doctype=json&version=1.1&q=car\")\n    Call<Translation>  getCall();\n    // @GET注解的作用:采用Get方法发送网络请求\n \n    // getCall() = 接收网络请求数据的方法\n    // 其中返回类型为Call<*>，*是接收数据的类（即上面定义的Translation类）\n    // 如果想直接获得Responsebody中的内容，可以定义网络请求返回值为Call<ResponseBody>\n}\n\n<!-- MainActivity.java -->\n// 创建 网络请求接口 的实例\nGetRequest_Interface request = retrofit.create(GetRequest_Interface.class);\n//对 发送请求 进行封装\nCall<Reception> call = request.getCall();\n```\n\n我们先看看`retrofit.create()`干了啥：\n```java\npublic <T> T create(final Class<T> service) {\n    validateServiceInterface(service);\n    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },\n        new InvocationHandler() {\n            private final Platform platform = Platform.get();\n            private final Object[] emptyArgs = new Object[0];\n\n            @Override public @Nullable Object invoke(Object proxy, Method method,\n                    @Nullable Object[] args) throws Throwable {\n                // 如果该方法是来自对象的方法，则推迟到正常调用。\n                if (method.getDeclaringClass() == Object.class) {\n                    return method.invoke(this, args);\n                }\n                if (platform.isDefaultMethod(method)) {\n                    return platform.invokeDefaultMethod(method, service, proxy, args);\n                }\n                return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);\n            }\n        });\n}\n```\n首先调用了`validateServiceInterface()`这个方法，我们来看看这个方法：\n```java\nprivate void validateServiceInterface(Class<?> service) {\n    // 如果不是接口就抛异常\n    if (!service.isInterface()) {\n        throw new IllegalArgumentException(\"API declarations must be interfaces.\");\n    }\n\n    // 构造了一个容量下限为1的空双向队列来存储数据\n    Deque<Class<?>> check = new ArrayDeque<>(1);\n    // 添加到队列\n    check.add(service);\n    while (!check.isEmpty()) {\n        // 将队列的正向第一个元素移除\n        Class<?> candidate = check.removeFirst();\n        // getTypeParameters()的作用是得到泛型类型，如果泛型的数量不为0的话进入\n        if (candidate.getTypeParameters().length != 0) {\n            StringBuilder message = new StringBuilder(\"Type parameters are unsupported on \")\n                .append(candidate.getName());\n            if (candidate != service) {\n                message.append(\" which is an interface of \")\n                    .append(service.getName());\n            }\n            throw new IllegalArgumentException(message.toString());\n        }\n        Collections.addAll(check, candidate.getInterfaces());\n    }\n\n    if (validateEagerly) {\n        Platform platform = Platform.get();\n        for (Method method : service.getDeclaredMethods()) {\n            if (!platform.isDefaultMethod(method) && !Modifier.isStatic(method.getModifiers())) {\n                loadServiceMethod(method);\n            }\n        }\n    }\n}\n```\n获取到`Platform`（平台），然后再遍历接口中的方法，调用`loadServiceMethod()`方法：\n```java\nServiceMethod<?> loadServiceMethod(Method method) {\n    ServiceMethod<?> result = serviceMethodCache.get(method);\n    if (result != null) return result;\n\n    synchronized (serviceMethodCache) {\n        result = serviceMethodCache.get(method);\n        if (result == null) {\n            result = ServiceMethod.parseAnnotations(this, method);\n            serviceMethodCache.put(method, result);\n        }\n    }\n    return result;\n}\n```\n这个方法主要就是通过`serviceMethodCache`来存储转换为`ServiceMethod`类型的`Method`。\n\n那我们在回过去看`InvocationHandler`的`invoke()`方法。\n```java\nnew InvocationHandler() {\n    private final Platform platform = Platform.get();\n    private final Object[] emptyArgs = new Object[0];\n\n    @Override public @Nullable Object invoke(Object proxy, Method method,\n            @Nullable Object[] args) throws Throwable {\n        // 如果该方法是来自对象的方法，则推迟到正常调用。\n        if (method.getDeclaringClass() == Object.class) {\n            return method.invoke(this, args);\n        }\n        if (platform.isDefaultMethod(method)) {\n            return platform.invokeDefaultMethod(method, service, proxy, args);\n        }\n        return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);\n    }\n});\n```\n两个if先不管，先看最后的`return`，可以看到他调用了一个`loadServiceMethod()`方法，而这个方法在前面就说过，主要就返回了一个`ServiceMethod`。那我们接着来看`invoke()`方法：\n按住`command+鼠标左键`进入后，显示的是：\n```java\nabstract class ServiceMethod<T> {\n  static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {\n    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);\n\n    Type returnType = method.getGenericReturnType();\n    if (Utils.hasUnresolvableType(returnType)) {\n      throw methodError(method,\n          \"Method return type must not include a type variable or wildcard: %s\", returnType);\n    }\n    if (returnType == void.class) {\n      throw methodError(method, \"Service methods cannot return void.\");\n    }\n\n    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);\n  }\n\n  abstract @Nullable T invoke(Object[] args);\n}\n```\n这个`invoke()`根本就是个抽象方法啊，然后我又回去找看看有没有说是哪个继承自`ServiceMethod`的类实现了这个方法，结果也没找到，最后想到了AndroidStudio可以`command+左键`找实现了这个类的地方啊。于是我就点了下这个类，结果成功找到了`HttpServiceMethod`这个类，他是`ServiceMethod`的子类中唯一一个实现了`invoke()`方法的：\n```java\n@Override final @Nullable ReturnT invoke(Object[] args) {\n    Call<ResponseT> call = new OkHttpCall<>(requestFactory, args, callFactory, responseConverter);\n    return adapt(call, args);\n}\n```\n\n可以看到这块他创建了一个OkHttpCall对象，此处不做详解，可以看我关于OkHttp的一篇博客：[Android网络请求3--解析OkHttp源码](https://www.littlecorgi.top/posts/151ac78a.html)。然后调用了adapt方法，我们来看看这个方法:\n```java\nprotected abstract @Nullable ReturnT adapt(Call<ResponseT> call, Object[] args);\n```\n这又是一个抽象方法。只不过好的是，这个方法下面我们就找到了他的实现：\n```java\nstatic final class CallAdapted<ResponseT, ReturnT> extends HttpServiceMethod<ResponseT, ReturnT> {\n    private final CallAdapter<ResponseT, ReturnT> callAdapter;\n\n    CallAdapted(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,\n            Converter<ResponseBody, ResponseT> responseConverter,\n            CallAdapter<ResponseT, ReturnT> callAdapter) {\n        super(requestFactory, callFactory, responseConverter);\n        this.callAdapter = callAdapter;\n    }\n\n    @Override protected ReturnT adapt(Call<ResponseT> call, Object[] args) {\n        return callAdapter.adapt(call);\n    }\n}\n```\n可是他又返回给了一个`CallAdapter`接口的实现类的`adapt()`方法。。。。艹\n\n所以，这块我就不懂了，我不知道他到底咋实现这个的这个方法的，我看了《Android进阶之光》和其它很多博客，他们都是老版本的`Retrofit`，`create()`方法不同，而且调用的`adapt()`方法也不同。。。\n\n![Retrofit网络请求接口创建](http://¡cdn.littlecorgi.top/mweb/Retrofit网络请求接口创建.jpg)\n\n\n## 3.3 网络请求\n网络请求这块Retrofit实际上就是用OkHttp实现的，所以这块我就不在这多说了，大家要了解的可以看我之前写的博客：[Android网络请求3--解析OkHttp源码](https://www.littlecorgi.top/posts/151ac78a.html)。\n\n","tags":["Android","源码","kotlin","OkHttp","Retrofit"],"categories":["Android"]},{"title":"操作系统4--进程的通信和线程","url":"/posts/30b7e738.html","content":">大家可以看下我使用幕布软件画的[思维导图](https://mubu.com/doc/3Pf0zwzrgw)，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员https://mubu.com/inv/477598\n<!-- More -->\n# 4.1 进程通信\n进程通信就是指进程之间的信息交换。\n\n早期的时候，由于技术不发达，以及由于进程的同步和互斥需要在进程间交换一定的数据，所以不少人也将他们称为进程通信，但是实质上他们只能被成为低级的进程通信。\n以信号量为例，他\n1. 效率低\n    生产者或消费者每次只能向缓冲区投放一个产品或者取出一个产品。\n2. 通信对用户不透明\n\n而关于进程间通信所需的数据结构的设置和数据的传送、进程的同步和互斥，都需要程序员去完成，显然是非常不方便的。\n\n所以高级进程通信必须满足如下特点：\n1. 使用方便。\n    OS隐藏了实现进程通信的具体细节，向用户提供了一组用于实现高级通信的命令，用户可以方便地直接利用它实现进程之间的通信。\n2. 高效的传送数据。\n    用户可以直接利用高级通信命令高效的传送大量的数据。\n    \n进程通信主要有共享存储器系统、管道通信系统、消息传递系统以及客户机-服务器系统。\n## 4.1.1 共享存储器系统\n共享存储器系统又分为了两种：\n1. 基于共享数据结构的通信方式\n    在这种通信方式下，要求进程公用某些数据结构，借以实现诸进程间的信息交换。这种方式仅适用于传递相对少量的数据，通信效率低下，属于低级通信。\n2. 基于共享存储区的通信方式\n    为了传输大量数据，就在内存中划出了一块共享存储区域，诸进程可通过对该共享区的读或写交换数据，实现通信，数据的形式和位置甚至访问控制都是由进程负责，而不是OS。\n\n## 4.1.2 管道通信系统\n所谓管道，是指用于连接一个读进程和一个写进程以实现他们之间通信的一块共享存储文件，又叫pipe文件。\n向管道提供输入的发送进程以字符流形式将达量的数据送入管道，而接收管道输出的接收进程则从管道中接收数据。\n这种方式是UNIX系统IPC最古老的形式。\n\n为了协调双方的通信，他必须提供一下三个功能的协调能力：\n1. 互斥\n2. 同步\n3. 确定对方是否存在\n\n## 4.1.3 消息传递系统\n在这种方式下，集成不再借助任何共享存储区或数据结构，而是以格式化的消息(Message)为单位，将通信的数据封装在消息中，并利用操作系统提供的一组通信命令，在进程间进行消息传递，完成进程间的数据交换。\n\n该方式隐藏了通信实现细节，使通信过程对用户透明化，降低了通信程序设计的复杂性和错误率，成为当前应用最为广泛的一类进程间的通信机制.\n\n## 4.1.4 客户机-服务器系统\n前面的几种通信系统，虽然也可以用于实现不同计算机间进程的双向通信，但是客户机-服务器系统的通信机制，在网络环境的各种应用领域已成为当前主流的通信实现机制，主要分为三类：套接字、远程过程调用和远程方法调用。在这就不多赘述了。\n\n# 4.2 线程\n## 4.2.1 为什么要引入线程\n我们都知道，进程有两个基本属性：①进程是一个可拥有资源的独立单位，一个进程要能独立运行，他必须拥有一定的数据结构。②进程同时又是一个可独立调度和分派的基本单位。\n\n为了程序能并发执行，系统必须能进行创建进程、撤销进程和切换进程操作。但是由于进程是资源的拥有者，所以在上述这些操作中，系统必须为之付出较大的时空开销。这就限制了系统中所设置进程的数目，而且进程切换也不宜过于频繁，从而限制了并发程度的进一步提高。\n\n## 4.2.2 线程的概念\n在上述原因下，引入了线程的概念。学者们将进程的两个属性分开，让作为调度和分派的基本单位不拥有资源，让拥有资源的基本单倍不被频繁的调度。这样的话，就形成了线程的概念。\n\n下面我们从6个方面来比较下进和线程：\n1. 调度的基本单位\n    传统OS中，进程是作为独立调度的基本单位，每次调度时，都需要上下文切换，开销大。在引入了线程的OS中，线程是作为独立调度的基本单位，线程切换时只需要保存和设置少量的寄存器内容，切换代价远小于进程。\n2. 并发性\n    在引入线程的OS中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可以并发执行，甚至还允许在一个进程中的所有线程都能并发执行。\n3. 拥有资源\n    进程可以拥有资源，而且还是系统中拥有资源的一个基本单位。但是线程本身并不拥有资源，而是仅有一点必不可少的、能保证独立运行的资源。\n4. 独立性\n    同一进程中的线程之间的独立性比不同进程间的独立性低得多。\n5. 系统开销\n    进程切换需要大量的系统开销，而线程间则需要的很少\n6. 支持多处理机系统\n    在多处理机系统中，对于传统进程，不管有多少处理机，该进程只能运行在一个处理机上。但是对于多线程进程，可以将一个进程中的多个线程分配到多个处理机上。\n\n## 4.2.3 线程的状态和线程控制块\n与进程一样，线程也拥有三个状态和线程控制块。\n\n### 4.2.3.1 线程运行的三个状态\n线程的三个状态和进程类似。\n1. 运行状态，表示线程已获得处理机而正在运行。\n2. 就绪状态，表示线程已具备各种执行条件，只须再获得CPU便可立即执行。\n3. 阻塞状态，只线程在执行中因某事件受阻而处于暂停状态。\n\n### 4.2.3.2 线程控制块TCB\n线程控制块用来纪录用于控制和管理线程的信息。\n线程控制块中通常由这几项：\n1. 线程标识符，为每个线程设置唯一地标识符。\n2. 一组寄存器，包括程序计数器PC、状态寄存器和通用寄存器的内容。\n3. 线程运行状态，用于描述线程正处于何种运行状态。\n4. 优先级，描述线程执行的优先程度。\n5. 线程专有存储区，用于线程切换时存放现场保护信息，和与该线程相关的统计信息等。\n6. 信号屏蔽，即对某些信号加以屏蔽。\n7. 堆栈指针。","tags":["操作系统"],"categories":["操作系统"]},{"title":"uCrop框架用法和源码解析","url":"/posts/4e4b8b52.html","content":">本人能力不足，在看到源码最后一部分的时候大量抄袭[可能是最详细的UCrop源码解析](https://www.jianshu.com/p/1d3fb16fb412)\n\n# 1. uCrop简介\nuCrop是目前较火的图片裁剪框架，开发者宣称他会比目前市面上所有的图片裁剪方案都要更流畅。外加他封装程度较高，可自定义，而且颜值很高（似乎这个才是重点），现在越来越多APP选择使用它。\n[github](https://github.com/Yalantis/uCrop)\n<!-- More -->\n\n# 2. 使用方法\n得益于uCrop优秀的封装，uCrop的使用方法特简单。\n## 2.1 导入依赖\n1. 先在项目的`build.gradle`中添加\n\n    ```java\n    allprojects {\n      repositories {\n        jcenter()\n        maven { url \"https://jitpack.io\" }\n      }\n    }\n    ```\n\n    并在`module`的`build.gradle`中添加\n    \n    `implementation 'com.github.yalantis:ucrop:2.2.3'` - 轻量级框架\n    \n    `implementation 'com.github.yalantis:ucrop:2.2.3-native'` - 获得框架全部强大的功能以及图片的高质量(最终可能会导致apk的大小增加1.5MB以上)\n2. 由于框架的本质是调用到另一个Activity去处理图片，所以需要在AndroidManifest.xml中将UCropActivity添加进去\n    ```xml\n    <activity\n        android:name=\"com.yalantis.ucrop.UCropActivity\"\n        android:screenOrientation=\"portrait\"\n        android:theme=\"@style/Theme.AppCompat.Light.NoActionBar\"/>\n    ```\n\n到这你就能把cUrop全部导入到你的项目里面了，接下来咱们就拉将如何调用\n\n## 2.2 开始基本的调用\n调用起来很简单：\n```java\nUCrop.of(sourceUri, destinationUri)\n    .start(context);\n```\n其中`sourceUri`是输入图片的`Uri`，`destinationUri`是输出图片的`Uri`。然后他就会由`Intent`的调动跳到`UCropActivity`，用户就在`UCropActivity`里面进行图片裁剪操作，然后最后由`UCropActivity`发起一个`Intent`回到你的`Activity`。\n\n## 2.3 处理回来的数据\n由于是从`UCropAcitivity`传回数据，所以你需要在你的`Activity`里面的`onActivityResult`方法处理`uCrop`返回的信息：\n```java\n@Override\npublic void onActivityResult(int requestCode, int resultCode, Intent data) {\n    if (resultCode == RESULT_OK && requestCode == UCrop.REQUEST_CROP) {\n        final Uri resultUri = UCrop.getOutput(data);\n    } else if (resultCode == UCrop.RESULT_ERROR) {\n        final Throwable cropError = UCrop.getError(data);\n    }\n}\n```\n\n到这，基本用法就完了，你就可以尽情的使用uCrop。但是我前面说过，uCrop封装程度好，这点很多图片处理框架都可以做到，基本上都是把需要的数据传到自己的Activity之后由自己的Activity处理，所以很多框架看起来都有优秀的封装，那uCrop相比其他又有啥好呢，答案就是自定义灵活：\n\n## 2.4 uCrop高阶用法\n\n### 2.4.1 配置uCrop\n```java\n/**\n  * 启动裁剪\n  * @param activity 上下文\n  * @param sourceFilePath 需要裁剪图片的绝对路径\n  * @param requestCode 比如：UCrop.REQUEST_CROP\n  * @param aspectRatioX 裁剪图片宽高比\n  * @param aspectRatioY 裁剪图片宽高比\n  * @return\n  */\npublic static String startUCrop(Activity activity, String sourceFilePath, \n\tint requestCode, float aspectRatioX, float aspectRatioY) {\n    Uri sourceUri = Uri.fromFile(new File(sourceFilePath));\n    File outDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);\n    if (!outDir.exists()) {\n        outDir.mkdirs();\n    }\n    File outFile = new File(outDir, System.currentTimeMillis() + \".jpg\");\n    //裁剪后图片的绝对路径\n    String cameraScalePath = outFile.getAbsolutePath();\n    Uri destinationUri = Uri.fromFile(outFile);\n    //初始化，第一个参数：需要裁剪的图片；第二个参数：裁剪后图片\n    UCrop uCrop = UCrop.of(sourceUri, destinationUri);\n    //初始化UCrop配置\n    UCrop.Options options = new UCrop.Options();\n    //设置裁剪图片可操作的手势\n    options.setAllowedGestures(UCropActivity.SCALE, UCropActivity.ROTATE, UCropActivity.ALL);\n    //是否隐藏底部容器，默认显示\n    options.setHideBottomControls(true);\n    //设置toolbar颜色\n    options.setToolbarColor(ActivityCompat.getColor(activity, R.color.colorPrimary));\n    //设置状态栏颜色\n    options.setStatusBarColor(ActivityCompat.getColor(activity, R.color.colorPrimary));\n    //是否能调整裁剪框\n    options.setFreeStyleCropEnabled(true);\n    //UCrop配置\n    uCrop.withOptions(options);\n    //设置裁剪图片的宽高比，比如16：9\n    uCrop.withAspectRatio(aspectRatioX, aspectRatioY);\n    //uCrop.useSourceImageAspectRatio();\n    //跳转裁剪页面\n    uCrop.start(activity, requestCode);\n    return cameraScalePath;\n}\n```\n\n### 2.4.2 其他配置\n```java\n//设置Toolbar标题\nvoid setToolbarTitle(@Nullable String text)\n//设置裁剪的图片格式\nvoid setCompressionFormat(@NonNull Bitmap.CompressFormat format)\n//设置裁剪的图片质量，取值0-100\nvoid setCompressionQuality(@IntRange(from = 0) int compressQuality)\n//设置最多缩放的比例尺\nvoid setMaxScaleMultiplier(@FloatRange(from = 1.0, fromInclusive = false) float maxScaleMultiplier)\n//动画时间\nvoid setImageToCropBoundsAnimDuration(@IntRange(from = 100) int durationMillis)\n//设置图片压缩最大值\nvoid setMaxBitmapSize(@IntRange(from = 100) int maxBitmapSize)\n//是否显示椭圆裁剪框阴影\nvoid setOvalDimmedLayer(boolean isOval) \n//设置椭圆裁剪框阴影颜色\nvoid setDimmedLayerColor(@ColorInt int color)\n//是否显示裁剪框\nvoid setShowCropFrame(boolean show)\n//设置裁剪框边的宽度\nvoid setCropFrameStrokeWidth(@IntRange(from = 0) int width)\n//是否显示裁剪框网格\nvoid setShowCropGrid(boolean show) \n//设置裁剪框网格颜色\nvoid setCropGridColor(@ColorInt int color)\n//设置裁剪框网格宽\nvoid setCropGridStrokeWidth(@IntRange(from = 0) int width)\n```\n\n# 3. 源码解析\n>在我开始说源码之前，我建议大家可以先看下我下面的连接，因为本框架的作者真的是个好人，他不仅为我们贡献了这么好的一个框架，还把自己写这个框架的思路都写了出来，大家可以看看\n[英文原版](https://yalantis.com/blog/how-we-created-ucrop-our-own-image-cropping-library-for-android/)\n[国内网友翻译版](https://blog.csdn.net/wood_water_peng/article/details/51306274)\n[百度网页翻译机翻版](http://fanyi.baidu.com/transpage?query=https%3A%2F%2Fyalantis.com%2Fblog%2Fhow-we-created-ucrop-our-own-image-cropping-library-for-android%2F%23&source=url&ie=utf8&from=auto&to=zh&render=1)\n其实我个人感觉百度机翻没有谷歌翻译的好，大家有条件的可以使用谷歌翻译浏览器插件翻译整个网页（谷歌翻译好像国内可以直接访问）\n\n代码结构大致分为三个部分:\n## 3.1 第一部分：UCropActivity（整个框架的外在，用户操作图片的地方）\n他的功能就是项目主要的界面，以及实现一些基本的初始化。你跳转到uCrop看到的那个操作图片的界面就是它。\n\n这块看源码的时候代码居多，但是，说实话，就像刚刚说的一样，他除了初始化还是初始化。初始化完`Toolbar`接着初始化`ViewGroup`，初始化完`ViewGroup`接着初始化`Image`数据等等。所以这块我就没咋细看~~（其实是因为代码太长了，逃）~~\n## 3.2 第二部分：OverlayView（绘制裁剪框）\n这一块主要就是来画你所看到的图片中的裁剪的辅助线。\n\n在构造方法里面就调用了一个方法，就是`init()`，而`init()`方法也就干了一件事——判断。当系统小于`JELLY_BEA_MR2`也就是`Android4.3`时，启动了硬件加速，至于为什么`setLayerType(LAYER_TYPE_SOFTWARE, null);`这个看着就像启动硬件加速的方法，甚至参数里面还有软件这个单词的方法能启动硬件加速，请大家移步[HenCoder Android 自定义 View 1-8 硬件加速](https://hencoder.com/ui-1-8/)（进去直接搜索这个方法即可，就能找到解释的地方），我再次不做解释。\n\n这个类主要有两个方法\n1. `drawDimmedLayer()`绘制裁剪框之外的灰色部分\n2. `drawCropGrid()`绘制裁剪框\n\n那我们分别来看下这两个方法：\n### 3.2.1 drawDimmedLayer()\n```java\nprotected void drawDimmedLayer(@NonNull Canvas canvas) {\n    //先保存当前当前画布\n    canvas.save();\n    //判断是否显示圆框\n    if (mCircleDimmedLayer) {\n        //按Path路径裁剪\n        canvas.clipPath(mCircularPath, Region.Op.DIFFERENCE);\n    } else {\n        //裁剪矩形\n        canvas.clipRect(mCropViewRect, Region.Op.DIFFERENCE);\n    }\n    //着色\n    canvas.drawColor(mDimmedColor);\n    //恢复之前保存的Canvas的状态\n    canvas.restore();\n\n    if (mCircleDimmedLayer) { // 绘制1px笔划以修复反锯齿\n        canvas.drawCircle(mCropViewRect.centerX(), mCropViewRect.centerY(),\n                Math.min(mCropViewRect.width(), mCropViewRect.height()) / 2.f, mDimmedStrokePaint);\n    }\n}\n```\n首先就是一个`mCircleDimmedLayer`，这个我真的很迷，因为我不知道她是咋来的，于是我就看`OverlayView`有没有对这个变量的赋值，于是整个类我就找到了一个`setCircleDimmedLayer()`方法，于是我看这个方法是在哪被调用了的，然后我就找到他分别被UCropActivity和UCropFragment两个类调用到，而且一个是`intent.getBooleanExtra()`方法一个是`bundle.getBoolean()`方法，看到这个我相信大家都有点数了，这明显就是其他类传过来的啊，我发现他两的key的值都是`UCrop.Options.EXTRA_CIRCLE_DIMMED_LAYER`，那我就懂了，找整个框架里面哪儿提到过这个值不就得了，于是我就发现除了上面两个方法以及他的初始化以外，我发现了第4个调用的地方，也是唯一一个调用的地方——Ucrop.setCircleDimmedLayer()：\n```java\n/**\n * @param isCircle - set it to true if you want dimmed layer to have an circle inside\n * iscircle-如果希望暗显层中有一个圆，请将其设置为true。\n */\npublic void setCircleDimmedLayer(boolean isCircle) {\n    mOptionBundle.putBoolean(EXTRA_CIRCLE_DIMMED_LAYER, isCircle);\n}\n```\n注释上面是原话，下面是我百度机翻的翻译。看了就懂了吧，反正我没懂，我也完全没有见到哪调用过这个方法，我更不懂啥叫希望暗显层有个圆，啥玩意？充满线条的黑？？？\n直到我将UCrop的调用方法修改了并运行之后我才懂了：\n```java\nval options = UCrop.Options()\noptions.setCircleDimmedLayer(true)\nUCrop.of(uri, destinationUri)\n        .withOptions(options)\n        .start(this)\n```\n结果是：\n![Screenshot_20190802-211515_PhotoXiu_puzzle](http://cdn.littlecorgi.top/mweb/Screenshot_20190802-211515_PhotoXiu_puzzle.jpg)\n\n然后就懂了，应该是能截一个圆形的图案吧，然后我点下了✔️，然后……\n\n![Screenshot_20190802-211547_PhotoXiu_puzzle](http://cdn.littlecorgi.top/mweb/Screenshot_20190802-211547_PhotoXiu_puzzle.jpg)\n无话可说，作者牛逼！！！\n\n\n回去回去，刚刚说到`drawDimmedLayer()`，可以看到，如果`mCircleDimmedLayer`为`true`就调用`clipPath()`跟着路径裁切一个矩形加原，不然的话就调用`clipRect()`裁切一个矩形。然后加入颜色，然后完了\n\n### 3.2.2 drawCropGrid()\n```java\nprotected void drawCropGrid(@NonNull Canvas canvas) {\n    // 判断是否显示剪裁框\n    if (mShowCropGrid) {\n        // 判断矩形数据是否为空，mGridPoints 如果等于空的话进入填充数据\n        if (mGridPoints == null && !mCropViewRect.isEmpty()) {\n            // 该数组为 canvas.drawLines 的第一个参数，该参数要求其元素个数为 4 的倍数\n            mGridPoints = new float[(mCropGridRowCount) * 4 + (mCropGridColumnCount) * 4];\n\n            int index = 0;\n            // 组装数据，数据为每一组线段的坐标点\n            for (int i = 0; i < mCropGridRowCount; i++) {\n                mGridPoints[index++] = mCropViewRect.left;\n                mGridPoints[index++] = (mCropViewRect.height() * (((float) i + 1.0f) / (float) (mCropGridRowCount + 1))) + mCropViewRect.top;\n                mGridPoints[index++] = mCropViewRect.right;\n                mGridPoints[index++] = (mCropViewRect.height() * (((float) i + 1.0f) / (float) (mCropGridRowCount + 1))) + mCropViewRect.top;\n            }\n\n            for (int i = 0; i < mCropGridColumnCount; i++) {\n                mGridPoints[index++] = (mCropViewRect.width() * (((float) i + 1.0f) / (float) (mCropGridColumnCount + 1))) + mCropViewRect.left;\n                mGridPoints[index++] = mCropViewRect.top;\n                mGridPoints[index++] = (mCropViewRect.width() * (((float) i + 1.0f) / (float) (mCropGridColumnCount + 1))) + mCropViewRect.left;\n                mGridPoints[index++] = mCropViewRect.bottom;\n            }\n        }\n        //绘制线段\n        if (mGridPoints != null) {\n            canvas.drawLines(mGridPoints, mCropGridPaint);\n        }\n    }\n    //绘制矩形包裹线段\n    if (mShowCropFrame) {\n        canvas.drawRect(mCropViewRect, mCropFramePaint);\n    }\n    //绘制边角包裹,mFreestyleCropMode此参数如果等于1的话 剪裁框为可移动状态，一般不用\n    if (mFreestyleCropMode != FREESTYLE_CROP_MODE_DISABLE) {\n        canvas.save();\n\n        mTempRect.set(mCropViewRect);\n        mTempRect.inset(mCropRectCornerTouchAreaLineLength, -mCropRectCornerTouchAreaLineLength);\n        canvas.clipRect(mTempRect, Region.Op.DIFFERENCE);\n\n        mTempRect.set(mCropViewRect);\n        mTempRect.inset(-mCropRectCornerTouchAreaLineLength, mCropRectCornerTouchAreaLineLength);\n        canvas.clipRect(mTempRect, Region.Op.DIFFERENCE);\n\n        canvas.drawRect(mCropViewRect, mCropFrameCornersPaint);\n\n        canvas.restore();\n    }\n}\n```\n一开头又是一个和上面类似的变量`mShowCropGrid`，这下我就不说我找的具体步骤，他的功能就是如果他是`true`就会在裁剪框中显示9宫格线，为`false`就没有。接着就是画线部分，我觉得这个我不用讲啥，也没啥讲的，唯一就是为什么mGridPoints这个数组的大小是4的倍数，大家可以看下这个博客[Android Canvas DrawLines中第一个参数的解释](https://blog.csdn.net/pimkle/article/details/16946423)\n\n\n## 3.3 第三部分：GestureCropImageView（正在框架的内在，代码操作操作图片的地方）\n这个是整个项目最核心的地方。前面的两部分都是UI的，而这个才是真正的对图片进行处理的部分，也是我最想知道了解的部分。\n这部分作者也在他的博客里面说的最多最清楚。\n作者把这部分的逻辑分为了三个部分\n1. `TransformImageView extends ImageView`\n    他处理了\n    1. 从源拿到图片\n    2. 将图片进变换（平移、缩放、旋转），并应用到当前图片上\n\n2. `CropImageView extends TransformImageView`\n    他处理了\n    1. 绘制裁剪边框和网格\n    2. 为裁剪区域设置一张图片（如果用户对图片操作导致裁剪区域出现了空白，那么图片应自动移动到边界填充空白区域）\n    3. 继承父类方法，使用更精准的规则来操作矩阵（限制最大和最小缩放比）\n    4. 添加方法和缩小的方法\n    5. 裁剪图片\n3. `GestureCropImageView extends CropImageView`\n    他处理了\n    1. 监听用户手势，并调用对应的正确的方法\n\n### 3.3.1 TransformImageView\n作者说这是最容易的部分。\n在看这个类之前我们先来看看`BitmapLoadTask`类，这个类是一切图像处理的基础，这个类负责了`Uri`解码`bitmap`，并处理分辨率：\n首先根据拿到的`Uri`解析位图：\n```java\nfinal ParcelFileDescriptor parcelFileDescriptor;\ntry {\n    parcelFileDescriptor = mContext.getContentResolver().openFileDescriptor(mInputUri, \"r\");\n} catch (FileNotFoundException e) {\n    return new BitmapWorkerResult(e);\n}\n\nfinal FileDescriptor fileDescriptor;\nif (parcelFileDescriptor != null) {\n    fileDescriptor = parcelFileDescriptor.getFileDescriptor();\n} else {\n    return new BitmapWorkerResult(new NullPointerException(\"ParcelFileDescriptor was null for given Uri: [\" + mInputUri + \"]\"));\n}\n```\n现在，可以使用`BitmapFactory`方法解码`FileDescriptor`。\n\n但在解码位图之前，有必要知道它的大小，因为如果分辨率太高，位图将被二次采样。\n```java\nfinal BitmapFactory.Options options = new BitmapFactory.Options();\n\n\n\noptions.inJustDecodeBounds = true;\n\nBitmapFactory.decodeFileDescriptor(fileDescriptor, null, options);\n\noptions.inSampleSize = calculateInSampleSize(options, requiredWidth, requiredHeight);\n\noptions.inJustDecodeBounds = false;\n\n\n\nBitmap decodeSampledBitmap = BitmapFactory.decodeFileDescriptor(fileDescriptor, null, options);\n\nclose(parcelFileDescriptor);\n\n\n\nExifInterface exif = getExif(uri);\n\nif (exif != null) {\n\n  int exifOrientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);\n\n  return rotateBitmap(decodeSampledBitmap, exifToDegrees(exifOrientation));\n\n} else {\n\n  return decodeSampledBitmap;\n\n}\n```\n这样就拿到了`bitmap`实例了，就可以去`TansformImageView`去对图片进行调整了。\n其实这个类我也不知道说啥😂，我觉得这个类也就是把`Matrix`的`postTranslate()`、`postRotate()`和`postScale()`方法给封装了下。\n关于Matrix的知识大家可以参考这篇博客：[安卓自定义View进阶-Matrix原理](https://www.gcssloop.com/customview/Matrix_Basic)\n\n### 3.3.2 CropImageView\n这一层是最复杂的一层，作者的操作大致可以分为3步：图片裁剪框偏移计算、图片归为动画处理、裁剪图片\n\n- 第一步：图片裁剪框偏移计算\n当用户手指移开时，要确保图片处于裁剪区域中，如果不处于，需要通过平移把它移过来：\n\n```java\npublic void setImageToWrapCropBounds(boolean animate) {\n    //如果图片加载完毕并且图片不处于剪裁区域\n    if (mBitmapLaidOut && !isImageWrapCropBounds()) {\n\n        //获取中心点X,Y坐标\n        float currentX = mCurrentImageCenter[0];\n        float currentY = mCurrentImageCenter[1];\n        //获取缩放比例\n        float currentScale = getCurrentScale();\n\n        //获取偏移距离\n        float deltaX = mCropRect.centerX() - currentX;\n        float deltaY = mCropRect.centerY() - currentY;\n        float deltaScale = 0;\n\n        mTempMatrix.reset();\n        mTempMatrix.setTranslate(deltaX, deltaY);\n\n        final float[] tempCurrentImageCorners = Arrays.copyOf(mCurrentImageCorners, mCurrentImageCorners.length);\n        mTempMatrix.mapPoints(tempCurrentImageCorners);\n\n        //判断图片是否包含在剪裁区域\n        boolean willImageWrapCropBoundsAfterTranslate = isImageWrapCropBounds(tempCurrentImageCorners);\n\n        //如果包含在剪裁区域\n        if (willImageWrapCropBoundsAfterTranslate) {\n            //获取偏移的距离\n            final float[] imageIndents = calculateImageIndents();\n            //偏移的距离，横坐标加横坐标 纵坐标加纵坐标\n            deltaX = -(imageIndents[0] + imageIndents[2]);\n            deltaY = -(imageIndents[1] + imageIndents[3]);\n        } else {\n            //如果不包含在剪裁区域，创建临时矩形\n            RectF tempCropRect = new RectF(mCropRect);\n            mTempMatrix.reset();\n            //设置偏移角度\n            mTempMatrix.setRotate(getCurrentAngle());\n            mTempMatrix.mapRect(tempCropRect);\n\n            //获得矩形的边长坐标\n            final float[] currentImageSides = RectUtils.getRectSidesFromCorners(mCurrentImageCorners);\n            //获取放大比例\n            deltaScale = Math.max(tempCropRect.width() / currentImageSides[0],\n                    tempCropRect.height() / currentImageSides[1]);\n            deltaScale = deltaScale * currentScale - currentScale;\n        }\n\n        //如果需要动画\n        if (animate) {\n            post(mWrapCropBoundsRunnable = new WrapCropBoundsRunnable(\n                    CropImageView.this, mImageToWrapCropBoundsAnimDuration, currentX, currentY, deltaX, deltaY,\n                    currentScale, deltaScale, willImageWrapCropBoundsAfterTranslate));\n        } else {\n            //不需要动画，直接移动到目标位置\n            postTranslate(deltaX, deltaY);\n            if (!willImageWrapCropBoundsAfterTranslate) {\n                zoomInImage(currentScale + deltaScale, mCropRect.centerX(), mCropRect.centerY());\n            }\n        }\n    }\n}\n```\n\n- 第二步：处理平移\n通过一个Runnable线程来处理平移，并且通过时间差值的计算来移动动画，使动画看起来更真实：\n```java\n/**\n * 此可运行文件用于动画图像，使其完全填充裁剪边界。\n * 给定值在动画期间内插。\n * runnable可以终止于vie{@link #cancelAllAnimations()}方法，\n * 也可以在触发{@link WrapCropBoundsRunnable#run()}方法内的某些条件时终止。\n */\nprivate static class WrapCropBoundsRunnable implements Runnable {\n\n    private final WeakReference<CropImageView> mCropImageView;\n\n    private final long mDurationMs, mStartTime;\n    private final float mOldX, mOldY;\n    private final float mCenterDiffX, mCenterDiffY;\n    private final float mOldScale;\n    private final float mDeltaScale;\n    private final boolean mWillBeImageInBoundsAfterTranslate;\n\n    public WrapCropBoundsRunnable(CropImageView cropImageView,\n                                long durationMs,\n                                float oldX, float oldY,\n                                float centerDiffX, float centerDiffY,\n                                float oldScale, float deltaScale,\n                                boolean willBeImageInBoundsAfterTranslate) {\n\n        mCropImageView = new WeakReference<>(cropImageView);\n\n        mDurationMs = durationMs;\n        mStartTime = System.currentTimeMillis();\n        mOldX = oldX;\n        mOldY = oldY;\n        mCenterDiffX = centerDiffX;\n        mCenterDiffY = centerDiffY;\n        mOldScale = oldScale;\n        mDeltaScale = deltaScale;\n        mWillBeImageInBoundsAfterTranslate = willBeImageInBoundsAfterTranslate;\n    }\n\n    @Override\n    public void run() {\n        CropImageView cropImageView = mCropImageView.get();\n        if (cropImageView == null) {\n            return;\n        }\n\n        long now = System.currentTimeMillis();\n        float currentMs = Math.min(mDurationMs, now - mStartTime);\n\n        float newX = CubicEasing.easeOut(currentMs, 0, mCenterDiffX, mDurationMs);\n        float newY = CubicEasing.easeOut(currentMs, 0, mCenterDiffY, mDurationMs);\n        float newScale = CubicEasing.easeInOut(currentMs, 0, mDeltaScale, mDurationMs);\n\n        if (currentMs < mDurationMs) {\n            cropImageView.postTranslate(newX - (cropImageView.mCurrentImageCenter[0] - mOldX), newY - (cropImageView.mCurrentImageCenter[1] - mOldY));\n            if (!mWillBeImageInBoundsAfterTranslate) {\n                cropImageView.zoomInImage(mOldScale + newScale, cropImageView.mCropRect.centerX(), cropImageView.mCropRect.centerY());\n            }\n            if (!cropImageView.isImageWrapCropBounds()) {\n                cropImageView.post(this);\n            }\n        }\n    }\n}\n```\n\n下面还有另一个线程，用于双击放大:\n\n```java\n/**\n * 此可运行项用于设置图像缩放的动画。\n * 给定值在动画期间内插。\n * runnable可以终止vie {@link #cancelAllAnimations()}方法，\n * 也可以在触发{@link ZoomImageToPosition#run()}方法内的某些条件时终止。\n */\nprivate static class ZoomImageToPosition implements Runnable {\n\n    private final WeakReference<CropImageView> mCropImageView;\n\n    private final long mDurationMs, mStartTime;\n    private final float mOldScale;\n    private final float mDeltaScale;\n    private final float mDestX;\n    private final float mDestY;\n\n    public ZoomImageToPosition(CropImageView cropImageView,\n                                long durationMs,\n                                float oldScale, float deltaScale,\n                                float destX, float destY) {\n\n        mCropImageView = new WeakReference<>(cropImageView);\n\n        mStartTime = System.currentTimeMillis();\n        mDurationMs = durationMs;\n        mOldScale = oldScale;\n        mDeltaScale = deltaScale;\n        mDestX = destX;\n        mDestY = destY;\n    }\n\n    @Override\n    public void run() {\n        CropImageView cropImageView = mCropImageView.get();\n        if (cropImageView == null) {\n            return;\n        }\n\n        long now = System.currentTimeMillis();\n        float currentMs = Math.min(mDurationMs, now - mStartTime);\n        float newScale = CubicEasing.easeInOut(currentMs, 0, mDeltaScale, mDurationMs);\n\n        if (currentMs < mDurationMs) {\n            cropImageView.zoomInImage(mOldScale + newScale, mDestX, mDestY);\n            cropImageView.post(this);\n        } else {\n            cropImageView.setImageToWrapCropBounds();\n        }\n    }\n}\n```\n\n- 第三步：裁剪图片\n\n```java\n/**\n * 取消所有当前动画并设置图像以填充裁剪区域（不带动画）。\n * 然后用适当的参数创建并执行{@link BitmapCropTask}。\n */\npublic void cropAndSaveImage(@NonNull Bitmap.CompressFormat compressFormat, int compressQuality,\n                            @Nullable BitmapCropCallback cropCallback) {\n    //结束子线程\n    cancelAllAnimations();\n    //设置要剪裁的图片，不需要位移动画\n    setImageToWrapCropBounds(false);\n\n    //存储图片信息，四个参数分别为：mCropRect要剪裁的图片矩阵，当前图片要剪裁的矩阵，当前放大的值，当前旋转的角度\n    final ImageState imageState = new ImageState(\n            mCropRect, RectUtils.trapToRect(mCurrentImageCorners),\n            getCurrentScale(), getCurrentAngle());\n\n    //剪裁参数，mMaxResultImageSizeX，mMaxResultImageSizeY：剪裁图片的最大宽度、高度。\n    final CropParameters cropParameters = new CropParameters(\n            mMaxResultImageSizeX, mMaxResultImageSizeY,\n            compressFormat, compressQuality,\n            getImageInputPath(), getImageOutputPath(), getExifInfo());\n\n    //剪裁操作放到AsyncTask中执行\n    new BitmapCropTask(getViewBitmap(), imageState, cropParameters, cropCallback).execute();\n}\n```\n这块核心方法还是在`BitmapCropTask`中：\n```java\n//调整剪裁大小，如果有设置最大剪裁大小也会在这里做调整到设置范围\nprivate float resize() {\n    final BitmapFactory.Options options = new BitmapFactory.Options();\n    options.inJustDecodeBounds = true;\n    BitmapFactory.decodeFile(mImageInputPath, options);\n\n    boolean swapSides = mExifInfo.getExifDegrees() == 90 || mExifInfo.getExifDegrees() == 270;\n    float scaleX = (swapSides ? options.outHeight : options.outWidth) / (float) mViewBitmap.getWidth();\n    float scaleY = (swapSides ? options.outWidth : options.outHeight) / (float) mViewBitmap.getHeight();\n\n    float resizeScale = Math.min(scaleX, scaleY);\n\n    mCurrentScale /= resizeScale;\n\n    resizeScale = 1;\n    if (mMaxResultImageSizeX > 0 && mMaxResultImageSizeY > 0) {\n        float cropWidth = mCropRect.width() / mCurrentScale;\n        float cropHeight = mCropRect.height() / mCurrentScale;\n\n        if (cropWidth > mMaxResultImageSizeX || cropHeight > mMaxResultImageSizeY) {\n\n            scaleX = mMaxResultImageSizeX / cropWidth;\n            scaleY = mMaxResultImageSizeY / cropHeight;\n            resizeScale = Math.min(scaleX, scaleY);\n\n            mCurrentScale /= resizeScale;\n        }\n    }\n    return resizeScale;\n}\n\n// 剪裁图片\nprivate boolean crop(float resizeScale) throws IOException {\n    ExifInterface originalExif = new ExifInterface(mImageInputPath);\n\n    //四舍五入取整\n    cropOffsetX = Math.round((mCropRect.left - mCurrentImageRect.left) / mCurrentScale);\n    cropOffsetY = Math.round((mCropRect.top - mCurrentImageRect.top) / mCurrentScale);\n    mCroppedImageWidth = Math.round(mCropRect.width() / mCurrentScale);\n    mCroppedImageHeight = Math.round(mCropRect.height() / mCurrentScale);\n\n    //计算出图片是否需要被剪裁\n    boolean shouldCrop = shouldCrop(mCroppedImageWidth, mCroppedImageHeight);\n    Log.i(TAG, \"Should crop: \" + shouldCrop);\n\n    if (shouldCrop) {\n        //调用C++方法剪裁\n        boolean cropped = cropCImg(mImageInputPath, mImageOutputPath,\n                cropOffsetX, cropOffsetY, mCroppedImageWidth, mCroppedImageHeight,\n                mCurrentAngle, resizeScale, mCompressFormat.ordinal(), mCompressQuality,\n                mExifInfo.getExifDegrees(), mExifInfo.getExifTranslation());\n        //剪裁成功复制图片EXIF信息\n        if (cropped && mCompressFormat.equals(Bitmap.CompressFormat.JPEG)) {\n            ImageHeaderParser.copyExif(originalExif, mCroppedImageWidth, mCroppedImageHeight, mImageOutputPath);\n        }\n        return cropped;\n    } else {\n        //直接复制图片到目标文件夹\n        FileUtils.copyFile(mImageInputPath, mImageOutputPath);\n        return false;\n    }\n}\n```\n\n### 3.3.3 GestureCropImageView\n这个类主要就是对手势的监听，所以我们简单粗暴，直接找他的onTouchEvent方法：\n```java\n/**\n * 如果是ACTION_DOWN event，用户触摸屏幕，必须取消所有当前动画。\n * 如果是ACTION_UP event，用户从屏幕上取下所有手指，必须纠正当前图像位置。\n * 如果有两个以上的手指-更新焦点坐标。\n * 如果已启用，则将事件传递给手势检测器。\n */\n@Override\npublic boolean onTouchEvent(MotionEvent event) {\n    if ((event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_DOWN) {\n        cancelAllAnimations();\n    }\n\n    if (event.getPointerCount() > 1) {\n        mMidPntX = (event.getX(0) + event.getX(1)) / 2;\n        mMidPntY = (event.getY(0) + event.getY(1)) / 2;\n    }\n\n    //双击监听和拖动监听\n    mGestureDetector.onTouchEvent(event);\n\n    //两指缩放监听\n    if (mIsScaleEnabled) {\n        mScaleDetector.onTouchEvent(event);\n    }\n\n    //旋转监听\n    if (mIsRotateEnabled) {\n        mRotateDetector.onTouchEvent(event);\n    }\n\n    if ((event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_UP) {\n        //最后一指抬起时判断图片是否填充剪裁框\n        setImageToWrapCropBounds();\n    }\n    return true;\n}\n```","tags":["Android","源码","uCrop","图片处理"],"categories":["Android"]},{"title":"Aria2macOS安装","url":"/posts/4f46fdbb.html","content":"> 对不起大家，在我配置好这个软件之后，我兴冲冲的打开了github想下载下ssr4.0forWindows，迫不及待想感受下aria2的快感，结果发现我错了。  \n> 下载速度就才几十k/s，那一瞬间，我感触很多，我突然想到我昨晚的迅雷下载同样的资源同样的网同样的vpn下大几百k/s 的速度，然后又看到了此时我给予希望的aria，我陷入了沉思，或许这就是人生吧。  \n> 突然觉得macOS迅雷，也还挺好看的，也挺好用的，完全没有广告，要下载打开，下载完了就退出，唯一问题就是Chrome的迅雷拓展似乎太灵敏了点，我啥都没点就莫名其妙弹出下载页面，除了这个，似乎非常完美。  \n> 所以，在我配置好aria2并写下这篇博客后的不到1个小时时间，我卸载了aira2，并重新用上了迅雷。所以，我最后只想说一句，财大nb！财大nb！财大nb！对不起，走错片场了，重来，IDM牛逼！IDM牛逼！IDM牛逼！  \n>如果哪位牛逼的大哥看到了这篇博客，记得帮我给IDM说声，一个Windows的IDM正版用户急需IDM macOS版！！！\n\n<!-- More -->\n# 下载Aira2\n## 通过github安装\n- 打开github主页 [aria2/aria2-Release](https://github.com/aria2/aria2/releases)\n- 找到对应的系统下载安装即可\n\n## 通过Homebrew安装\n终端输入命令`brew install aria2`安装即可。\n没有安装Homebrew的同学可以搜索安装Homebrew即可。\n\n> 这个软件是没有图形界面的，所以安装好之后在启动台里面是找不到Aria2的图标的\n\n# 配置Aira2\n## 先创建Aria2的配置文件\nAria2提供了两种工作模式：\n1. 直接命令行模式下载\n    不太推荐这种，因为命令行下下载比较繁琐，而且也不太好操作\n2. RPC模式\n    在这种方式，Aria2启动之后就会以后台的方式运行，你就可以通过WebUI或者安装客户端的方式来使用图形界面控制Aria2.\n但是这种方式下需要配置文件，现在就告诉大家如何配置：\n首先创建文件\n\n```linux\ncd ~\nmkdir /.aria2\ncd /.aria2\ntouch aria2.conf\n```\n\n然后打开Finder，使用快捷键`Shift+Cmd+G`弹出路径输入框，接着复制粘贴`~/.aria2/`回车就进入了`.aria2`文件夹，你就会看到里面的`aria2.conf`文件，接着用文本编辑器打开，复制粘贴以下内容\n```\n#用户名\n#rpc-user=user\n#密码\n#rpc-passwd=passwd\n#上面的认证方式不建议使用,建议使用下面的token方式\n#设置加密的密钥\n#rpc-secret=token\n#允许rpc\nenable-rpc=true\n#允许所有来源, web界面跨域权限需要\nrpc-allow-origin-all=true\n#允许外部访问，false的话只监听本地端口\nrpc-listen-all=true\n#RPC端口, 仅当默认端口被占用时修改\n#rpc-listen-port=6800\n#最大同时下载数(任务数), 路由建议值: 3\nmax-concurrent-downloads=5\n#断点续传\ncontinue=true\n#同服务器连接数\nmax-connection-per-server=5\n#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要\nmin-split-size=10M\n#单文件最大线程数, 路由建议值: 5\nsplit=10\n#下载速度限制\nmax-overall-download-limit=0\n#单文件速度限制\nmax-download-limit=0\n#上传速度限制\nmax-overall-upload-limit=0\n#单文件速度限制\nmax-upload-limit=0\n#断开速度过慢的连接\n#lowest-speed-limit=0\n#验证用，需要1.16.1之后的release版本\n#referer=*\n#文件保存路径, 默认为当前启动位置\ndir=/Users/xxx/Downloads\n#文件缓存, 使用内置的文件缓存, 如果你不相信Linux内核文件缓存和磁盘内置缓存时使用, 需要1.16及以上版本\n#disk-cache=0\n#另一种Linux文件缓存方式, 使用前确保您使用的内核支持此选项, 需要1.15及以上版本(?)\n#enable-mmap=true\n#文件预分配, 能有效降低文件碎片, 提高磁盘性能. 缺点是预分配时间较长\n#所需时间 none < falloc ? trunc « prealloc, falloc和trunc需要文件系统和内核支持\nfile-allocation=prealloc\n\n#开启BT下载\nenable-dht=true\nbt-enable-lpd=true\nenable-peer-exchange=true\n# bt-tracker 更新，解决Aria2 BT下载速度慢没速度的问题\nudp://tracker.coppersurfer.tk:6969/announce,http://tracker.internetwarriors.net:1337/announce,udp://tracker.opentrackr.org:1337/announce,udp://9.rarbg.to:2710/announce,udp://9.rarbg.me:2710/announce,udp://tracker.openbittorrent.com:80/announce,http://tracker3.itzmx.com:6961/announce,http://tracker1.itzmx.com:8080/announce,udp://exodus.desync.com:6969/announce,udp://retracker.lanta-net.ru:2710/announce,udp://tracker.torrent.eu.org:451/announce,udp://tracker.tiny-vps.com:6969/announce,udp://bt.xxx-tracker.com:2710/announce,udp://tracker2.itzmx.com:6961/announce,udp://tracker.cyberia.is:6969/announce,udp://open.demonii.si:1337/announce,udp://explodie.org:6969/announce,udp://denis.stalker.upeer.me:6969/announce,udp://open.stealth.si:80/announce,http://tracker4.itzmx.com:2710/announce\n```\n\n不用更改啥，也不建议更改啥，大家可以看一下上面的配置内容，至少记得每一项大致是个啥，因为等会配置图形界面需要这些信息。\n\n最后面的BT下载的`bt-tracker`大家配置记得到这个页面更新：https://raw.githubusercontent.com/ngosang/trackerslist/master/trackers_best.txt\n\n然后再把内容复制粘贴过去。\n\n下载路径你可以自己选择，可以就把`/Users/xxx/Downloads`中的`xxx`换成你自己的macOS用户名即可。\n\n# 启动Aria2 RPC模式\n终端输入`aria2c --conf-path=\"/Users/xxx/.aria2/aria2.conf\" -D`就可以启动了。一样的，xxx是你的用户名。\n\n# 进入图形界面\nAria2有很多第三方图形界面，客户端有，但是我没用过所以我不做介绍，在这主要介绍WebUI。\n\n## YAAW插件\n1. 在chrome的拓展中心搜索`YAAW`，然后安装即可，接着就会出现YAAM的插件\n2. 点击打开它，就会进入YAAW的WebUI。\n![](http://cdn.littlecorgi.top/mweb/15647112624749.jpg)\n3. 点击右上角的🔧图标，进入设置界面\n![](http://cdn.littlecorgi.top/mweb/15647113330438.jpg)\n4. 如果你上面的`aria2.conf`是直接复制粘贴的我的话，照着我图中的填写就可以了，然后就可以使用了。找到需要下载的资源右键然后选择YAAW就会自动开始下载。\n\n## AriaNg WebUI\n这个比上面那个好看点，缺点是没有插件，你只能复制下载链接手动新建下载任务\n1. 在浏览器中输入网址 `http://ariang.mayswind.net/latest/#!/downloading`\n![](http://cdn.littlecorgi.top/mweb/15647115205711.jpg)\n\n\n2. 点击AriaNg设置\n![](http://cdn.littlecorgi.top/mweb/15647115637006.jpg)\n3. 一样，如果你上面的`aria2.conf`是直接复制粘贴的我的话，照着我图中的填写就可以了，然后就可以使用了。\n4. 你可以点击Aria2状态，看看是不是已连接，如果不是就看看有没有哪儿和`aria2.conf`设置的不一样。\n![](http://cdn.littlecorgi.top/mweb/15647116500131.jpg)\n\n# 关闭Aria2\n这个好像官方没有方法关闭，于是我们就用最简单粗暴的方法。\n1. 终端输入`ps aux|grep aria2`得到Aria2的进程号\n2. 然后输入`kill number`调用系统命令直接杀死这个进程，`number`改为上面的到的进程号即可。\n\n# 配置自启动\n## 创建sh文件\n进入到希望保存的目录下，新建一个文件`aria2.sh`：\n```\ntouch aria2.sh\n```\n然后输入下面的代码并保存：\n```\n#!/bin/bash\necho \"start aria2 server\"\naria2c --conf-path=\"/Users/xxx/.aria2/aria2.conf\" -D\necho \"exiting\"\nexit\n```\n## 修改文件权限\n1. 给`aria2.sh`文件执行权限：`chmod +x aria2.sh`\n2. 让`aria2.sh`默认用自己常用的terminal工具打开。右键文件 －> 显示简介：设置“打开方式->所有应用程序”为自己的terminal即可。\n\n## 添加到开机启动项\n1. 在`Mac`桌面顶部菜单中，点击苹果图标，在弹出的菜单中，点击进入系统偏好设置。\n2. 在打开系统偏好设置后，然后点击进入用户与群组设置选项。\n3. 然后在用户与群组设置界面，先在左侧选择登陆用户-当前用户，然后在右侧切换到登录项\n4. 然后点下面的+进行添加，选择刚才我们创建的文件aria2.sh，并勾选隐藏。\n这样 aria2 就可以在每次开机的时候自启动了。\n\n### 最后，Aria2卸载方式\n终端下执行`sudo pkgutil --forget aria2`以及`sudo pkgutil --forget aria2.path`，然后上面创建的`.aria2`文件夹","tags":["Aria2"],"categories":["杂项"]},{"title":"操作系统3--进程的同步","url":"/posts/362e394f.html","content":">大家可以看下我使用幕布软件画的[思维导图](https://mubu.com/doc/3Pf0zwzrgw)，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员https://mubu.com/inv/477598\n<!--More-->\n# 3.1 进程同步\n## 3.1.1 同步概念\n### 3.1.1.1 进程同步的概念\n进程同步机制的主要任务就是对多个相关进程在执行次序上进行协调，使并发执行的进程之间能按照一定的规则共享系统资源，并能很好的配合工作，从而使程序的执行具有可再现性。\n\n### 3.1.1.2 制约关系\n对于处于同一个系统中的多个进程，由于他们共享着系统的资源，或者为了完成同一个任务而相互合作，所以他们之间可能存在下面两种制约关系：\n1. 间接相互制约关系\n    系统中的进程难免会调用像打印机、CPU等这样的临界资源。如果想这些资源正常调用，必须保证多个进程之间互斥地访问这些资源，进而就在这些进程间形成了间接相互制约关系。\n    为了保证这些进程能有序的进行，对于系统中的这类资源，必须由系统实施统一分配，即用户在使用之前必须先提出申请，绝不允许用户直接使用。\n2. 直接相互制约关系\n    在系统中也会存在一些进程，他们为了完成同一个目标而相互配合合作工作，这种就是直接互相制约关系。\n    进程间的直接制约关系就是源于他们之间的相互合作。\n\n### 3.1.1.3 临界资源\n虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。此外，如果变量、数据等都可以被若干进程共享，也属于临界资源。\n\n### 3.1.1.4 临界区\n人们把在每个进程中访问临界资源的那段代码称为临界区。若能保证诸进程互斥地进入自己的临界区，便可实现诸进程对临界资源的互斥访问。\n为此，每个进程在进入临界区之前，应先对要访问的临界区进程检查：如果临界区正在被访问，则进程不能进入临界区；如果临界区没有被访问，那进程就可进入临界区，并将临界区正在被访问的标志置为正被访问。\n所以，我们可以将访问临界资源的线程的循环代码分为如下部分：\n- 访问临界区之前用于上述判断的代码区称为**进入区**\n- 在访问完临界区之后用于将临界区正被访问的标志恢复为未被访问的标志的代码区称为**退出区**\n- 除了进入去、临界区、退出区代码之外的其它代码称为**剩余区**\n\n```c\nwhile (true) {\n    进入区\n    临界区\n    退出区\n    剩余区\n}\n```\n\n### 3.1.1.5 同步机制应遵循的规则\n1. 空闲让进：当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效的利用临界资源\n2. 忙则等待：当已有进程进入临界区，表明临界资源正在被访问，因而其它视图进入临界区的进程必须等待，以保证对临界资源的互斥访问\n3. 有限等待：对要求访问临界资源的进程，应保证在有限的时间内能进入自己的临界区，以免陷入“死等”状态\n4. 让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态\n\n## 3.1.2 同步机制\n### 3.2.2.1 信号量机制\n#### 1. 什么是信号量\n信号量的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程，值则与相应的资源的使用情况有关：\n- 当他的值大于0时，表示当前可用资源的数量\n- 当他的值小于0时，其绝对值表示等待使用该资源的进程个数\n\n#### 2. 什么是信号量机制\n信号量机制即利用pv操作对信号量进行处理。而且信号量只能由pv操作进程处理。\n当S>0时，S表示可用资源的数量。执行一次P操作意味着分配一个单位资源，因此S值减1；当S<0时，表示已经没有可用资源，请求者必须等待别的进程释放该类资源，他才能运行下去。而执行一个V操作以为着释放一个单位资源，因此S的值加1；当S>0，表示有某些资源正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去。\n\n### 3.2.2.2 PV操作\n#### 1. P操作\n申请一个单位资源，进程进入临界区\n```c\nwait (S) {\n    while (s <= 0) ;// 如果没有资源则循环等待\n    S--;\n}\n```\n1. 将信号量S的值减1，即S=S-1；\n2. 如果S<=0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。\n\n#### 2. V操作\n释放一个单位资源，进程从临界区出来\n```c\nsignal (S) {\n    S++;\n}\n```\n1. 将信号量S的值加1，即S=S+1；\n2. 如果S>0，则该进程继续执行；否则释放队列中第一个等待信号量的进程。\n\n#### 3. PV操作的意义\n用PV操作来实现进程的同步和互斥\n\n### 3.2.3 管程机制\n尽管信号量机制很方又高效，但是每个要访问临界资源的进程都必须必备同步操作，这就使得大量的同步操作分散在各个进程中。这不仅给系统的管理带来麻烦，还会因同步操作不当而产生死锁。为了解决上述问题，变产生了一种新的同步工具——管程。\n#### 1. 管程的定义\n系统中各种硬件资源和软件资源均可用数据结构抽象地描述其资源特征，即用少量信息和对该资源所执行的操作来表征该资源。所以就出现了管程。\n管程可以看成一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。\n在管程入口处的等待队列称为入口等待队列，由于进程会执行唤醒操作，因此可能有多个等待使用管程的队列，这样的队列称为紧急队列，它的优先级高于等待队列。\n\n#### 2. 管程的特征\n1. 模块化\n    管程是一个基本的软件模块，可以单独编译\n2. 抽象数据类型\n    管程中封装了数据及对于数据的操作\n3. 信息隐藏\n    管程外的进程或其他软件模块只能通过管程对外的接口来访问管程提供的操作，管程内部的实现细节对外界是透明的\n4. 使用的互斥性\n    任何一个时刻，管程只能由一个进程使用。进入管程时的互斥由编译器负责完成\n\n#### 3. 条件变量\n\n一个进程被阻塞或挂起的条件（原因）有多个，因此在管程中设置了多个条件变量，对这些条件变量的访问只能在管程中进行。\n管程中每个条件变量都需予以说明，形式为：`condition x`。对其的操作只有`wait`和`signal`，其含义是：\n1. `x.wait`：正在调用管程的进程因x条件需要被阻塞或挂起，则调用`x.wait`将自己插入到x条件的等待队列上，并释放管程，知道x条件发生变化。此时其它进程可以使用该管程。\n2. `x.signal`： 正在调用管程的进程发现x条件发生了变化，则调用`x.signal`，重新启动一个因x条件而阻塞或挂起的进程，如果存在多个这样的进程，则选择其中的一个，如果没有，继续执行原进程，不产生任何结果。（与信号量的signal不同，没有s=s+1的操作）\n\n# 3.2 进程同步的经典问题\n## 3.2.1 生产者-消费者问题\n### 1. 问题描述\n有一群生产者进程在生产产品，并将这些产品提供给消费者进程去消费。为使生产者进程与消费者进程能并发执行，在两者之间设置了一个大小为n的缓冲区，生产者进程将其所产生的产品放入缓冲区中；消费者可从缓冲区中取走产品去消费。他们之间必须保持同步，也就是既不允许消费者进程到一个空缓冲区去取产品，也不允许生产者进程向一个已装满产品且尚未被取走的缓冲区中投放产品。\n![ProducerConsumerProble](https://blog-1255876459.cos.ap-chengdu.myqcloud.com/2019/07/31/ProducerConsumerProblem.jpg)\n### 2. 问题分析\n需要注意的几点：\n- 在缓冲区为空时，消费者不能再进行消费\n- 在缓冲区已满时，生产者不能再进行生产\n- 当一个线程进行生产或消费时，其余线程不能再进行生产或消费\n\n### 3. 伪代码\n```c\nvar items = 0, space = 10, mutex = 1;\nvar in = 0, out = 0;\nitem buf[10] = { NULL };\n\nproducer {\n    while( true ) {\n        wait( space );  // 等待缓冲区有空闲位置， 在使用PV操作时，条件变量需要在互斥锁之前\n        wait( mutex );  // 保证在product时不会有其他线程访问缓冲区\n\n        // product\n        buf.push( item, in );  // 将新资源放到buf[in]位置 \n        in = ( in + 1 ) % 10;\n\n        signal( mutex );  // 唤醒的顺序可以不同\n        signal( items );  // 通知consumer缓冲区有资源可以取走\n    }\n}\n\nconsumer {\n    while( true ) {\n        wait( items );  // 等待缓冲区有资源可以使用\n        wait( mutex );  // 保证在consume时不会有其他线程访问缓冲区\n\n        // consume\n        buf.pop( out );  // 将buf[out]位置的的资源取走\n        out = ( out + 1 ) % 10;\n\n        signal( mutex );  // 唤醒的顺序可以不同\n        signal( space );  // 通知缓冲区有空闲位置\n    }\n}\n```\n不能将线程里两个`wait`的顺序调换否则会出现死锁。例如(调换后)，将`consumer`的两个`wait`调换，在`producer`发出`signal`信号后，如果`producer`线程此时再次获得运行机会，执行完了`wait(space)`，此时，另一个`consumer`线程获得运行机会，执行了`wait(mutex)`，如果此时缓冲区为空，那么`consumer`将会阻塞在`wait(items)`，而`producer`也会因为无法获得锁的所有权所以阻塞在`wait(mutex)`，这样两个线程都在阻塞，也就造成了死锁。\n\n## 3.2.2 哲学家进餐问题\n\n### 1. 问题描述\n有五位哲学家共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五支筷子。他们的生活的方式是交替的进行思考和进餐：平时，一个哲学家进行思考，饥饿时便视图取其左右离他最近的筷子，只有在他拿到两只筷子时才能进餐，进餐完毕，放下筷子继续思考。\n\n### 2. 问题分析\n- 只有拿到两只筷子时，哲学家才能吃饭。\n- 如果筷子已被别人拿走，则必须等别人吃完之后才能拿到筷子。\n- 任一哲学家在自己未拿到两只筷子吃完饭前，不会放下手中已经拿到的筷子\n\n### 3. 伪代码\n至多只允许四个哲学家同时进餐，以保证至少有一个哲学家能够进餐，最终总会释放出他所使用过的两支筷子，从而可使更多的哲学家进餐。定义信号量count，只允许4个哲学家同时进餐，这样就能保证至少有一个哲学家可以就餐。\n ```c\nsemaphore chopstick[5]={1,1,1,1,1};\nsemaphore count=4; // 设置一个count，最多有四个哲学家可以进来\nvoid philosopher(int i)\n{\n\twhile(true)\n\t{\n\t\tthink();\n\t\twait(count); //请求进入房间进餐 当count为0时 不能允许哲学家再进来了\n\t\twait(chopstick[i]); //请求左手边的筷子\n\t\twait(chopstick[(i+1)%5]); //请求右手边的筷子\n\t\teat();\n\t\tsignal(chopstick[i]); //释放左手边的筷子\n\t\tsignal(chopstick[(i+1)%5]); //释放右手边的筷子\n\t\tsignal(count); //离开饭桌释放信号量\n\t}\n}\n ```\n \n## 3.2.3 读者-写者问题\n### 1. 问题描述\n一个数据文件或记录可被多个进程共享，我们把只要求读该文件的进程称为“Reader进程”，其它进程则称为“Writer进程”。允许多个进程同时读一个共享对象，因为读操作不会使数据文件混乱。但不允许一个Writer进程和其它Reader进程或Writer进程同时访问共享对象，这样很有可能造成共享数据混乱。\n### 2. 问题分析\n- 允许多个Reader进程同时操作一个共享对象\n- 不允许Writer进程和其它进程同时操作一个共享对象\n\n### 3. 伪代码\n```c\nsemaphore rmutex = 1,wmutex = 1;\nint readcount = 0;\nvoid reader(){\n\tdo{\n\t\twait(rmutex);\n\t\tif(readcount==0) wait(wmutex);\n\t\treadcount++;\n\t\tsignal(rmutex);\n\t\t···\n\t\tperform read operation;\n\t\t···\n\t\twait（rmutex）；\n\t\tif(readcount==0) signal(wmutex);\n\t\treadcount--;\n\t\tsignal(rmutex);\n\t}while(TRUE);\n}\n\nvoid writer(){\n\tdo{\n\t\twait(wmutex);\n\t\tperfrom write operation;\n\t\tsignal(wmutex); \n\t}while(TRUE);\n}\n```","tags":["操作系统"],"categories":["操作系统"]},{"title":"Android网络请求3--解析OkHttp源码","url":"/posts/151ac78a.html","content":"# 1. OkHttp简介\n`okhttp`是一个第三方类库，用于android中请求网络。\n\n这是一个开源项目,是安卓端最火热的轻量级框架,由移动支付Square公司贡献。用于替代因移除了`HttpClient`而导致没用的`Volley`。\n\n目前更多人选择了`Retrofit`。\n<!-- More -->\n\n# 2. 源码解析\n>本文对OkHttp的探讨全部基于目前的最新版OkHttp:4.0.1，而这个版本作者已经使用kotlin对源码进行了重写，所以有些小伙伴可能阅读稍微有点问题，但是别担心，本文中所涉及的源码阅读起来基本上和Java一样，所以请不会kotlin的小伙伴还是耐心看下去，不太懂的语法就百度下，同时我也会对某些语法作注释\n\n## 2.1 OkHttp请求流程\n### 2.1.1 从请求处理开始分析\n我们无论在使用`OkHttp`进行什么请求的时候都会创建`OkHttpClient`对象并调用他的`newCall()`方法，那我们就从这个方法看起：\n\n```kotlin\noverride fun newCall(request: Request): Call {\nreturn RealCall.newRealCall(this, request, forWebSocket = false)\n}\n```\n可以看到返回了一个`RealCall`对象，所以也就意味着我们使用`OkHttpClient`对象调用的`execute()`操作实际上是`RealCall`的`execute()`操作，那我们就来看`RealCall`的`execute()`方法：\n```kotlin\noverride fun execute(): Response {\n    // 添加同步锁\n    synchronized(this) {\n        // check()是kotlin特有的一个方法，他本质上就是一个if，\n        // 但是当他的判断语句是false的话，\n        // 他就会抛出一个IllegalStateException异常，异常的内容就是后面的语句\n        check(!executed) { \"Already Executed\" }\n        executed = true\n        // executed是一个布尔值，他的作用就是判断是不是执行过了，\n        // 如果执行过了还执行了这个方法的话就抛异常\n    }\n    // transmitter用于连接OKHTTP的应用程序和网络层，不用多管\n    transmitter.timeoutEnter()\n    transmitter.callStart()\n    try {\n        client.dispatcher.executed(this)\n        return getResponseWithInterceptorChain()\n    } finally {\n        client.dispatcher.finished(this)\n    }\n}\n```\n这块又调用了`client.dispatcher`，然后找回去找到`OkHttpClient`的`dispatcher`对象，发现他就是`Dispatcher`类的一个对象，接着我们继续看`Dispatcher`类。\n\n### 2.1.2 Dispatcher任务调度\n进入`Dispatcher`类，我们可以看到如下成员变量定义:\n>注：kotlin中一个成员变量的@get和@set分别对应了Java中get和set方法，所以这块我没有完完全全复制粘贴到这，我只取了定义部分\n\n```kotlin\n// 最大并发请求数\nvar maxRequests = 64\n// 每个主机的最大请求数\nvar maxRequestsPerHost = 5\n// 消费者线程\nval executorService: ExecutorService\n// 将要运行的异步请求队列\nprivate val readyAsyncCalls = ArrayDeque<AsyncCall>()\n// 正在运行的异步请求队队列\nprivate val runningAsyncCalls = ArrayDeque<AsyncCall>()\n// 正在运行的同步请求队列\nprivate val runningSyncCalls = ArrayDeque<RealCall>()\n```\n\n接下来我们看看`Dispatcher`的构造方法\n```kotlin\n// 主构造方法，没写具体实现\nclass Dispatcher constructor() {} \n\nconstructor(executorService: ExecutorService) : this() {\n    this.executorServiceOrNull = executorService\n}\n```\n我们可以看到他将传进来的`executorService`传给了`executorServiceOrNull`，那我们来看看`executorServiceOrNull`的定义：\n```kotlin\n// executorServiceOrNull这个应该是因为kotlin的空安全检查特性而定义的，本质上就是executorService\nprivate var executorServiceOrNull: ExecutorService? = null\n\n@get:Synchronized\n@get:JvmName(\"executorService\") val executorService: ExecutorService\n    get() {\n        if (executorServiceOrNull == null) {\n            executorServiceOrNull = ThreadPoolExecutor(0, Int.MAX_VALUE, 60, TimeUnit.SECONDS,\n                SynchronousQueue(), threadFactory(\"OkHttp Dispatcher\", false))\n        }\n        return executorServiceOrNull!!\n    }\n```\n我们可以看到`executorService`的`set`方法，就是创建了一个线程池。再结合他有两个构造器就知道：如果没有给`Dispatcher`传入一个线程池他就会自己创建一个线程池。这个线程池适合执行大量且耗时较少的任务。\n\n构造器我们看完了，我们就来看他的`enqueue()`方法：\n```kotlin\ninternal fun enqueue(call: AsyncCall) {\n    synchronized(this) {\n        readyAsyncCalls.add(call)\n\n        // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to\n        // the same host.\n        if (!call.get().forWebSocket) {\n            val existingCall = findExistingCallWithHost(call.host())\n            if (existingCall != null)call.reuseCallsPerHostFrom(existingCall)\n        }\n    }\n    promoteAndExecute()\n}\n```\n来一个请求就把他添加到就绪请求队列中去，然后就来判断`forWebSocket`这个属性。看到这个属性我还迷了下，有点搞不懂她是干嘛的，然后经过我的一番搜索后，发现原来`OkHttp`还可以进行`WebSocket`通信，而这个属性就是为`WebSocket`通信准备的。于是我就到`RealCall`里面找在哪儿定义了这个属性了，然后我就发现了在`RealCall`的`newRealCall()`方法这块，这个方法传入的参数中有一个`Boolean`值名字就叫`forWebSocket`。\n```kotlin\ncompanion object {\n    fun newRealCall(\n        client: OkHttpClient,\n        originalRequest: Request,\n        forWebSocket: Boolean\n    ): RealCall {\n        // Safely publish the Call instance to the EventListener.\n        return RealCall(client, originalRequest, forWebSocket).apply {\n            transmitter = Transmitter(client, this)\n        }\n    }\n}\n```\n不知道大家有没有印象，咱们在上面说过，执行`OkHttpClient.newCall()`方法实际上是返回了一个`RealCall`对象，于是在那找到了这个的答案，`forWebSocket=false`\n所以说这个`if`咱们不用管，直接看`promoteAndExecute()`方法：\n```kotlin\nprivate fun promoteAndExecute(): Boolean {\n    // 不知道大家还记不记得咱们之前说的kotlin里面的check()语法，\n    // 这个和check也一样，只不过抛出的是AssertionError异常\n    assert(!Thread.holdsLock(this))\n\n    // mutableListOf是kotlin里面的可变list集合\n    val executableCalls = mutableListOf<AsyncCall>()\n    val isRunning: Boolean\n    synchronized(this) {\n        val i = readyAsyncCalls.iterator()\n            while (i.hasNext()) {\n                val asyncCall = i.next()\n\n                if (runningAsyncCalls.size >= this.maxRequests) break // 最大容量\n                if (asyncCall.callsPerHost().get() >= this.maxRequestsPerHost) continue // 主机最大容量\n\n                i.remove()\n                asyncCall.callsPerHost().incrementAndGet()\n                executableCalls.add(asyncCall)\n                runningAsyncCalls.add(asyncCall)\n            }\n        isRunning = runningCallsCount() > 0\n    }\n\n    for (i in 0 until executableCalls.size) {\n        val asyncCall = executableCalls[i]\n        asyncCall.executeOn(executorService)\n    }\n\n    return isRunning\n}\n```\n首先将已就绪队列遍历一遍，判断正在运行的数量是不是大于定义的最大请求数，如果大于的话直接退出循环；如果不大于则在判断这个请求的主机请求数是不是大于定义的每个主机最大请求数，如果大于就跳过这个请求换下一个请求；不大于就把它调入正在运行的请求队列里面，直到遍历完成。然后判断还有没有正在运行的请求，如果有就`isRunning`置`true`。接着再取出`executableCalls`里的每一个元素，然后执行`executteOn()`方法。我们继续来看`AsyncCall`的`executeOn()`方法：\n```kotlin\nfun executeOn(executorService: ExecutorService) {\n    assert(!Thread.holdsLock(client.dispatcher))\n    var success = false\n    try {\n        executorService.execute(this)\n        success = true\n    } catch (e: RejectedExecutionException) {\n        val ioException = InterruptedIOException(\"executor rejected\")\n        ioException.initCause(e)\n        transmitter.noMoreExchanges(ioException)\n        responseCallback.onFailure(this@RealCall, ioException)\n    } finally {\n        if (!success) {\n            client.dispatcher.finished(this) // This call is no longer running!\n        }\n    }\n}\n```\n这段代码就是在执行线程池中的线程，如果成功执行就将`success`置`true`，如果不成功，则抛异常并返回给`responseCallback`的`onFailure()`方法。并且如果没有成功执行也就是`success`为`false`，那么在`finally`中就会执行`client.dispatcher.finished()`方法:\n```kotlin\ninternal fun finished(call: AsyncCall) {\n    call.callsPerHost().decrementAndGet()\n    finished(runningAsyncCalls, call)\n  }\n```\n这个方法先将传入的`AsyncCall`的`callsPerHost`给减1，然后再调用了`finished()`方法，我们再来看这个`finished()`方法：\n\n```kotlin\nprivate fun <T> finished(calls: Deque<T>, call: T) {\n    val idleCallback: Runnable?\n    synchronized(this) {\n        if (!calls.remove(call)) throw AssertionError(\"Call wasn't in-flight!\")\n        idleCallback = this.idleCallback\n    }\n\n    val isRunning = promoteAndExecute()\n\n    if (!isRunning && idleCallback != null) {\n        idleCallback.run()\n    }\n}\n```\n他讲此次请求从`runningAsyncCalls`中移除，然后执行了`promoteAndExecute()`方法，咱们在上面说过这个方法，他的返回值就是判断当前这个运行队列中还有没有请求，如果还有就返回`true`，没有就`false`。接着一个`if`，判断`isRunning`和`idleCallback`的，那么如果当前这个请求还没有执行的话，就调用`run()`方法执行当前请求。这样每个请求都执行完毕了。\n那我们再来看看他的`run()`方法：\n```kotlin\noverride fun run() {\n      threadName(\"OkHttp ${redactedUrl()}\") {\n            var signalledCallback = false\n            transmitter.timeoutEnter()\n            try {\n                val response = getResponseWithInterceptorChain()\n                signalledCallback = true\n                responseCallback.onResponse(this@RealCall, response)\n            } catch (e: IOException) {\n                if (signalledCallback) {\n                    // Do not signal the callback twice!\n                    Platform.get().log(INFO, \"Callback failure for ${toLoggableString()}\", e)\n                } else {\n                    responseCallback.onFailure(this@RealCall, e)\n                }\n            } finally {\n                client.dispatcher.finished(this)\n            }\n      }\n}\n```\n这块调用了一个`getResponseWithInterceptorChain()`方法，并返回了`response`，并将它返回给了`responseCallback.onResponse()`方法。如果失败了就将结果返回给`responseCallback.onFailure()`方法。最后调用`client.dispatcher.finished()`方法。\n\n### 2.1.3 Interceptor拦截器\n#### 2.1.3.1 getResponseWithInterceptorChain()方法\n首先我们看看`getResponseWithInterceptorChain()`方法：\n```kotlin\n@Throws(IOException::class)\nfun getResponseWithInterceptorChain(): Response {\n    // Build a full stack of interceptors.\n    val interceptors = mutableListOf<Interceptor>()\n    interceptors += client.interceptors\n    interceptors += RetryAndFollowUpInterceptor(client)\n    interceptors += BridgeInterceptor(client.cookieJar)\n    interceptors += CacheInterceptor(client.cache)\n    interceptors += ConnectInterceptor\n    if (!forWebSocket) {\n        interceptors += client.networkInterceptors\n    }\n    interceptors += CallServerInterceptor(forWebSocket)\n\n    val chain = RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this,\n        client.connectTimeoutMillis, client.readTimeoutMillis, client.writeTimeoutMillis)\n\n    var calledNoMoreExchanges = false\n    try {\n        val response = chain.proceed(originalRequest)\n        if (transmitter.isCanceled) {\n            response.closeQuietly()\n            throw IOException(\"Canceled\")\n        }\n        return response\n    } catch (e: IOException) {\n        calledNoMoreExchanges = true\n        throw transmitter.noMoreExchanges(e) as Throwable\n    } finally {\n        if (!calledNoMoreExchanges) {\n            transmitter.noMoreExchanges(null)\n        }\n    }\n}\n```\n首先就创建了一大堆的连接器并添加到`interceptors`集合中。然后创建了一个`RealInterceptorChain`对象，并调用了他的`proceed()`方法，接着主要目的就是讲`proceed()`返回的`response`给返回去。\n那我们就来看看`RealInterceptorChain`的`proceed()`方法：\n\n```kotlin\noverride fun proceed(request: Request): Response {\n    return proceed(request, transmitter, exchange)\n}\n  \n@Throws(IOException::class)\nfun proceed(request: Request, transmitter: Transmitter, exchange: Exchange?): Response {\n    if (index >= interceptors.size) throw AssertionError()\n\n    calls++\n\n    // If we already have a stream, confirm that the incoming request will use it.\n    check(this.exchange == null || this.exchange.connection()!!.supportsUrl(request.url)) {\n        \"network interceptor ${interceptors[index - 1]} must retain the same host and port\"\n    }\n\n    // If we already have a stream, confirm that this is the only call to chain.proceed().\n    check(this.exchange == null || calls <= 1) {\n        \"network interceptor ${interceptors[index - 1]} must call proceed() exactly once\"\n    }\n\n    // Call the next interceptor in the chain.\n    val next = RealInterceptorChain(interceptors, transmitter, exchange,\n        index + 1, request, call, connectTimeout, readTimeout, writeTimeout)\n    val interceptor = interceptors[index]\n\n    @Suppress(\"USELESS_ELVIS\")\n    val response = interceptor.intercept(next) ?: throw NullPointerException(\n        \"interceptor $interceptor returned null\")\n\n    // Confirm that the next interceptor made its required call to chain.proceed().\n    check(exchange == null || index + 1 >= interceptors.size || next.calls == 1) {\n        \"network interceptor $interceptor must call proceed() exactly once\"\n    }\n\n    check(response.body != null) { \"interceptor $interceptor returned a response with no body\" }\n\n    return response\n  }\n```\n首先就是一个`index`，`index`是`RealInterceptorChain`构造器中传入的参数，她是第四个参数，所以我们看`getResponseWithInterceptorChain()`方法中创建`RealInterceptorChain`对象时构造器的第四个传入的值为0。然后判断`index`的值是不是大于`interceptors`的大小，如果大于就抛异常，否则就继续一顿检查！！！然后再创建`RealInterceptorChain`对象，此时创建的对象传入的`index`为此时的`index+1`，然后再调用`interceptor`的`intercept()`方法，并返回`response`。\n`interceptor`的`intercept()`作用是当存在多个拦截器时都会在上面代码注释1处阻塞，并等待下一个拦截器的调用返回。\n\n#### 2.1.3.2 Interceptor源码\n那现在我们再来讲几个重要的拦截器吧。\n`OkHttp`中`Interceptor`的实现类有：\n1. `ConnectInterceptor`：连接拦截器。 \n2. `CallServerInterceptor`：请求服务器拦截器 \n3. `CacheInterceptor`：缓存拦截器 \n4. `BridgeInterceptor`：桥梁拦截器。 \n\n其中较为重要的就是`ConnectInterceptor`和`CallServerInterceptor`，那我们来看看这两个。\n\n##### 2.1.3.2.1 ConnectInterceptor\n这个类主要用来实现网络请求连接。我们来看下他的`intercept`方法：\n```kotlin\n@Throws(IOException::class)\noverride fun intercept(chain: Interceptor.Chain): Response {\n    val realChain = chain as RealInterceptorChain\n    val request = realChain.request()\n    val transmitter = realChain.transmitter()\n\n    // We need the network to satisfy this request. Possibly for validating a conditional GET.\n    val doExtensiveHealthChecks = request.method != \"GET\"\n    val exchange = transmitter.newExchange(chain, doExtensiveHealthChecks)\n\n    return realChain.proceed(request, transmitter, exchange)\n}\n```\n这个方法先将传入的`chain`对象造型成了`RealInterceptorChain`的对象，这个类我们在上面提到过，然后调用他的`response()`和`transmitter()`方法，分别得到当前`chain`的`response`和`transmitter`。然后执行了`request`的`method()`方法，判断`request`的类型是不是`GET`，如果是`doExtensiveHealthChecks`就为`false`，否则为`true`，接着把`doExtensiveHealthChecks`传入`transmitter的newExchange()`方法中去，这个方法我们等会再说，然后再调用了`proceed()`方法，这个方法我们在上面说过。\n\n##### 2.1.3.2.2 CallServerInterceptor\n这个类是网络请求的本质。它的`intercept`方法源码如下：\n```kotlin\n@Throws(IOException::class)\n  override fun intercept(chain: Interceptor.Chain): Response {\n    val realChain = chain as RealInterceptorChain\n    val exchange = realChain.exchange()\n    val request = realChain.request()\n    val requestBody = request.body\n    val sentRequestMillis = System.currentTimeMillis()\n\n    // 写入请求头\n    exchange.writeRequestHeaders(request)\n\n    var responseHeadersStarted = false\n    var responseBuilder: Response.Builder? = null\n    // 写入请求体信息\n    if (HttpMethod.permitsRequestBody(request.method) && requestBody != null) {\n        // 如果请求上有“expect:100 continue”头\n        // 请等待“http/1.1 100 continue”响应，然后再传输请求主体.\n        // 如果我们没有得到，返回我们得到的（例如4xx响应），而不传输请求体。\n        if (\"100-continue\".equals(request.header(\"Expect\"), ignoreCase = true)) {\n            exchange.flushRequest()\n            responseHeadersStarted = true\n            exchange.responseHeadersStart()\n            responseBuilder = exchange.readResponseHeaders(true)\n        }\n        if (responseBuilder == null) {\n            if (requestBody.isDuplex()) {\n                // 准备一个双工主体，以便应用程序稍后可以发送请求主体。\n                exchange.flushRequest()\n                val bufferedRequestBody = exchange.createRequestBody(request, true).buffer()\n                requestBody.writeTo(bufferedRequestBody)\n            } else {\n                // 如果满足“expect:100 continue”预期，则编写请求正文。\n                val bufferedRequestBody = exchange.createRequestBody(request, false).buffer()\n                requestBody.writeTo(bufferedRequestBody)\n                bufferedRequestBody.close()\n            }\n        } else {\n            exchange.noRequestBody()\n            if (!exchange.connection()!!.isMultiplexed) {\n                // 如果不满足“expect:100 continue”的要求，请防止重用HTTP/1连接。\n                // 否则，我们仍然有义务传输请求主体以使连接保持一致状态。\n                exchange.noNewExchangesOnConnection()\n            }\n        }\n    } else {\n        exchange.noRequestBody()\n    }\n\n    // 结束请求\n    if (requestBody == null || !requestBody.isDuplex()) {\n        exchange.finishRequest()\n    }\n    if (!responseHeadersStarted) {\n        exchange.responseHeadersStart()\n    }\n    if (responseBuilder == null) {\n        responseBuilder = exchange.readResponseHeaders(false)!!\n    }\n    // 读取响应头信息\n    var response = responseBuilder\n        .request(request)\n        .handshake(exchange.connection()!!.handshake())\n        .sentRequestAtMillis(sentRequestMillis)\n        .receivedResponseAtMillis(System.currentTimeMillis())\n        .build()\n    var code = response.code\n    if (code == 100) {\n        // 服务器发送了一个100继续，即使我们没有请求。\n        // 再次尝试读取实际响应\n        response = exchange.readResponseHeaders(false)!!\n            .request(request)\n            .handshake(exchange.connection()!!.handshake())\n            .sentRequestAtMillis(sentRequestMillis)\n            .receivedResponseAtMillis(System.currentTimeMillis())\n            .build()\n        code = response.code\n    }\n\n    exchange.responseHeadersEnd(response)\n\n    // openResponseBody 获取响应体信息\n    response = if (forWebSocket && code == 101) {\n        // 连接正在升级，但我们需要确保拦截器看到非空的响应主体。\n        response.newBuilder()\n            .body(EMPTY_RESPONSE)\n            .build()\n        } else {\n            response.newBuilder()\n                .body(exchange.openResponseBody(response))\n                .build()\n        }\n        if (\"close\".equals(response.request.header(\"Connection\"), ignoreCase = true) ||\n        \"close\".equals(response.header(\"Connection\"), ignoreCase = true)) {\n            exchange.noNewExchangesOnConnection()\n        }\n        if ((code == 204 || code == 205) && response.body?.contentLength() ?: -1L > 0L) {\n            throw ProtocolException(\n                \"HTTP $code had non-zero Content-Length: ${response.body?.contentLength()}\")\n        }\n    \n    //返回一个响应\n    return response\n}\n```\n具体过程可以看代码中的注释，它主要是向服务器发送请求数据和接受服务器返回的数据。\n\n### 2.1.4 Transmiter\n`Transmitter`类是`OkHttp`的应用层和网络层的一个桥梁类。\n\n我们先来看看该类的初始化：\n```kotlin\nclass Transmitter(\n    private val client: OkHttpClient,\n    private val call: Call\n) {\n    private val connectionPool: RealConnectionPool = client.connectionPool.delegate\n    private val eventListener: EventListener = client.eventListenerFactory.create(call)\n    private val timeout = object : AsyncTimeout() {\n        override fun timedOut() {\n            cancel()\n        }\n    }.apply {\n        timeout(client.callTimeoutMillis.toLong(), MILLISECONDS)\n    }\n```\n`Transmitter`主要的一些成员变量就这些，首先构造器中传入了两个参数，一个`OkHttpClient`，一个`Call`。然后又创建了一个连接池`connectionPool`，还有一个监听器，我们可以通过扩展这个类来监听程序的`HTTP`的调用数量、大小和持续时间。\n\n### 2.1.5 RealConnection\n我们先看看他的一些属性：\n```kotlin\nclass RealConnection(\n    val connectionPool: RealConnectionPool,\n    private val route: Route\n) : Http2Connection.Listener(), Connection {\n\n    // 以下字段由connect（）初始化，从不重新分配。\n\n    // 底层socket\n    private var rawSocket: Socket? = null\n\n    /**\n     * 应用层套接字。如果此连接不使用SSL，则可以是[sslsocket]分层在[rawsocket]上，也可以是[rawsocket]本身。\n    */\n    // 应用层socket\n    private var socket: Socket? = null\n    // 握手\n    private var handshake: Handshake? = null\n    //  协议\n    private var protocol: Protocol? = null\n    // http2的连接\n    private var http2Connection: Http2Connection? = null\n    // 与服务器交互的输入输出流\n    private var source: BufferedSource? = null\n    private var sink: BufferedSink? = null\n\n    // 跟踪连接状态下的字段由连接池保护。\n\n    /**\n     * 如果为true，则不能在此连接上创建新的交换。一旦是true的，这总是true的。\n     * 由[ConnectionPool]监视。\n     */\n    var noNewExchanges = false\n\n    /**\n     * 建立可能由于所选路由而导致的流时出现问题的次数。由[ConnectionPool]保护。\n     */\n    internal var routeFailureCount = 0\n\n    internal var successCount = 0\n    private var refusedStreamCount = 0\n\n    /**\n     * 此连接可以承载的最大并发流数。\n     * 如果“allocations.size（）<allocationlimit”，则可以在此连接上创建新流。     \n     */ \n    private var allocationLimit = 1\n```\n接下来我们看看他的`connect()`方法：\n```kotlin\nfun connect(\n    connectTimeout: Int,\n    readTimeout: Int,\n    writeTimeout: Int,\n    pingIntervalMillis: Int,\n    connectionRetryEnabled: Boolean,\n    call: Call,\n    eventListener: EventListener\n) {\n    check(protocol == null) { \"already connected\" }\n\n    // 线路的选择\n    var routeException: RouteException? = null\n    val connectionSpecs = route.address.connectionSpecs\n    val connectionSpecSelector = ConnectionSpecSelector(connectionSpecs)\n\n    if (route.address.sslSocketFactory == null) {\n        if (ConnectionSpec.CLEARTEXT !in connectionSpecs) {\n            throw RouteException(UnknownServiceException(\n                \"CLEARTEXT communication not enabled for client\"))\n        }\n        val host = route.address.url.host\n        if (!Platform.get().isCleartextTrafficPermitted(host)) {\n            throw RouteException(UnknownServiceException(\n                \"CLEARTEXT communication to $host not permitted by network security policy\"))\n        }\n    } else {\n        if (Protocol.H2_PRIOR_KNOWLEDGE in route.address.protocols) {\n            throw RouteException(UnknownServiceException(\n                \"H2_PRIOR_KNOWLEDGE cannot be used with HTTPS\"))\n        }\n    }\n\n    // 连接开始\n    while (true) {\n        try {\n            // 如果要求隧道模式，建立通道连接，通常不是这种\n            if (route.requiresTunnel()) {\n                connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener)\n                if (rawSocket == null) {\n                    // 我们无法连接隧道，但适当关闭了我们的资源。\n                    break\n                }\n            } else {\n                // 一般都走这条逻辑了，实际上很简单就是socket的连接\n                connectSocket(connectTimeout, readTimeout, call, eventListener)\n            }\n            // https的建立\n            establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener)\n            eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)\n            break\n        } catch (e: IOException) {\n            socket?.closeQuietly()\n            rawSocket?.closeQuietly()\n            socket = null\n            rawSocket = null\n            source = null\n            sink = null\n            handshake = null\n            protocol = null\n            http2Connection = null\n\n            eventListener.connectFailed(call, route.socketAddress, route.proxy, null, e)\n\n            if (routeException == null) {\n                routeException = RouteException(e)\n            } else {\n                routeException.addConnectException(e)\n            }\n\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException\n            }\n        }\n    }\n\n    if (route.requiresTunnel() && rawSocket == null) {\n        throw RouteException(ProtocolException(\n            \"Too many tunnel connections attempted: $MAX_TUNNEL_ATTEMPTS\"))\n    }\n\n    val http2Connection = this.http2Connection\n    if (http2Connection != null) {\n        synchronized(connectionPool) {\n            allocationLimit = http2Connection.maxConcurrentStreams()\n        }\n    }\n}\n```\n首先检查是否已经建立连接，如果已经建立就抛异常，没有的话就继续。接着就得到了`ConnectionSpecs`，然后根据他建立了一个`connectionSpecSelector`集合。接着判断是不是安全连接，也就是ssl连接，如果不是的话就判断了一些属性，先确定是不是明文然后再确定主机能不能接受明文操作。接着就开始连接，判断是不是要进行隧道通信，如果是就调用`connectTunnel()`建立隧道通信，如果不是就调用`connectSocket()`建立普通的通信。然后通过`establishProtocol()`建立协议。如果是`HTTP/2`就设置相关属性。\n\n然后我们就来看看他具体如何实现的，先看看`connectSocket()`方法：\n```kotlin\n@Throws(IOException::class)\nprivate fun connectSocket(\n    connectTimeout: Int,\n    readTimeout: Int,\n    call: Call,\n    eventListener: EventListener\n) {\n    val proxy = route.proxy\n    val address = route.address\n\n    // 根据代理类型选择socket类型是代理还是直连\n    val rawSocket = when (proxy.type()) {\n        Proxy.Type.DIRECT, Proxy.Type.HTTP -> address.socketFactory.createSocket()!!\n        else -> Socket(proxy)\n    }\n    this.rawSocket = rawSocket\n\n    eventListener.connectStart(call, route.socketAddress, proxy)\n    rawSocket.soTimeout = readTimeout\n    try {\n        // 连接socket，之所以这样写是因为支持不同的平台\n        // 里面实际上是  socket.connect(address, connectTimeout);\n        Platform.get().connectSocket(rawSocket, route.socketAddress, connectTimeout)\n    } catch (e: ConnectException) {\n        throw ConnectException(\"Failed to connect to ${route.socketAddress}\").apply {\n            initCause(e)\n        }\n    }\n\n    // 下面的Try/Catch块是一种避免Android 7.0崩溃的伪黑客方法\n    // More details:\n    // https://github.com/square/okhttp/issues/3245\n    // https://android-review.googlesource.com/#/c/271775/\n    try {\n        // 得到输入／输出流\n        source = rawSocket.source().buffer()\n        sink = rawSocket.sink().buffer()\n    } catch (npe: NullPointerException) {\n        if (npe.message == NPE_THROW_WITH_NULL) {\n            throw IOException(npe)\n        }\n    }\n}\n```\n首先先判断连接类型，如果是直连或者`HTTP`连接就直连，否则的话走`Socket`代理，然后通过`eventListener.connectStart()`方法创建连接，再设定超时->完成连接->创建用于I/O的`source`和`sink`。\n\n我们接着再来看`connectTunnel()`方法：\n```kotlin\n@Throws(IOException::class)\nprivate fun connectTunnel(\n    connectTimeout: Int,\n    readTimeout: Int,\n    writeTimeout: Int,\n    call: Call,\n    eventListener: EventListener\n) {\n    var tunnelRequest: Request = createTunnelRequest()\n    val url = tunnelRequest.url\n    for (i in 0 until MAX_TUNNEL_ATTEMPTS) {\n        connectSocket(connectTimeout, readTimeout, call, eventListener)\n        tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url)\n            ?: break // 已成功创建隧道。\n\n        // 代理决定在身份验证质询后关闭连接。\n        // 我们需要创建一个新的连接，但这次需要使用身份验证凭据。\n        rawSocket?.closeQuietly()\n        rawSocket = null\n        sink = null\n        source = null\n        eventListener.connectEnd(call, route.socketAddress, route.proxy, null)\n    }\n}\n```\n大体就是先创建隧道请求，然后建立`socket`连接，再发送请求建立隧道。\n\n# 3. 请求流程图\n那我们最后来总结下\n## 3.1 同步请求是如何操作的？\n![OkHttpSyn](https://blog-1255876459.cos.ap-chengdu.myqcloud.com/2019/07/26/OkHttpSync.jpg)\n\n## 3.2 异步请求是如何操作的？\n![OkHttpAsyn](https://blog-1255876459.cos.ap-chengdu.myqcloud.com/2019/07/26/OkHttpAsync.jpg)\n","tags":["Android","源码","kotlin","OkHttp"],"categories":["Android"]},{"title":"Android网络请求2--解析Volley源码","url":"/posts/df8fd75e.html","content":">本文大篇幅参考[此篇文章](https://www.jianshu.com/p/d8500e377f3e)，大家可以结合两篇文章看一下\n\n# 1. Volley简介\n在很早以前，如果Android开发者想使用网络请求的话，必须自己通过`HttpClient`或者`HttpURLConnection`编写代码来访问。但是他两的用法还是很复杂的，如果不适当的封装的话，就会有很多多余代码甚至效率降低。所以当时出现了很多第三方网络通信框架，但是都是第三方的，而谷歌官方一直没有作为。\n最终在2013年，谷歌终于意识到了问题，于是他们推出了一个官方的全新的网络框架——Volley。Volley它又能非常简单的进行HTTP通信，又能轻松加载网络上的图片。他的设计目的就是应对数据量不大但是频发的网络操作，但是对于下载等需要大数据量的网络操作，他就不太适合。\n<!-- More -->\n\n# 2. 源码解析\n## 2.1 从RequestQueue入手\n如果你使用Volley的话，就会发现Volley不管进行什么操作，首先第一步就是先创建RequestQueue对象。\n所以我们就可以认定他为Volley的入口。\n创建RequestQueue的方法是`RequestQueue mQueue = Volley.newRequestQueue(getApplicationContext());`,我们就看看`newRequestQueue`干了什么：\n```java\npublic static RequestQueue newRequestQueue(Context context, BaseHttpStack stack) {\n    BasicNetwork network;\n    if (stack == null) {\n        if (Build.VERSION.SDK_INT >= 9) {\n            network = new BasicNetwork(new HurlStack());\n        } else {\n            // 在Android 2.3之前，HttpURLConnection是不可靠的。\n            // 请参阅：http://android-developers.blogspot.com/2011/09/androids-http-clients.html\n            // 在将来的某个时候，我们将把minsdkversion移到Android 2.2之上，\n            // 并可以删除这个回退（连同所有ApacheHTTP代码）。            \n            String userAgent = \"volley/0\";\n            try {\n                String packageName = context.getPackageName();\n                PackageInfo info =\n             context.getPackageManager().getPackageInfo(packageName, /* flags= */ 0);\n                    userAgent = packageName + \"/\" + info.versionCode;\n            } catch (NameNotFoundException e) {\n            }\n\n        network =\n                new BasicNetwork(\n                        new HttpClientStack(AndroidHttpClient.newInstance(userAgent)));\n        }\n    } else {\n        network = new BasicNetwork(stack);\n    }\n\n    return newRequestQueue(context, network);\n}\n```\n调用方法后，先查看Android版本是否大于等于2.3，如果大于则调用基于`HttpURLConnection`的`HurlStack`，否则调用基于`HttpClient`的`HttpClientStack`。接下来创建`BasicNetwork`并调用`newRequestQueue(context, network)`方，我们再来看看这个`newRequestQueue()`方法：\n```java\nprivate static RequestQueue newRequestQueue(Context context, Network network) {\n    final Context appContext = context.getApplicationContext();\n    // 对缓存目录使用惰性供应商，以便可以在主线程上调用newRequestQueue（），\n    // 而不会导致严格的模式冲突。    \n    DiskBasedCache.FileSupplier cacheSupplier =\n            new DiskBasedCache.FileSupplier() {\n                private File cacheDir = null;\n\n                @Override\n                public File get() {\n                    if (cacheDir == null) {\n                        cacheDir = new File(appContext.getCacheDir(), DEFAULT_CACHE_DIR);\n                    }\n                    return cacheDir;\n                }\n            };\n    RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheSupplier), network);\n    queue.start();\n    return queue;\n}\n```\n可以看到，这个方法主要为Volley创建了一个硬盘缓存`DiskBasedCache`，然后通过这个磁盘缓存和`Network`创建了一个`RequestQueue`对象，并调用了`start()`方法，接下来我们看下`start()`方法:\n```java\npublic void start() {\n    stop(); \n    // 确保当前运行的所有调度程序都已停止。\n    // 创建缓存调度器并开始它。\n    mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);\n    mCacheDispatcher.start();\n\n    // 创建达到池大小的网络调度程序（和相应的线程）。\n    for (int i = 0; i < mDispatchers.length; i++) {\n        NetworkDispatcher networkDispatcher =\n                    new NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery);\n        mDispatchers[i] = networkDispatcher;\n        networkDispatcher.start();\n    }\n}\n```\n`CacheDispatcher`是一个缓存调度线程，并调用了`start()`方法。在循环中调用`NetworkDispatcher`的`start()`方法。`NetworkDispatcher`是网络调度线程，默认情况下`mDispatchers.length`为4，默认开启了4个调度线程，外加1个缓存调度线程，总共5个线程。\n接下来Volley会创建各种`Request`，并调用`RequestQueue`的`add()`方法：\n```java\npublic <T> Request<T> add(Request<T> request) {\n    // 将请求标记为属于此队列，并将其添加到当前请求集。\n    request.setRequestQueue(this);\n    synchronized (mCurrentRequests) {\n        //mCurrentRequests是一个HashSet\n        mCurrentRequests.add(request);\n    }\n\n    // 按添加的顺序处理请求。\n    request.setSequence(getSequenceNumber());\n    request.addMarker(\"add-to-queue\");\n    sendRequestEvent(request, RequestEvent.REQUEST_QUEUED);\n\n    // 如果请求是不可执行的，跳过缓存队列，然后直接进入网络。\n    if (!request.shouldCache()) {\n        mNetworkQueue.add(request);\n        return request;\n    }\n    mCacheQueue.add(request);\n    return request;\n}\n```\n这块地方的代码就很简单了，就是根据`request`的`shouldCache()`方法来返回`request`的`mShouldCache`属性来判断是否可以缓存，默认是可以的。如果能缓存，将此请求加入`mCacheQueue`队列，不再重复请求；不可以的话就将请求加入网络请求队列`mNetworkQueue`。\n\n## 2.2 CacheDispatcher缓存调度线程\n`RequestQueue`的`add()`方法并没有请求网络或者对缓存进行操作。当将请求添加到网络请求队 列或者缓存队列时，在后台的网络调度线程和缓存调度线程轮询各自的请求队列，若发现有请求任务则开 始执行。下面先看看缓存调度线程。\n\n首先先来看看`CacheDispatcher`的`add()`方法：\n```java\n@Override\npublic void run() {\n    if (DEBUG) \n        VolleyLog.v(\"start new dispatcher\");\n    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n    // Process.THREAD_PRIORITY_BACKGROUND默认值为10\n\n    // 进行阻塞调用以初始化缓存。\n    mCache.initialize();\n\n    while (true) {\n        try {\n            processRequest();\n        } catch (InterruptedException e) {\n            // 可能被打断了，因为是时候要退出了。\n            if (mQuit) {\n                Thread.currentThread().interrupt();\n                    return;\n            }\n            VolleyLog.e(\n                    \"Ignoring spurious interrupt of CacheDispatcher thread; \"\n                            + \"use quit() to terminate it\");\n            // 忽略cachedispatcher线程的假中断；\n            // 使用quit（）终止它\n        }\n    }\n}\n```\n这块可以看出主要就是初始化了缓存队列，然后开了个死循环，一直调用`processRequest()`，我们来看看这个方法：\n```java\nprivate void processRequest() throws InterruptedException {\n    // 从CacheQueue中取出一个可用的request\n    final Request<?> request = mCacheQueue.take();\n    processRequest(request);\n}\n\n@VisibleForTesting\nvoid processRequest(final Request<?> request) throws InterruptedException {\n    request.addMarker(\"cache-queue-take\");\n    request.sendEvent(RequestQueue.RequestEvent.REQUEST_CACHE_LOOKUP_STARTED);\n\n    try {\n        //request如果被取消了，就直接返回\n        if (request.isCanceled()) {\n            request.finish(\"cache-discard-canceled\");\n            return;\n        }\n\n        Cache.Entry entry = mCache.get(request.getCacheKey());\n        // 没有缓存就把request添加到NetworkQueue中\n        if (entry == null) {\n            request.addMarker(\"cache-miss\");\n            // 没有缓存，并且等待队列中也没有此request，那么就直接加入到NetworkQueue中\n            if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) {\n                mNetworkQueue.put(request);\n            }\n            return;\n        }\n\n        // 如果缓存过期了，也是一样把request添加到NetworkQueue中\n        if (entry.isExpired()) {\n            request.addMarker(\"cache-hit-expired\");\n            request.setCacheEntry(entry);\n            if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) {\n                mNetworkQueue.put(request);\n            }\n            return;\n        }\n\n        // 有缓存并且没有过期\n        request.addMarker(\"cache-hit\");\n        // 根据缓存的内容解析\n        Response<?> response =\n                request.parseNetworkResponse(\n                        new NetworkResponse(entry.data, entry.responseHeaders));\n        request.addMarker(\"cache-hit-parsed\");\n        // 是否需要更新\n        if (!entry.refreshNeeded()) {\n            // 不需要更新，直接将结果调度到主线程\n            mDelivery.postResponse(request, response);\n        } else {\n            request.addMarker(\"cache-hit-refresh-needed\");\n            request.setCacheEntry(entry);\n            response.intermediate = true;\n            // 判断是否有相同缓存键的任务在执行\n            if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) {\n                // 需要更新结果，先将结果调度到主线程，然后执行new runnable(){}\n                // runnable中就是将request添加到NetworkQueue中，更新一下内容\n                mDelivery.postResponse(\n                        request,\n                        response,\n                        new Runnable() {\n                            @Override\n                            public void run() {\n                                try {\n                                    mNetworkQueue.put(request);\n                                } catch (InterruptedException e) {\n                                    // Restore the interrupted status\n                                    Thread.currentThread().interrupt();\n                                }\n                            }\n                        });\n            } else {\n                // request已经加入到mWaitingRequests中\n                // 直接把结果调度到主线程\n                mDelivery.postResponse(request, response);\n            }\n        }\n    } finally {\n        request.sendEvent(RequestQueue.RequestEvent.REQUEST_CACHE_LOOKUP_FINISHED);\n    }\n}\n```\n我们在`processRequest`中可以看到有一个方法经常出现，那就是`mWaitingRequestManager.maybeAddToWaitingRequests(request)`，它的作用是判断当前这个`request`是否有存在相同缓存键的请求已经处于运行状态，如果有，那么就将这个`request`加入到一个等待队列中，等到相同缓存键的请求完成。\n\n总结一下`CacheDispatcher`主要步骤：\n\n- 从`CacheQueue`中循环取出`request`；\n- 如果缓存丢失，加入到`NetworkQueue`中；\n- 如果缓存过期，加入到`NetworkQueue`中；\n- 将缓存中的数据解析成`Response`对象；\n- 如果不需要更新，直接将结果回调到主线程，回调操作等介绍完`NetworkDispatcher`之后一起深入剖析；\n- 如果需要更新，先将结果回调到主线程，然后再将`request`加入到`NetworkQueue`中。\n\n下面来看看网络调度线程。\n\n## 2.3 NetWorkDispatcher网络调度线程\nNetworkDispatcher的run方法代码如下所示:\n```java\n@Override\npublic void run() {\n    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n    while (true) {\n        try {\n            processRequest();\n        } catch (InterruptedException e) {\n            // 我们可能被打断了，因为是时候退出了。\n            if (mQuit) {\n                Thread.currentThread().interrupt();\n                return;\n            }\n            VolleyLog.e(\n                    \"Ignoring spurious interrupt of NetworkDispatcher thread; \"\n                            + \"use quit() to terminate it\");\n        }\n    }\n}\n```\n由此可以看出，`NetWordDispatch`和`CacheDispatch`非常类似。\n他的`run()`方法和`CacheDispatch`的方法基本一样，这就不多做介绍，下面来看看他的`processRequest()`方法。\n```java\nprivate void processRequest() throws InterruptedException {\n    // 从NetworkQueue中取出request\n    Request<?> request = mQueue.take();\n    processRequest(request);\n}\n\n@VisibleForTesting\nvoid processRequest(Request<?> request) {\n    long startTimeMs = SystemClock.elapsedRealtime();\n    request.sendEvent(RequestQueue.RequestEvent.REQUEST_NETWORK_DISPATCH_STARTED);\n    try {\n        request.addMarker(\"network-queue-take\");\n\n        // 如果request被取消了，那么就不执行此request\n        if (request.isCanceled()) {\n            request.finish(\"network-discard-cancelled\");\n            request.notifyListenerResponseNotUsable();\n            return;\n        }\n\n        addTrafficStatsTag(request);\n\n        // 还记得这个mNetwork么，它就是Volley.newRequestQueue()方法里的BasicNetwork对象，一会我们来看看mNetwork.performRequest()方法是如何得到NetworkResponse的\n        NetworkResponse networkResponse = mNetwork.performRequest(request);\n        request.addMarker(\"network-http-complete\");\n\n        // notModified是服务端返回304，hasHadResponseDelivered()是request已经回调过了\n        if (networkResponse.notModified && request.hasHadResponseDelivered()) {\n            request.finish(\"not-modified\");\n            request.notifyListenerResponseNotUsable();\n            return;\n        }\n\n        // 将NetworkResponse解析成Response对象，在子线程中执行\n        Response<?> response = request.parseNetworkResponse(networkResponse);\n        request.addMarker(\"network-parse-complete\");\n\n        // 将request写入缓存\n        if (request.shouldCache() && response.cacheEntry != null) {\n            mCache.put(request.getCacheKey(), response.cacheEntry);\n            request.addMarker(\"network-cache-written\");\n        }\n\n        request.markDelivered();\n        // 回调结果至主线程\n        mDelivery.postResponse(request, response);\n        request.notifyListenerResponseReceived(response);\n    } \n    // 以下都是处理异常错误，然后也需要回调至主线程\n    catch (VolleyError volleyError) {\n        volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);\n        parseAndDeliverNetworkError(request, volleyError);\n        request.notifyListenerResponseNotUsable();\n    } catch (Exception e) {\n        VolleyLog.e(e, \"Unhandled exception %s\", e.toString());\n        VolleyError volleyError = new VolleyError(e);\n        volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);\n        mDelivery.postError(request, volleyError);\n        request.notifyListenerResponseNotUsable();\n    } finally {\n        request.sendEvent(RequestQueue.RequestEvent.REQUEST_NETWORK_DISPATCH_FINISHED);\n    }\n}\n```\n通过`NetworkDispatcher.processRequest()`方法可以发现，主要分为以下几步：\n\n- 通过`BasicNetwork.performRequest(request)`得到`NetworkResponse`对象；\n- 通过`request.parseNetworkResponse(networkResponse)`解析得到`Response`对象；\n- 通过`mDelivery`将成功结果或者失败结果回调到主线程。\n\n现在我们依次来分析这三步：\n- 请求网络，得到`NetworkResponse`\n    我们看看`BasicNetwork`的`performRequest()`方法：\n    \n```java\n@Override\npublic NetworkResponse performRequest(Request<?> request) throws VolleyError {\n    long requestStart = SystemClock.elapsedRealtime();\n    while (true) {\n        HttpResponse httpResponse = null;\n        byte[] responseContents = null;\n        List<Header> responseHeaders = Collections.emptyList();\n        try {\n            // Gather headers.\n            Map<String, String> additionalRequestHeaders =\n                    getCacheHeaders(request.getCacheEntry());\n            httpResponse = mBaseHttpStack.executeRequest(request, additionalRequestHeaders);\n            int statusCode = httpResponse.getStatusCode();\n\n            responseHeaders = httpResponse.getHeaders();\n            // Handle cache validation.\n            if (statusCode == HttpURLConnection.HTTP_NOT_MODIFIED) {\n                Entry entry = request.getCacheEntry();\n                if (entry == null) {\n                    return new NetworkResponse(\n                            HttpURLConnection.HTTP_NOT_MODIFIED,\n                            /* data= */ null,\n                            /* notModified= */ true,\n                            SystemClock.elapsedRealtime() - requestStart,\n                            responseHeaders);\n            }\n                    …………省略\n```\n通过上面源码可以看出，`BasicNetwork`就是封装了一下`NetworkResponse`，并没有涉及到网络请求，我们继续深入到`BaseHttpStack.executeRequest(request, additionalRequestHeaders)`源码中。\n```java\npublic abstract HttpResponse executeRequest(\n        Request<?> request, Map<String, String> additionalHeaders)\n        throws IOException, AuthFailureError;\n```\n这时发现这个`BaseHttpStack`就是一个抽象类，而这个`executeRequest()`也就是一个抽象方法。我当时就卡在这了，调用了一个抽象类的抽象方法，这咋操作嘛。然后我就好好再看了一遍，找到`BasicNetwork`的构造函数中对`mBaseHttpStck`定义的地方，发现这个是构造函数传进来的，然后就想到了在调用`Volley.newRequestQueue()`时，是根据Android版本传入了不同的`Stack`，那我们就来看看`HurlStack.executeRequest()`方法：\n```java\n@Override\npublic HttpResponse executeRequest(Request<?> request, Map<String, String> additionalHeaders)\n        throws IOException, AuthFailureError {\n    String url = request.getUrl();\n    HashMap<String, String> map = new HashMap<>();\n    map.putAll(additionalHeaders);\n    // request.getheaders（）优先于给定的附加（缓存）头.\n    map.putAll(request.getHeaders());\n    if (mUrlRewriter != null) {\n        String rewritten = mUrlRewriter.rewriteUrl(url);\n        if (rewritten == null) {\n            throw new IOException(\"URL blocked by rewriter: \" + url);\n        }\n        url = rewritten;\n    }\n    URL parsedUrl = new URL(url);\n    HttpURLConnection connection = openConnection(parsedUrl, request);\n    boolean keepConnectionOpen = false;\n    try {\n        for (String headerName : map.keySet()) {\n            connection.setRequestProperty(headerName, map.get(headerName));\n        }\n        setConnectionParametersForRequest(connection, request);\n        // 使用来自httpurlConnection的数据初始化httpResponse。\n        int responseCode = connection.getResponseCode();\n        if (responseCode == -1) {\n            // 如果无法检索响应代码，getResponseCode（）将返回-1。\n            // 向呼叫者发出信号，说明连接有问题。\n            throw new IOException(\"Could not retrieve response code from HttpUrlConnection.\");\n        }\n\n        if (!hasResponseBody(request.getMethod(), responseCode)) {\n            return new HttpResponse(responseCode, convertHeaders(connection.getHeaderFields()));\n        }\n\n        // 需要保持连接打开，直到调用方使用流。包装流，以便close（）将断开连接。\n        keepConnectionOpen = true;\n        return new HttpResponse(\n                responseCode,\n                convertHeaders(connection.getHeaderFields()),\n                connection.getContentLength(),\n                new UrlConnectionInputStream(connection));\n    } finally {\n        if (!keepConnectionOpen) {\n            connection.disconnect();\n        }\n    }\n}\n```\n可以看到，主要就是借助了`HttpURLConnection`对象来请求网络，并根据不同的条件返回不同的`HttpResponse`对象。\n- 解析`NetworkResponse`, 得到`Response`：\n解析过程是定义在`Request`类中，但是他是一个抽象类，不同的Request都有自己的实现，我们现在就以JsonRequest为例看看：\n然后发现他又是一个抽象类，那我们就看看`JsonRequest`其中一个实现类`JsonObjectRequest`的`parseNetworkResponse()`方法：\n\n```java\n@Override\nprotected Response<JSONObject> parseNetworkResponse(NetworkResponse response) {\n    try {\n        String jsonString =\n                new String(\n                        response.data,\n                        HttpHeaderParser.parseCharset(response.headers, PROTOCOL_CHARSET));\n        return Response.success(\n                new JSONObject(jsonString), HttpHeaderParser.parseCacheHeaders(response));\n    } catch (UnsupportedEncodingException e) {\n        return Response.error(new ParseError(e));\n    } catch (JSONException je) {\n        return Response.error(new ParseError(je));\n    }\n}\n```\n这个就不用多说了，根据返回来的`response`建了一个`String`然后把这个`String`放到`Response`里面去然后再返回去。\n- 回调主线程\n回调主要是通过`Delivery`的`postResponse()`方法实现的，我们来看看这个方法,找过去又找到了一个`ResponseDelivery`抽象类，然后又得找他的实现类，这时大家应该记得`RequestQueue()`的时候初始化了一个`Delivery`：\n\n```java\npublic RequestQueue(Cache cache, Network network, int threadPoolSize) {\n    this(\n            cache,\n            network,\n            threadPoolSize,\n            new ExecutorDelivery(new Handler(Looper.getMainLooper())));\n}\n```\n他返回了一个`ExecutorDelivery`，我们来看看这个类，然后就惊喜的发现，我们终于找到我们需要的东西了：\n```java\n/**\n * Creates a new response delivery interface.\n *\n * @param handler {@link Handler} to post responses on\n */\npublic ExecutorDelivery(final Handler handler) {\n    // Make an Executor that just wraps the handler.\n    mResponsePoster =\n            new Executor() {\n                @Override\n                public void execute(Runnable command) {\n                        handler.post(command);\n                }\n            };\n}\n```\n知道了它的初始化，我们再来看看它是如何实现回调的：\n\n`Volley`中回调是通过`postResponse()`方法的 :\n\n```java\npublic void postResponse(Request<?> request, Response<?> response) {\n    postResponse(request, response, null);\n}\n\n@Override\npublic void postResponse(Request<?> request, Response<?> response, Runnable runnable) {\n    request.markDelivered();\n    request.addMarker(\"post-response\");\n    mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));\n}\n```\n\n`postResponse()`最终会调用`mResponsePoster`对象的`execute()`方法，传入了一个`ResponseDeliveryRunnable`对象，它实现了`Runnable`接口，`execute()`方法会通过`Handler.post(runnable)`将`ResponseDeliveryRunnable`放入消息队列。最后我们来看看这个`ResponseDeliveryRunnable`的`run()`方法在主线程中做了什么操作：\n\n```java\n@SuppressWarnings(\"unchecked\")\n@Override\npublic void run() {\n\n    // If this request has canceled, finish it and don't deliver.\n    if (mRequest.isCanceled()) {\n        mRequest.finish(\"canceled-at-delivery\");\n        return;\n    }\n\n    if (mResponse.isSuccess()) {\n        // 执行成功的回调，在具体的Request实现类中，比如StringRequest就会调用listener.onResponse(string)回调\n        mRequest.deliverResponse(mResponse.result);\n    } else {\n        // 执行失败的回调，在request中，直接回调了listener.onErrorResponse(error)\n        mRequest.deliverError(mResponse.error);\n    }\n\n    // intermediate默认为false，但是在CacheDispatcher的run()中，如果需要更新缓存，那么就会置为true\n    if (mResponse.intermediate) {\n        mRequest.addMarker(\"intermediate-response\");\n    } else {\n        mRequest.finish(\"done\");\n    }\n\n    // 如果传入了runnable不为空，那就就执行runnable.run()方法\n    // 回忆下在CacheDispatcher的run()方法中，如果request有缓存，但是需要更新缓存的时候，mDelivery是不是调用的带runnable的方法\n    if (mRunnable != null) {\n        mRunnable.run();\n    }\n}\n```\n\n# 3 请求流程图\n最后附上Volley的请求流程图\n![VolleyRequestProcess](https://blog-1255876459.cos.ap-chengdu.myqcloud.com/2019/07/23/VolleyRequestProcess.jpg)\n\n\n\n","tags":["Android","源码","kotlin","Volley"],"categories":["Android"]},{"title":"操作系统2--进程的描述和控制","url":"/posts/2e847144.html","content":">大家可以看下我使用幕布软件画的[思维导图](https://mubu.com/doc/3Pf0zwzrgw)，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员https://mubu.com/inv/477598\n\n<!-- More -->\n[TOC]\n\n# 2.1 进程的描述\n## 2.1.1 进程的定义和特征\n### 2.1.1.1 进程的定义\n为了能够使程序并发执行，并且可以对并发执行的程序加以描述和控制，人们引入了“进程”的概念。\n为了使参与并发执行的每个程序都能独立地运行，操作系统必须为之配置一个专门的数据结构，称为**进程数据块（PCB）**。他用来纪录进程的各种属性，描述进程的动态变化过程。主要包含有进程的描述信息（进程标识符，进程名，用户标识符，进程组关系等）、进程控制信息（当前状态，优先级，代码执行入口地址，保存的磁盘地址等等）、所拥有的资源和使用情况（虚拟地址空间的状态，文件打开列表等）和CPU现场信息等内容。PCB是系统感知进程存在的唯一标志。\n所以一般情况下，我们把进程实体就简称为进程，创建进程，实质上是创建进程实体中的PCB；撤销进程，实质上是撤销进程的PCB。\n对于进程的定义，比较典型的有：\n1. 进程是程序的一次执行\n2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动\n3. 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位\n\n### 2.1.1.2 进程的特征\n1. 结构性\n进程实体是由程序段、数据段及进程控制快三部分组成。\n2. 动态性\n进程的实质是进程实体的执行过程，而且进程“由创建而产生，由调度而执行，由撤销而消亡”。\n3. 并发性\n多个进程实体同存于内存中，且能在一段时间内同时运行。\n4. 独立性\n进程实体是一个能独立运行、独立获得资源和独立接收调度的基本单位。\n5. 异步性\n进程是按异步方式运行的。\n\n## 2.1.2 进程的基本状态及转换\n### 2.1.2.1 进程的三种基本状态\n进程主要分为三种基本状态：\n1. 运行态\n指进程已经获得了CPU，他正在CPU上执行。\n2. 就绪态\n指进程已经准备就绪，准备好了被CPU执行的状态。如果系统中有很多处于就绪态的进程，通常把他们按一定的策略排成一个队列，这个队列称为就绪队列。\n3. 等待态\n指正在运行的进程由于发生某事件（如I/O请求、申请缓冲区失败等问题）暂时无法继续执行时的状态。此时引起进程调度，OS把处理机分配给就绪中的进程，让受阻的进程处于阻塞状态。\n\n### 2.1.2.2 三种状态的转换\n![三种状态的转换](https://blog-1255876459.cos.ap-chengdu.myqcloud.com/2019/07/20/UntitledDiagram.jpg)\n\n### 2.1.2.3 创建状态和终止状态\n为了满足进程控制块对数据及操作的完整性要求以及增强管理的灵活性，通常在系统中又为进程引入了两种常见的状态：创建状态和终止状态。\n![五种状态转换](https://blog-1255876459.cos.ap-chengdu.myqcloud.com/2019/07/20/wuzhongzhuangtaizhuanhuan.png)\n\n## 2.1.3 进程管理中的数据结构\n在最开始我已经经提到了进程控制块PCB这个东西，现在我们就进一步来了解他。\n### 2.1.3.1 进程控制块中的作用\nPCB的作用主要就是使一个在多道程序环境下不能独立运行的程序称为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。\n1. 作为独立运行基本单位的标志。\n    当一个程序配置了PCB之后，就表示他已是一个能在多道程序环境下独立运行的、合法的基本单位，也就具有取得OS服务的权利。当系统创建一个新的进程的时候，就为他创建了一个PCB，进程结束后收回PCB。\n2. 能实现间断性运行方式。\n    在多道程序运行环境下，由于存在时间片或者有等待I/O请求的情况，所以进程一般都是出于走走停停的状态，当一个进程被阻塞的时候，他应该有一种能保存当前运行状态的能力也就是保护现场机制，方便在此被调度执行时恢复阻塞前的状态。所以就需要在PCB里面提供一个数据结构来保存该进程被中断时的一些信息。\n3. 提供进程管理所需要的信息。\n    这个就不用多说吧。\n4. 提供进程调度所需要的信息。\n    只有处于就绪状态的进程才能被调度执行，而在PCB中就提供了进程处于何种状态的信息。\n5. 实现与其它进程的同步与通信。\n    \n### 2.1.3.2 进程控制块中的信息\n根据上面进程控制块作用的描述，对应的进程控制块中就需要包含以下信息。\n1. 进程标识符\n    进程标识符用于唯一地标识一个进程。一个进程通常具有两种标识符：\n    1. 外部标识符\n        为了方便用户（进程）对进程的访问，进程需要提供一个用于用户（进程）访问的标识符。\n    2. 内部标识符\n        为了方便系统对进程的使用，在OS中又为进程设置了内部标识符。通常是一个进程的序号。\n2. 处理机状态\n    处理机状态信息也称为处理机的上下文，主要是由处理机的各种寄存器中的内容组成的。这些寄存器信息包括通用寄存器、指令寄存器、程序状态字PSW和用户栈指针。\n3. 进程调度信息\n    在OS进行调度的时候，必须了解进程的状态及有关进程调度的信息，这些信息包括：进程状态、进程优先级、进程调度所需其他信息（与所采用的的调度算法有关）和事件（阻塞原因）。\n4. 进程控制信息\n    用于进程控制所必须的信息，包括：程序和数据的地址、进程同步和通信机制、资源清单和链接指针。\n\n### 2.1.3.3 进程控制块的组织方式\n一个系统中有很多个PCB，为了对他们进行有效的管理，应该用适当的方式将这些PCB组织起来，常用的组织方式有三种\n1. 线性方式\n直接将所有PCB放在一张线性表中，优点是简单，开销小，但是每次查找起来很麻烦。\n![linedPCB](https://blog-1255876459.cos.ap-chengdu.myqcloud.com/2019/07/21/linedPCB.jpg)\n\n2. 链接方式\n把具有相同状态的PCB分别通过PCB中的链接字链接成一个队列。\n![linkedPCB](https://blog-1255876459.cos.ap-chengdu.myqcloud.com/2019/07/21/linkedPCB.png)\n\n3. 索引方式\n根据所有进程状态的不同建立几张索引表，并把个索引表在内存的首地址纪录在内存的一些专用单元中。\n![indexPCB](https://blog-1255876459.cos.ap-chengdu.myqcloud.com/2019/07/21/indexPCB.png)\n\n# 2.2 进程控制\n## 2.2.1 进程的层次结构\n在OS中，允许一个进程创建另一个进程，通常把创建进程的进程称为父进程，被创建的进程称为子进程。然后子进程可以作为父进程继续去创建子进程，进而形成一个进程家族。\n## 2.2.2 进程的创建\n每当出现了创建新进程的请求后，OS便调用进程创建原语Creat按下述步骤创建新进程：\n1. 申请空白PCB，为新进程申请获得唯一的数字标识符，并从PCB集合中索取一个空白PCB。\n2. 为新进程分配其运行所需的资源，包括各种物理和逻辑资源。\n3. 初始化进程控制块PCB。\n4. 如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。\n\n## 2.2.3 进程的终止\n1. 根据被终止进程的标识符，从PCB集合中检索出进程的PCB，从中读出该进程的状态。\n2. 若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志位真，用于指示该进程被终止后应重新进行调度。\n3. 若该进程还有子孙进程，还应将其所有子孙进程也都予以终止，以防它们称为不可控的进程。\n4. 将被终止进程所拥有的的全部资源或者归还给其父进程，或者归还给系统。\n5. 将被终止进程（PCB）从所在队列（或链表）中移出，等待其他程序来搜集信息。\n\n","tags":["操作系统"],"categories":["操作系统"]},{"title":"操作系统1--操作系统概述","url":"/posts/62248b34.html","content":">大家可以看下我使用幕布软件画的[思维导图](https://mubu.com/doc/3Pf0zwzrgw)，如果大家想使用幕布可以通过我的邀请链接注册，可免费获得一个月高级会员https://mubu.com/inv/477598\n\n<!-- More -->\n# 现如今主流的操作系统\n\n## 1.1.1 PC\n\n### 1.1.1.1 Windows\nMicrosoft Windows是微软公司推出的一系列操作系统。其问世时间为1985年，起初为运行于MS-DOS之下的桌面环境，其后续版本逐渐发展成为主要为个人计算机和服务器用户设计的操作系统，并最终获得了世界个人计算机操作系统的垄断地位。此操作系统可以在几种不同类型的平台上运行，如个人计算机、移动设备、服务器和嵌入式系统等等，其中在个人计算机的领域应用内最为普遍。\nWindows操作系统当前最新的稳定版是于2015年7月29日发布的 Windows 10。Windows Server当前最新的稳定版是2018年10月2日发布的Windows Server 2019。Windows Phone当前最新的稳定版是Windows10 Mobile，但是已停止开发新版本，仅对现有版本进行安全补丁和维护，直到2019年12月。\n### 1.1.1.2 macOS\nmacOS（2011年及之前称Mac OS X，2012年至2015年称OS X）是苹果公司推出的基于图形用户界面操作系统，为麦金塔（Macintosh）的主操作系统。StatCounter在2018年8月的数据表示，在桌面操作系统中，macOS的使用份额为12.65%，次于Windows的82.51%位居第二。\nmacOS当前最新的稳定版是2018年9月25日发布的macOS 10.14 Mojave，2019年6月4日推出macOS 10.15 Catalina的第一个测试版本。\n### 1.1.1.3 Linux\nLinux是一种自由和开放源码的类UNIX 操作系统。该操作系统的内核由林纳斯·托瓦兹在1991年10月5日首次发布，在加上用户空间的应用程序之后，成为 Linux 操作系统。Linux也是自由软件和开放源代码软件发展中最著名的例子。只要遵循 GNU 通用公共许可证（GPL），任何个人和机构都可以自由地使用 Linux 的所有底层源代码，也可以自由地修改和再发布。大多数 Linux 系统还包括像提供 GUI 的 X Window 之类的程序。除了一部分专家之外，大多数人都是直接使用 Linux 发行版，而不是自己选择每一样组件或自行设置。\n### 1.1.1.4 Unix\nUNIX操作系统（尤尼斯），是一个强大的多用户、多任务操作系统，支持多种处理器架构，按照操作系统的分类，属于分时操作系统，最早由KenThompson、Dennis Ritchie和Douglas McIlroy于1969年在AT&T的贝尔实验室开发。它的商标权由国际开放标准组织所拥有，只有符合单一UNIX规范的UNIX系统才能使用UNIX这个名称，否则只能称为类UNIX（UNIX-like）。\n## 1.1.2 移动端\n\n### 1.1.2.1 Android\nAndroid，常见的非官方中文名称为安卓，是一个基于Linux内核的开放源代码移动操作系统，由Google成立的Open Handset Alliance持续领导与开发，主要设计用于触摸屏移动设备如智能手机和平板电脑与其他便携式设备。\nAndroid Inc.于2003年10月由安迪·鲁宾、利奇·米纳尔、尼克·席尔斯、克里斯·怀特在加州帕罗奥图创建。Android最初由安迪·鲁宾等人开发制作，最初开发这个系统的早期方向是创建一个数字相机的先进操作系统，但是后来发现市场需求不够大，加上智能手机市场快速成长，于是Android成为一款面向智能手机的操作系统。于2005年7月11日Android Inc.被美国科技企业Google收购。\n2017年3月，Android全球网络流量和设备超越Microsoft Windows，正式成为全球第一大操作系统。\n### 1.1.2.2 iOS\niOS（原名为iPhone OS）是苹果公司为其移动设备所开发的专有移动操作系统，为其公司的许多移动设备提供操作界面，支持设备包括iPhone、iPad和iPod touch。iPhone OS自iOS 4起便改名为iOS，它是继Android后全球第二大最受欢迎的移动操作系统，市占率已上升至约24.5% ，但仍远低于Google开发的Android系统的72.2%。\n\n# 1.2 操作系统的简介与作用\n\n## 1.2.1 操作系统的简介\n操作系统是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。主要作用是对管理好计算机硬件设备，提高他们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单接口，便于用户使用。\n\n## 1.2.2 操作系统的目的\n1. 方便性\n    如果一个计算机没有OS，那么他会非常难用。用户不管进行啥操作都得通过机器语言编写程序然后运行，而如果有OS的话，用户就可以使用各种各样的语言编写程序，然后通过编译将高级语言编译成机器代码，方便了用户。\n2. 有效性\n    有效性分两层含义——提高系统资源的利用率和提高系统的吞吐量。早期没有OS的计算机中，处理机和I/O设备等经常处于空闲状态，各种资源不能得到合理利用，所以提高系统资源利用率是推动OS发展的主要动力。另一方面，OS可以通过合理组织计算机的工作流程，加速程序的运行，缩短程序的运行周期，从而提高系统的吞吐量。\n3. 可扩充性\n    为了适应现在越来越多的计算机硬件以及体系结构，OS必修有良好的可扩充性。\n4. 开放性\n    OS需要遵循世界标准规范，凡遵循国际标准所开发的硬件和软件都能彼此兼容，方便地实现互联。\n\n## 1.2.3 操作系统的作用\n1. OS作为用户与计算机硬件系统之间的接口\n    OS处于用户和硬件之间，方便用户通过OS使用硬件。或者说，用户在OS的帮助下能够方便、快捷、可靠地操纵计算机硬件和运行自己的程序。\n2. OS作为计算机系统资源的管理者\n    计算机系统资源主要可分为处理机、存储器、I/O设备以及文件。OS主要功能也就是对这四类资源进行有效的管理。处理机管理是用于分配和控制处理机；存储器管理主要负责内存的分配与回收；I/O设备管理是负责I/O设备的分配与操纵；文件管理是用于实现对文件的存取、共享和保护。\n3. OS实现了对计算机资源的抽象\n    在裸机中，用户如果想要对计算器进行操作，必须对物理接口的实现细节有充分的了解。但在操作系统中，用户并不需要关心具体的物理，而由操作系统来实现具体的操作细节，并向上讲操作设备抽象为一组数据结构以及一组操作命令。此时在用户眼里，看到的是一台比裸机功能更强，使用更方便的机器。\n\n## 1.2.4 推动操作系统发展的主要动力\n1. 不断提高计算机资源利用率\n2. 方便用户\n3. 器件的不断更新换代\n4. 计算机体系结构的不断发展\n5. 不断提出新的应用需求\n\n# 1.3 操作系统的发展\n\n## 1.3.1 单道批处理系统\n在说单道批处理之前现要引入一个概念——作业。作业包括用户程序、数据、作业说明书。这样每一个处理对象都是作业。\n### 1. 处理过程\n每个单道批处理系统都有一个系统操作员。用户先将作业交给系统操作员，然后操作系统操作员就将一个个作业组成一批作业，输入到计算机中，在系统中形成一个自动转接的作业流，然后启动操作系统对作业自动、依次的处理，处理完成后再将处理结果返回给系统操作员，操作员在返回给用户。这样就形成了一个单道批处理过程。\n![单道批处理系统处理过程](https://blog-1255876459.cos.ap-chengdu.myqcloud.com/2019/07/19/15635340778216.png)\n\n### 2. 缺点\n系统资源得不到充分利用。这是因为在内存中仅有一道程序，每逢程序在运行中发出I/O请求后，CPU便处于等待状态，必须在I/O完成后才继续运行。\n\n## 1.3.2 多道批处理系统\n\n### 1. 处理过程\n在该系统中，用户所提交的作业先放在外存中，并排成一个队列，称为“后备队列“。然后由作业调度程序按一定的算法，从后备队列中选择若干作业调入内存。由于同时在内存中装有若干道程序，这样便可以在运行程序A时，利用其I/O操作暂停执行时的CPU空档期，再调度另一道程序B运行。\n\n### 2. 优缺点\n1. 优点\n    1. 资源利用率高\n    2. 系统吞吐量大\n2. 缺点\n    1. 平均周转时间长\n    2. 无交互能力\n\n\n## 1.3.3 分时系统\n\n### 1. 运行方式\n1. 作业直接进入内存。因为作业在磁盘上不可运行，所以作业应直接进入内存\n2. 采用轮转运行方式。如果一个作业独占CPU连续运行，那么其他作业没法运行。为了避免这种情况，引入了时间片概念。一个时间片是一个很短的时间，系统规定了每个作业每次只能运行一个时间片，然后就暂停该作业的运行，并立即调度下一个作业运行。如果在不长的时间内能使所有的作业都执行一个时间片的时间，便可以使每个用户都能及时地与自己的作业进行交互，从而使用户的请求的到及时响应。\n\n### 2. 特征\n1. 多路性\n2. 独立性\n3. 及时性\n4. 交互性\n\n## 1.3.4 实时系统\n实时系统是指系统能及时响应外部事件的请求，在规定时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。\n实时系统主要应用于：\n1. 工业（武器）控制系统\n2. 信息查询系统\n3. 多媒体系统\n4. 嵌入式系统\n\n# 1.4 操作系统的基本特征\n\n## 1.4.1 并发\n正是系统中有这一特征，才使得OS能有效地提高系统中的资源利用率，增加系统的吞吐量。\n\n### 并发与并行\n并行是指两个或多个事件在同一时刻发生，微观上是同一时刻多个线程在CPU上运行。\n并发是指宏观上两个或多个事件在同一时间发生，微观上缺是某一时刻CPU上只有一个进程。\n\n## 1.4.2 共享\n资源共享，即操作系统中的资源可供多个并发执行的进程共同使用，由于资源属性不同，多个进程对资源的共享方式也不同。可分为：互斥共享方式和同时访问方式。\n\n### 1. 互斥共享方式\n一段时间内只允许一个进程访问该资源，如磁带机,打印机等。虽然可以供多个进程使用，但是为了打印或记录结果不造成混淆，应规定一段时间内只允许一个进程访问该资源。\n\n### 2. 同时访问方式\n某些资源，一段时间内是可以允许多个进程“同时”同时对他们进行访问，这个同时是宏观上的，在微观上可能是分时共享。\n\n## 1.4.3 虚拟\n在OS中，把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为”虚拟“。\n\n## 1.4.4 异步\n在多道环境下，允许多个程序并发执行。但由于资源有限，进程的执行不是一贯到底。而是走走停停，以不可预知的速度向前推进，这就是进程的异步。\n\n# 1.5 操作系统的主要功能\n操作系统的主要功能应分为处理机管理、存储器管理、设备管理和文件管理。此外，还应向用户提供方便的用户接口。\n\n## 1.5.1 处理机管理功能\n\n### 1. 进程控制\n在多道程序环境中，为了使作业能并发执行，必须为每道作业创建一个或几个进程，并为之分配必要的资源。当进程运行结束时，应立即撤销该进程，以便能及时回收该进程所占用的各种资源，供其它进程使用。\n\n### 2. 进程同步\n为了使多个进程能有条不紊的运行，系统中必须设置相应的进程同步机制。该机制的主要任务是为多个进程的运行进行协调。\n\n### 3. 进程通信\n如果一组相互合作的进程去完成一个共同的任务时，在他们之间往往需要交换信息。\n\n### 4. 调度\n在传统OS中，调度包括作业调度和进程调度。\n1. 作业调度\n    作业调度的基本任务就是从后备队列中按照一定的算法选择出若干个作业，为他们分配所需资源，在这些作业调入内存后，分别为他们创建进程，是他们都称为可能获得处理机的就绪进程，并将他们插入就绪队列中。\n2. 进程调度\n    进程调度的任务是从进程的就绪队列中按照一定的算法选出一个进程，将处理机分配给他，并为他设置运行线程，使其投入执行。\n\n## 1.5.2 存储器管理功能\n存储器管理视为多道程序的运行提供良好的环境，提高存储器利用率，并能从逻辑上扩充内存。为此，存储器管理应具有内存分配和回收、内存保护、地址映射和内存扩充等功能。\n\n### 1. 内存分配\n内存分配主要任务是：\n1. 为每道程序分配内存空间\n2. 提高存储器的利用率，尽量减少不可用的内存空间\n3. 允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需要。\n\nOS在实现内存分配时，可采取静态和动态两种方式：\n1. 静态分配内存。每个作业的内存空间在作业装入时确定，确定后不再改变。\n2. 动态分配内存。每个作业所要求的的基本内存空间虽然也是在装入时确定的，但允许作业在运行过程中继续申请新的附加内存空间，以适应程序和数据的动态增长。\n\n### 2. 内存保护\n确保每道用户程序都在自己的内存空间内运行，彼此互不干扰。决不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其他用户程序中去执行。\n\n### 3. 地址映射\n每道程序经编译连接后所形成的的可装入程序其地址都是从0开始的，但是不可能将他们从“0”地址开始装入内存，所以物理地址和逻辑地址并不一致，这时候就需要地址映射来让程序能正常运行。\n\n### 4. 内存扩充\n借助虚拟存储技术来实现内存扩充，主要解决：\n1. 内存和I/O之间速度不匹配的问题\n2. 如果内存空间不足的问题\n\n## 1.5.3 设备管理功能\n主要任务：\n1. 完成用户进程提出的I/O请求，为用户进程分配所需的I/O设备，并完成指定的I/O操作\n2. 提高CPU与I/O设备的利用率，提高I/O速度，方便用户使用I/O\n\n为了实现以上功能，应具有缓冲管理、设备分配和设备处理以及虚拟设备等功能。\n### 1. 缓冲管理\n为了有效的缓和CPU与I/O设备间速度不匹配的问题，提高CPU利用率，于是引入了缓冲管理。\n\n### 2. 设备分配\n设备分配的基本任务是根据用户进程的I/O请求、系统现有资源情况以及按照某种设备分配策略，为之分配其所需的设备。\n\n### 3. 设备处理\n实现CPU和设备控制器之间的通信，即由CPU向设备控制器发出I/O命令，要求他完成指定的I/O操作；反之，由CPU控制从接收器发来的中断请求，并给予迅速的响应和相应的处理。\n\n## 1.5.4 文件管理功能\n主要是对用户文件和系统文件进行管理以方便用户使用，并保证文件的安全性。为此，文件管理应具有对文件存储空间管理、目录管理、文件的读/写管理以及文件的共享与保护等功能。\n\n### 1. 文件存储空间的管理\n为每个文件分配必要的外存空间，提高我村利用率，进而提高文件系统的存、取速度。\n\n### 2. 目录管理\n为每个文件建立一个目录项，目录项包括文件名、文件属性、文件在磁盘上的物理位置等，并对众多的目录项加以有效的组织，以实现方便的按名字存取。\n\n### 3. 文件的读/写管理和保护\n根据用户的请求，从外存中读取数据或将数据写入外存。并且保护文件防止其被非法盗取和破坏。\n\n## 1.5.5 操作系统与用户间的接口\n接口主要分为两大类：用户接口和程序接口。用户接口是供用户调用，方便用户直接或间接控制自己的作业。程序接口是为用户程序在执行中访问系统资源而设定的，是用户取得操作系统服务的唯一途径。","tags":["操作系统"],"categories":["操作系统"]},{"title":"Android多线程2--Java中的线程池","url":"/posts/b39fd0ab.html","content":"# 简介\n我们在写项目经常要用到多线程。但是线程的创建和摧毁都是较消耗资源和性能的，如果你每需要一个任务就新建一个线程，那可能会在线程的创建和摧毁上浪费掉很多资源。那如果我们让线程执行任务后不摧毁，接着执行下一个任务，这样是不是就能避免这种情况了。Java1.5中提供了`Executor`框架用于把任务的提交和执行解耦，任务的执行就交给`Runnable`或者`Callable`，而`Executor`框架用于处理任务。`Executor`中最核心的成员就是`ThreadPoolExecutor`，他就是线程池核心实现类。\n\n<!-- More -->\n\n# ThreadPoolExecutor\n我们现在先来看下这个方法。\n构造器：\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                        int maximumPoolSize,markdownlint\n                        long keepAliveTime,\n                        TimeUnit unit,\n                        BlockingQueue<Runnable> workQueue,\n                        ThreadFactory threadFactory,\n                        RejectedExecutionHandler handler) {\n    if (corePoolSize < 0 ||\n        maximumPoolSize <= 0 ||\n        maximumPoolSize < corePoolSize ||\n        keepAliveTime < 0)\n        throw new IllegalArgumentException();\n    if (workQueue == null || threadFactory == null || handler == null)\n        throw new NullPointerException();\n    this.corePoolSize = corePoolSize;\n    this.maximumPoolSize = maximumPoolSize;\n    this.workQueue = workQueue;\n    this.keepAliveTime = unit.toNanos(keepAliveTime);\n    this.threadFactory = threadFactory;\n    this.handler = handler;\n}\n```\n我们来看下这些参数：\n* `corePoolSize`：核心线程数。线程池刚创建的时候，线程数量为0，只有任务提交的时候才会创建线程。如果当前线程数量小于`corePoolSize`，则创建新线程；如果等于或者大于，则不再创建。\n* `maximumPoolSize`：线程池允许创建的最大线程数。当`workQueue`满了而且线程数小于`maximumPoolSize`时，线程池仍会创建新的线程。但是如果超过了`maximumPoolSize`时，则会抛出异常。\n* `keepAliveTime`：非核心线程闲置的超过时间。当线程池中线程数量大于workQueue，如果一个线程的空闲时间大于keepAliveTime，则该线程会被回收。如果任务很多，并且每个任务 的执行事件很短，则可以调大keepAliveTime来提高线程的利用率。另外，如果设置 allowCoreThreadTimeOut属性为true时，keepAliveTime也会应用到核心线程上。\n* `timeUnit`：keepAliveTime参数的时间单位。可选的单位有天(DAYS)、小时(HOURS)、分钟(MINUTES)、秒(SECONDS)、毫秒(MILLISECONDS)等。\n* `workQueue`：任务队列。如果当前线程数大于`corePoolSize`，则将任务添加到此任务队列中。该任务 队列是`BlockingQueue`类型的，也就是阻塞队列。\n* `threadFactory`：线程工厂。可以用线程工厂给每个创建出来的线程设置名字。一般情况下无须设置该参数。\n* `RejectedExecutionHandler`：饱和策略。这是当任务队列和线程池都满了时所采取的应对策略，默认是AbordPolicy，表示无法处理新任务，并抛出`RejectedExecutionException`异常。此外还有3种策略，它们分别如下:\n    1. `CallerRunsPolicy`：用调用者所在的线程来处理任务。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。\n    2. `DiscardPolicy`：不能执行的任务，并将该任务删除。\n    3. `DiscardOldestPolicy`：丢弃队列最近的任务，并执行当前的任务。\n\n# 线程池的处理流程\n线程池的任务处理主要分为3个步骤\n1. 提交任务后，线程池先判断线程数是否达到了核心线程数`corePoolSize`。如果未达到核心线程数，则创建核心线程处理任务；否则，就执行下一步操作。\n2. 接着线程池判断任务队列是否满了。如果没满，则将任务添加到任务队列中；否则，就执行下一步操作。\n3. 接着因为任务队列满了，线程池就判断线程数是否达到了最大线程数。如果未达到，则创建非核心线程处理任务；否则，就执行饱和策略，默认会抛出`RejectedExecutionException`异常。\n\n![线程池执行流程](http://psb1j8lvg.bkt.clouddn.com/mweb/屏幕快照2019-06-16下午3.03.51.png)\n1. 如果线程池中的线程数未达到核心线程数，则创建核心线程处理任务。\n2. 如果线程数大于或者等于核心线程数，则将任务加入任务队列，线程池中的空闲线程会不断地从 任务队列中取出任务进行处理。\n3. 如果任务队列满了，并且线程数没有达到最大线程数，则创建非核心线程去处理任务。\n4. 如果线程数超过了最大线程数，则执行饱和策略。\n\n# 线程池的种类\n## CachedThreadPool：可缓存线程池\n1. 线程数无限制\n2. 有空闲线程则复用空闲线程，若无空闲线程则新建线程\n3. 一定程序减少频繁创建/销毁线程，减少系统开销\n\n创建源码：\n```java\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                    60L, TimeUnit.SECONDS,\n                                    new SynchronousQueue<Runnable>());\n}\n```\n\n`CachedThreadPool`的`corePoolSize`为0，`maximumPoolSize`设置为`Integer.MAX_VALUE`，这意味着`CachedThreadPool`没有核心线程，非核心线程是无界的。`keepAliveTime`设置为60L，则空闲线程等待新任务 的最长时间为60s。在此用了阻塞队列`SynchronousQueue`，它是一个不存储元素的阻塞队列，每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都等待另一个线程的插入操作。\n\n## FixedThreadPool：定长线程池\n1. 可控制线程最大并发数（同时执行的线程数）\n2. 超出的线程会在队列中等待\n\n创建源码：\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>());\n}\n```\n\n`FixedThreadPool`的`corePoolSize`和`maximumPoolSize`都设置为创建`FixedThreadPool`指定的参数`nThreads`，也就意味着`FixedThreadPool`只有核心线程，并且数量是固定的，没有非核心线程。`keepAliveTime`设置为0L意味着多余的线程会被立即终止。因为不会产生多余的线程，所以`keepAliveTime`是无效的参数。另外，任务队列采用了无界的阻塞队列`LinkedBlockingQueue`。\n\n## ScheduledThreadPool：定长线程池\n支持定时及周期性任务执行。\n\n创建源码：\n```java\npublic static ScheduledExecutorService newScheduledThreadPool(\n        int corePoolSize, ThreadFactory threadFactory) {\n    return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);\n}\n```\n我们可以看到在创建源码中他跳转到了`ScheduledThreadPoolExecutor`的构造方法，我们继续看进去：\n```java\npublic ScheduledThreadPoolExecutor(int corePoolSize,\n                                    ThreadFactory threadFactory) {\n    super(corePoolSize, Integer.MAX_VALUE,\n            DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,\n            new DelayedWorkQueue(), threadFactory);\n}\n```\n\n从上面的代码可以看出，`ScheduledThreadPoolExecutor`的构造方法最终调用的是`ThreadPoolExecutor`的构造方法。`corePoolSize`是传进来的固定数值，`maximumPoolSize`的值是`Integer.MAX_VALUE`。因为采用的`DelayedWorkQueue`是无界的，所以`maximumPoolSize`这个参数是无效的。\n\n## SingleThreadExecutor：单线程化的线程池\n1. 有且仅有一个工作线程执行任务\n2. 所有任务按照指定顺序执行，即遵循队列的入队出队规则\n\n创建源码：\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>()));\n}\n```\n\n`corePoolSize`和`maximumPoolSize`都为1，意味着`SingleThreadExecutor`只有一个核心线程，其他的参数都和`FixedThreadPool`一样，这里就不赘述了。","tags":["Android","Java","多线程"],"categories":["Java"]},{"title":"Next配置备份","url":"/posts/5b6e53a4.html","content":"# Hexo配置备份\n<!-- More -->\n\n# 评论系统\n* 来必力 - https://www.livere.com/\n* valine(在用) - https://valine.js.org/\n\n# 阅读量显示\n* leancloud - https://leancloud.cn/\n* valine(在用) - https://valine.js.org/","tags":["Hexo"],"categories":["杂项"]},{"title":"Android多线程1--Java中的阻塞队列","url":"/posts/63ab42b7.html","content":"\n# 阻塞队列\n\n## 前言\n在谈论阻塞队列之前我们先看下操作系统多线程部分一个经典的例子——生产者和消费者问题：\n>现在有两个进程，一个是生产者一个是消费者，还有一个线程缓冲区。生产者主要作用就是向缓冲区中添加数据，消费者就是从缓冲区中取出数据。这个问题的核心就是如何确保生产者不会在缓冲区满了的时候还往其中添加元素，消费者不会在缓冲区空了的时候还要求取出数据。\n\n<!-- More -->\n关于这个问题的解决办法我们以后再说，我们现在主要讨论线程缓冲区——阻塞队列。\n## 阻塞队列简介\n阻塞队列就是队列，只是在一般的队列上添加了两个条件：\n1. 当队列满了的时候不允许再添加数据\n2. 当队列空了的时候不允许从中取数据\n\n在Java中，阻塞队列是通过`BlockingQueue`来实现的，`BlockingQueue`是`Java.util.concurrent`包下一个重要的数据结构。\n\n## BlockingQueue的操作方法\n| 方法 | 抛异常 | 返回特定值 | 阻塞 | 超时 |\n| :---: | :---: | :---: | :---: | :---: |\n|插入| add(E e) | offer(E e) | put(E e) | offer(E e, long timeout, TimeUnit unit) |\n|移除| remove() | poll() | take() | poll(time, unit) |\n|检查| element() | peek() | 不可用 | 不可用 |\n\n> 解释：\n> 1. 抛异常：如果操作无法执行，则抛出一个异常\n> 2. 特定值：如果操作无法执行，则返回一个特定的值\n> 3. 阻塞： 如果操作无法执行，则方法调用被阻塞，直到可以执行\n> 4. 超时：如果操作无法执行，则方法调用被阻塞，直到可以执行或者超过限定的时间。返回一个特定值以告知该操作是否成功(典型的是true / false)。\n\n## Java中的各种阻塞队列\n`Java`基于`BlockingQueue`给开发者提供了7个阻塞队列：\n1. `ArrayBlockingQueue`：基于数组的有界阻塞队列。有界就意味着他有一个最大限度，所存储的线程的数量不能超过这个限定值。你也可以在对其初始化的时候给定这个限定值。但是由于它是基于数组所以他和数组一样，在初始化的时候限定了这个大小以后就不能改变。\n2. `LinkedBlockingQueue`：基于链表的阻塞队列。它内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用`Integer.MAX_VALUE`作为上限。`LinkedBlockingQueue`内部以FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。由于默认是无上限的，所以在使用他的时候，如果生产者的速度大于消费者的速度，系统内存可能会被耗尽。所以使用他一定要设置初值。\n3. `PriorityBlockingQueue`：支持优先级的无界队列。默认情况按照自然顺序生序排列，你可以重写`compateTo()`方法来制定元素按规定排序。\n4. `DelayQueue`：支持延时获取元素的无界阻塞队列。队列中的元素必须实现`Delayed`接口。\n5. `SynchromousQueue`：是一个特殊的队列。他不能存储任何元素，他的每一次插入操作必须等待另一个线程相应的删除操作，反之亦然。\n6. `LinkedTransferQueue`：基于链表的无界阻塞`TransferQueue`队列。相对于其他队列，他多了`transfer(E e)`、`tryTransfer(E e)` 和 `tryTransfer(E e, long timeout, TimeUnit unit)`方法。\n7. `LinkedBlockingDeque`：是一个链表结构的双向阻塞队列。可在两端入队出对。所以当多线程入队时，减少了一半的竞争。\n\n## 阻塞队列实现原理\n下面我们以`ArrayBlockingQueue`源码为例，来看下阻塞队列实现原理：\n### 定义\n首先就是一堆变量的定义：\n```java\n/** The queued items */\nfinal Object[] items;\n\n/** items index for next take, poll, peek or remove */\nint takeIndex;\n\n/** items index for next put, offer, or add */\nint putIndex;\n\n/** Number of elements in the queue */\nint count;\n\n/*\n * Concurrency control uses the classic two-condition algorithm\n * found in any textbook.\n */\n\n/** Main lock guarding all access */\nfinal ReentrantLock lock;\n\n/** Condition for waiting takes */\nprivate\nfinal Condition notEmpty;\n\n/** Condition for waiting puts */\nprivate\nfinal Condition notFull;\n```\n`items`是存储队列元素的数组，`takeIndex`和`putIndex`分别是取数据和存数据的索引，`count`是队列中元素个数，`lock`为看一个可重入锁，`notEmpty`和`notFull`均为等待条件，由`loc`k创建。\n\n### 构造器\n接下来看下它的构造器\n```java\npublic ArrayBlockingQueue(int capacity) {\n}\n\npublic ArrayBlockingQueue(int capacity, boolean fair) { \n}\n\npublic ArrayBlockingQueue(int capacity, boolean fair, Collection<? extends E> c) {\n}\n```\n构造器有三个重载的版本，第一个构造器只有一个参数用来指定容量，第二个构造器多了一个参数来指定访问策略，第三个构造器又多了一个参数可以指定用另外一个集合进行初始化。\n\n### 数据的添加\n接下来我们看看`BlockingQueue`的三个插入的方法：`put()`、`add()`和`offer()`：\n* `put()` 方法：队列满，会阻塞调用存储元素的线程\n\n```java\npublic void put(E e) throws InterruptedException {\n    // 先检查e是不是空，如果空则抛异常\n    Objects.requireNonNull(e);\n    // 获取一个重入锁lock\n    final ReentrantLock lock = this.lock;\n    // 加锁，保证调用put方法的时候只有1个线程\n    lock.lockInterruptibly();\n    try {\n    // 如果线程中的元素数量是否等于当前数组的长度，如果相等则调用await方法等待，如果不相等则enqueue方法插入元素\n        while (count == items.length)\n            notFull.await();\n        enqueue(e);\n    } finally {\n    // 解锁\n        lock.unlock();\n    }\n}\n```\n* `add()`方法：实际上调用了`offer()`方法\n\n```java\npublic boolean add(E e) {\n    if (offer(e))\n        return true;\n    else\n        throw new IllegalStateException(\"Queue full\");\n}\n```\n* `offer()`方法：成功返回true，失败返回false\n\n```java\npublic boolean offer(E e) {\n    // 检查e是否为空\n    Objects.requireNonNull(e);\n    // 获取重入锁lock\n    final ReentrantLock lock = this.lock;\n    // 加锁\n    lock.lock();\n    try {\n        // 如果如果线程中的元素数量是否等于当前数组的长度，如果相等则调返回false，如果不相等则enqueue方法插入元素并返回true\n        if (count == items.length)\n            return false;\n        else {\n            enqueue(e);\n            return true;\n        }\n    } finally {\n        // 解锁\n        lock.unlock();\n    }\n}\n```\n\n以上三个方法都调用了`enqueue()`方法。下面我们就来看看这个方法：\n```java\n/**\n * Inserts element at current put position, advances, and signals.\n * Call only when holding lock.\n */\nprivate void enqueue(E e) {\n    // assert lock.isHeldByCurrentThread();\n    // assert lock.getHoldCount() == 1;\n    // assert items[putIndex] == null;\n    final Object[] items = this.items;\n    items[putIndex] = e;\n    if (++putIndex == items.length) \n        putIndex = 0;\n    count++;\n    notEmpty.signal();\n}\n```\n先获取元素数组`items`，然后添加`putIndex`上，如果`++putIndex`等于`items`的长度，则证明当前这个`items`所有元素都添加进了，就让`putIndex`等于0.然后调用`notEmpty.signal()`方法唤醒正在获取元素的线程，让他们从队列中取数据。\n\n### 数据的取出\nArrayBlockingQueue的取数据方法总共也有三个方法：`poll()`、`take()`和`remove()`\n* `poll()`方法：获取元素，存在返回元素e,不存在返回null\n \n```java\npublic E poll() {\n    // 获取重入锁lock\n    final ReentrantLock lock = this.lock;\n    // 加锁\n    lock.lock();\n    try {\n        // 如果元素数量等于0就返回null，否则调用dequeue()方法\n        return (count == 0) ? null : dequeue();\n    } finally {\n        // 解锁\n        lock.unlock();\n    }\n}\n```\n* `take()`方法：取元素。如果队列为空,则会阻塞调用获取元素的线程\n\n```java\npublic E take() throws InterruptedException {\n    // 获取重入锁lock\n    final ReentrantLock lock = this.lock;\n    // 加锁\n    lock.lockInterruptibly();\n    try {\n        // 如果线程中的元素数量是否等于0，如果相等则调用await方法等待，如果不相等则dequeue方法删除元素\n        while (count == 0)\n            notEmpty.await();\n        return dequeue();\n    } finally {\n        // 解锁\n        lock.unlock();\n    }\n}\n```\n* `remove()`方法：取元素，它是取特定的那个元素\n\n```java\npublic boolean remove(Object o) {\n    // 判断o是否为空\n    if (o == null) return false;\n    // 获取重入锁lock\n    final ReentrantLock lock = this.lock;\n    // 加锁\n    lock.lock();\n    try {\n        // 如果元素数量大于0，则获取items，然后便利元素，判断o是其中的哪个，然后删除那个\n        if (count > 0) {\n            final Object[] items = this.items;\n            for (int i = takeIndex, end = putIndex, to = (i < end) ? end : items.length; ; i = 0, to = end) {\n                for (; i < to; i++)\n                    if (o.equals(items[i])) {\n                        removeAt(i);\n                        return true;\n                    }\n                if (to == end) break;\n            }\n        }\n        return false;\n    } finally {\n        // 解锁\n        lock.unlock();\n    }\n}\n```\n`poll()`和`take()`两个方法都调用了`dequeue()`方法，我们就看下`dequeue()`是如何来实现的：\n```java\n/**\n * Extracts element at current take position, advances, and signals.\n * Call only when holding lock.\n */\nprivate E dequeue() {\n    // assert lock.isHeldByCurrentThread();\n    // assert lock.getHoldCount() == 1;\n    // assert items[takeIndex] != null;\n    final Object[] items = this.items;\n    @SuppressWarnings(\"unchecked\")\n    E e = (E) items[takeIndex];\n    items[takeIndex] = null;\n    if (++takeIndex == items.length) takeIndex = 0;\n    count--;\n    if (itrs != null)\n        itrs.elementDequeued();\n    notFull.signal();\n    return e;\n}\n```\n和上面的`enqueue()`方法类似，再次就不再赘述。\n\n## 阻塞队列的应用\n前面我说过，阻塞队列主要用在生产者和消费者模式中，那下面我们就来写一个简单的小demo\n>>这段代码来自刘望舒所著《Android进阶之光》\n\n如果不用阻塞队列：\n```java\nimport java.util.PriorityQueue;\n\npublic class Test {\n    private int queueSize = 10;\n    private PriorityQueue<Integer> queue = new PriorityQueue<>(queueSize);\n\n    public static void main(String[] args) {\n        Test test = new Test();\n        Producer producer = test.new Producer();\n        Consumer consumer = test.new Consumer();\n        producer.start();\n        consumer.start();\n    }\n\n    class Consumer extends Thread {\n        @Override\n        public void run() {\n            while (true) {\n                synchronized (queue) {\n                    while (queue.size() == 0) {\n                        try {\n                            System.out.println(\"队列空，等待数据\");\n                            queue.wait();\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                            queue.notify();\n                        }\n                    }\n                    // 每次移走队首元素\n                    queue.poll();\n                    queue.notify();\n                }\n            }\n        }\n    }\n\n    private class Producer extends Thread {\n        @Override\n        public void run() {\n            while (true) {\n                synchronized (queue) {\n                    try {\n                        System.out.println(\"队列满，等待有空余空间\");\n                        queue.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                        queue.notify();\n                    }\n                }\n                // 每次插入一个元素\n                queue.offer(1);\n                queue.notify();\n            }\n        }\n    }\n}\n```\n\n使用阻塞队列`ArrayBlockingQueue`：\n```java\nimport java.util.concurrent.ArrayBlockingQueue;\n\npublic class BlockingQueueTest {\n    private int queueSize = 10;\n    private ArrayBlockingQueue<Integer> queue = new ArrayBlockingQueue<>(queueSize);\n\n    public static void main(String[] args) {\n        BlockingQueueTest test = new BlockingQueueTest();\n        BlockingQueueTest.Producer producer = test.new Producer();\n        BlockingQueueTest.Consumer consumer = test.new Consumer();\n        producer.start();\n        consumer.start();\n    }\n\n    class Consumer extends Thread {\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    queue.take();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private class Producer extends Thread {\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    queue.put(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```","tags":["Android","Java","多线程"],"categories":["Java"]},{"title":"Kotlin入门1:Kotlin和Java区别基础篇","url":"/posts/343b01ae.html","content":"# Koltin入门\n# Kotlin简介\n> 科特林岛(Котлин)是一座俄罗斯的岛屿,位于圣彼得堡以西约30公里处,形状狭长,东西长度约14公里,南北宽度约2公里,面积有16平方公里,扼守俄国进入芬兰湾的水道。科特林岛上建有喀琅施塔得市,为圣彼得堡下辖的城市。\n\n而我们虽说的kotlin，就是一门根据它命名的一种现代程序设计语言。Kotlin 是一个用于现代多平台应用的静态编程语言，由 JetBrains 开发。Kotlin可以编译成Java字节码，也可以编译JavaScript，方便在没有JVM的设备上运行。Kotlin已正式成为Android官方支持开发语言。\n\n<!-- More -->\n-------\n\n\n# 变量\nkotlin和Java的最基本的区别就是kotlin中**万物皆对象**，Java中还存在着int、float等基本类型，但是在kotlin中，它把这些都定义成了对象，类似于Java中的封装类\n## 变量的声明\n上面说了，kotlin万物皆对象，所以所有的变量也都是对象。\n在kotlin定义对象和Java有点小区别。\nkotlin定义对象的格式为\n>  声明类型 变量名： 变量类型\n\n其中：\n* 声明类型分为`val`和`var`。`val`是不可变类型，类似于const，定义时必须赋值，赋值后不能被修改。`var`是可变类型。\n* 变量名就是你定义的这个变量的名称。\n* 变量类型就是你这个变量对应的类的名字。\n\n## 类型推断\n### 省去变量类型\nkotlin里面类似c++的`auto`类型，对于基本类型，你可以不写变量类型，kotlin会自动帮你判断。\n\n```kotlin\nvar a = 5\nprintln(a is Int)\n\nvar b = “123\nprintln(b is String)\n\nvar c = 1.3\nprintln(c is Float)\n\nvar d = true\nprintln(d is Boolean)\n```\n\n### `is`关键字\n`is`顾名思义，就是判断这个变量是不是这个类型的实例。\n例子见上。\n\n## 数字类型\n\n|  类型  |  宽度(bit)  |\n| --- | --- |\n|  Byte |   8 |\n| Short |  16  |\n|  Int  |  32  |\n|  Long  |  64  |\n|  Float  |  32  |\n| Double   |  64  |\n\n这些类型都继承自`Number`和`Comparable`类。\n\n### 字面常量值\n* 十进制：`123`\n* 十六进制：`0x0f`\n* 二进制：`0b0010`\n* Long类型：`123L`\n* double类型：123.4\n* Float类型：`123.4f`或者`123.4F`\n\n我们也可以使用下划线`_`来方便我们阅读\n\n```kotlin\n1_000_000 // 1000000\n0xFF_EC // 0xFFEC\n```\n### 显示转换\nkotlin中不可隐式转换\n比如Java 中\n\n```java\nint a = 2;\nlong b = a;\n```\n但是在kotlin中\n\n```kotlin\nvar a : Int? = 2\nvar b : Long? = a; // error\nvar b : Long? = a.toLong()\n```\n\n## Char类型\nkotlin中的`Char`表示字符。但是和Java不同，他不能直接当ASCII码值。\n\n```kotlin\nfun check(c : Char) {\n    if (c == 1) { // error \n    \n    }\n}\n```\n\n## Boolean类型\nkotlin中的布尔类型用`Boolean`来表示，他有两个值`true`和`false`。用法和Java一样。\n\n## String类型\n和Java一样，kotlin中的字符串也是`String`。但是kotlin中`String`是不可变的。所以kotlin中`String`必须是`val`类型。同时，`String`是`final`不可继承的。\n\n## Array类型\nkotlin中数组必须使用`Array`表示。\n基本写法\n> val array: Array<类型> = arrayOf(..)\n\n例如\n```kotlin\n/**整型Int的数组*/\nval arrayOfInt: IntArray = intArrayOf(1,3,5,7,9)\n/**字符Char类型的数组*/\nval arrayOfChar: CharArray = charArrayOf('H','e','l','l','o','W','o','r','l','d')\n/**字符串String数组*/\nval arrayOfString: Array<String> = arrayOf(\"Hello\",\"World\")\n\nfun main(args: Array<String>) {\n    //查看有多少个元素\n    println(arrayOfInt.size)\n    //遍历数组\n    for (char in arrayOfChar){\n        println(char)\n    }\n\n    //根据所引获取数据,数组是从0开始的，现在获取第二个东京大学\n    println(arrayOfUniversity[1])\n    //重新给数组赋值，早稻田大学\n    arrayOfUniversity[1] = University(\"早稻田大学\")\n    println(arrayOfUniversity[1])\n\n    //将char连接成一个字符串,默认是自动由逗号\",\"分割的，输出H, e, l, l, o, W, o, r, l, d\n    println(arrayOfChar.joinToString())\n    //如果想要连成HelloWorld\n    println(arrayOfChar.joinToString (\"\"))\n\n    //数组的切片,输出3，5,结尾需要arrayOfInt-1，不然会报索引越界异常\n    println(arrayOfInt.slice(1..2))\n\n    println(arrayOfInt.size)\n}\n```","tags":["Kotlin","语言基础"],"categories":["Kotlin"]},{"title":"Kotlin Anko入门","url":"/posts/62bb1dd7.html","content":"# Kotlin Anko入门\n\n# 简介\nAnko的官网就是他的GitHub地址\n> https://github.com/Kotlin/anko\n\n官方对Anko的解释是\n> Anko是一个 [Kotlin](https://www.kotlinlang.org/) 库，它使Android应用程序开发更快更容易。它使您的代码清晰易读，让您忘记Android SDK for Java的粗糙边缘。\n\n<!-- More -->\n为什么这样说呢？\n比方说如果你写Android，你在xml中定义了一个`Button`，他的ID是`button_login`。\n如果是Java：\n```java\nsetContentView(R.layout.activity_words_detail);\nButton button = findViewById(R.Id.button_login);\n```\n而如果你使用kotlin的话，你可以就按如下代码写\n```kotlin\nimport kotlinx.android.synthetic.main.activity_kotlin_main.*\n...\nbutton_login.setText(\"Kotlin Android Extensions 我不太喜欢\");\n```\n这样确实比Java方便多了，不需要对每一个组件都定义再findViewById，可以就直接输入组件的id然后就能使用了。但是我们还是觉得不够啊，为什么我们不能就直接在代码中写入各个组件呢，于是，Anko来了。\n\n# 导入Anko\nAnko由几部分组成：\n* *Anko Commons*：一个轻量级的库，包含用于Layouts，Intent，Log等的帮助程序;\n* *Anko Layouts*：一种快速且类型安全的方式来编写动态Android布局;\n* *Anko SQLite*：Android SQLite的查询DSL和解析器集合;\n* *Anko Coroutines*：基于[kotlinx.coroutines](https://github.com/Kotlin/kotlinx.coroutines)库的实用程序。\n\n你可以在app的`build.gradle`中添加\n```java\ndependencies {\n     // Anko Layouts\n    implementation \"org.jetbrains.anko:anko-sdk25:$anko_version\" // sdk15, sdk19, sdk21, sdk23 are also available\n    implementation \"org.jetbrains.anko:anko-appcompat-v7:$anko_version\"\n\n    // Coroutine listeners for Anko Layouts\n    implementation \"org.jetbrains.anko:anko-sdk25-coroutines:$anko_version\"\n    implementation \"org.jetbrains.anko:anko-appcompat-v7-coroutines:$anko_version\"}\n```\n这个依赖可以直接导入所有的可用特性（包括Commons, Layouts, SQLite)。\n\n# 使用Anko layout\n\n## 创建简单布局\n使用Anko创建布局很简单：\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        verticalLayout {\n            padding = dip(30)\n            editText {\n                hint = \"Name\"\n                textSize = 24f\n            }\n            editText {\n                hint = \"Password\"\n                textSize = 24f\n            }\n            button(\"登录\") {\n                textSize = 26f\n            }\n        }\n    }\n}\n```\n\n你只需要在Activity中写入DSL代码就能使用它。\n\n## AnkoComponent\n尽管我们现在可以直接在Activity中写入DSL代码，但是我们还是觉得把代码和布局文件放在一起不太好，希望把Activity和DSl代码放到两个不同的类里面，所以AnkoComponent就出来了。\n代码如下\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        MainActivityUI().setContentView(this)\n    }\n}\n\nclass MainActivityUI : AnkoComponent<MainActivity> {\n    override fun createView(ui: AnkoContext<MainActivity>) = with(ui) {\n        verticalLayout {\n            padding = dip(30)\n            editText {\n                hint = \"Name\"\n                textSize = 24f\n            }\n            editText {\n                hint = \"Password\"\n                textSize = 24f\n            }\n            button(\"登录\") {\n                textSize = 26f\n            }\n        }\n    }\n}\n```\n\n## Theme\n在Anko如果你想设置Theme需要使用`themeable`\n```kotlin\nverticalLayout {\n    padding = dip(30)\n    themedButton(\"登陆\", theme = R.style.Base_TextAppearance_AppCompat_Button)\n}\n```\n\n## LayoutParams\n在Anko中也可以使用`LayoutParams`。\n比方说我现在要显示一个button，下面显示一个图片。\n\n如果使用XML:\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"\n    tools:context=\".MainActivity\">\n\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Hello World!\"\n        android:gravity=center\n        android:textSize=\"20sp\" />\n\n    <ImageView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:background=\"@color/colorAccent\" />\n\n</LinearLayout>\n```\n\n但是使用Anko:\n\n```kotlin\nverticalLayout {\n    textView (\"Hello World!\") {\n        textSize = sp(12).toFloat()\n    }.lparams(height = wrapContent, width = wrapContent) {\n        horizontalGravity = Gravity.CENTER_HORIZONTAL\n    }\n    imageView {\n        backgroundColor = Color.BLUE\n    }.lparams(height = matchParent, width = matchParent)\n}\n```\n\n注意：\n* `horizontalMargin` 同时设置 left 和 right margins\n* `verticalMargin` 同时设置 top 和 bottom\n* `margin` 同时设置4个方向的 margins\n\n## Listeners\n在Anko中设置`Listeners`非常简单，我下面以`Button`的`OnClick`举例：\n```kotlin\nbutton(\"登录\") {\n    id = buttonLogin\n    textSize = 26f\n    onClick { toast(\"OnClickLoginButton\") }\n}\n```\n\n## 使用Fragment加载\n先创建一个`Activity`，把`Fragment`加进去\n```kotlin\nclass AnkoFragmentActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        linearLayout {\n            id = R.id.fragment_id\n            supportFragmentManager.beginTransaction().replace(id, AnkoFragment.newInstance()).commit()\n        }\n    }\n}\n```\n然后在`Fragment`的`onCreateView()`中加入DSL代码，然后返回`View`即可\n```kotlin\nclass AnkoFragment : Fragment() {\n    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {\n        // return inflater.inflate(R.layout.fragment_anko, container, false)\n        return UI {\n            verticalLayout {\n                editText()\n                button(\"OK\")\n            }\n        }.view\n    }\n    companion object {\n        fun newInstance(): AnkoFragment {\n            return AnkoFragment()\n        }\n    }\n}\n```\n\n## 不足\nAnkoLayout确实挺好的，因为他把UI代码集成到了代码文件中，不用再像以前一样写一个点击事件还得先`findViewBuId`，然后再`setOnClickListeners`。代码能非常简洁。\n\n但是AnkoLayout还是不够完美，感觉写起来还是没有XML那个顺手（可能是我写惯了XML，刚开始用Anko还不够熟练），而且Anko还有很多控件都不支持。\n最重要的是，**他没有实时预览**！！！\n> Android Studio里面有一个叫`Anko Support`的插件，可以实现anko的预览，但是他必须是先将项目构建了再预览的，不算是实时预览","tags":["Android","Kotlin"],"categories":["Kotlin"]},{"title":"Android类之SharedPreferences","url":"/posts/8a47fe84.html","content":"# Android类之SharedPreferences\n# 简介\nSharedPreferences是一个轻量的存储类，用于把一些只需要少量简单类型数据保存到本地，例如搜索历史、用户设置等。 他只适合处理简单的数据，处理太过于庞大的数据会减慢程序运行。\n\n<!-- More -->\n\n# 使用步骤\n## 1. 存储数据\n1. 使用Activity类的getSharedPreferences()方法获得SharedPreferences对象，其中存储key-value的文件名由getSharedPreferences()方法的第一个参数指定。\n2. 使用SharedPreferences接口的edit()获得SharedPreferences.Editor对象。\n3. 通过SharedPreferences.Editor接口的putXxx()方法保存key-value对，其中Xxx表示不同的数据类型。例如：字符串类型的value需要用putString方法。\n4. 通过SharedPreferences.Editor接口的commit()方法保存key-value对，commit方法相当于数据库事务中的提交操作。\n\n```java\nSharedPreferences sharedPreferences = getSharedPreferences(\"test\", Context.MODE_PRIVATE);\nEditor editor = sharedPreferences.edit();//获取编辑器\neditor.putString(\"name\", \"小明\");\neditor.putInt(\"age\", 24);\neditor.commit();//提交修改\n```\n\n## 2. 读取数据\n1. 使用Activity类的getSharedPreferences()方法获得SharedPreferences对象。\n2. 通过SharedPreferences对象的getXxx()方法得到数据。\n\n```java\nSharedPreferences sharedPreferences= getSharedPreferences(\"test\", Activity.MODE_PRIVATE);\n// 使用getString方法获得value，注意第2个参数是value的默认值   \nString name =sharedPreferences.getString(\"name\", \"\");\nint age =sharedPreferences.getInt(\"age\", 0);\n```\n`SharedPreferences`的四种模式\n\n```java\nContext.MODE_PRIVATE：为默认操作模式,代表该文件是私有数据,只能被应用本身访问,在该模式下,写入的内容会覆盖原文件的内容\nContext.MODE_APPEND：模式会检查文件是否存在,存在就往文件追加内容,否则就创建新文件.\nContext.MODE_WORLD_READABLE：表示当前文件可以被其他应用读取.\nContext.MODE_WORLD_WRITEABLE：表示当前文件可以被其他应用写入.\n```","tags":["Android","View"],"categories":["Android"]},{"title":"AndroidView之PopupWindow","url":"/posts/1900f7eb.html","content":"# AndroidView之PopupWindow\n\n因为项目中有很多地方都需要使用PopupWindow，所以特别查了一下，做了一个简单的总结，过两天就加到项目中去。\n\n<!-- More -->\n\n# PopupWindow\nPopupWindow，顾名思义，就是一个用来显示弹窗的组件。\n\n# 创建步骤\n1. 创建PopupWindow实例\n2. 设置一些基本参数\n3. 显示PopupWindow\n# 构造方法\n\n```java\nPopupWindow window = new PopupWindow(View contentView, int width, int height, boolean focusable);\n```\n\n这个方法有四个参数，第一个参数是用于PopupWindow中的View，第二个参数是PopupWindow的宽度，第三个参数是PopupWindow的高度，第四个参数指定PopupWindow能否获得焦点。\n\n示例代码\n\n```java\nView contentView = LayoutInflater.from(MainActivity.this).inflate(R.layout.popuplayout, null);\nPopupWindwo window = PopupWindow (contentView, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, true);\n```\n\n# 基本方法\n- window.setBackgroundDrawable(Drawable background); 设置PopupWindow的背景\n- window.setOutsideTouchable(boolean touchable); 设置PopupWindow是否能响应外部点击事件\n- window.setTouchable(boolean touchable); 设置PopupWindow是否能响应点击事件\n只有同时设置PopupWindow的背景和可以响应外部点击事件，它才能“真正”响应外部点击事件。\n\n# 显示PopupWindow\n- window.showAtLocation(View parent, int gravity, int x, int y); 第一个参数是PopupWindow的父View，第二个参数是PopupWindow相对父View的位置，第三和第四个参数分别是PopupWindow相对父View的x、y偏移\n- window.showAsDropDown(View anchor, int xoff, int yoff, int gravity); 第一个参数是PopupWindow的锚点，第二和第三个参数分别是PopupWindow相对锚点的x、y偏移\n\n# 为PopupWindow添加动画\n- 进入时动画：(context_menu_enter.xml)\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<set xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <translate\n        android:duration=\"@android:integer/config_shortAnimTime\"\n        android:fromXDelta=\"0\"\n        android:fromYDelta=\"100%p\"\n        android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\"\n        android:toXDelta=\"0\"\n        android:toYDelta=\"0\"/>\n \n</set>\n```\n- 退出时动画：(context_menu_exit.xml)\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<set xmlns:android=\"http://schemas.android.com/apk/res/android\" >\n \n    <translate\n        android:duration=\"@android:integer/config_shortAnimTime\"\n        android:fromXDelta=\"0\"\n        android:fromYDelta=\"0\"\n        android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\"\n        android:toXDelta=\"0\"\n        android:toYDelta=\"100%p\" />\n \n</set>\n```\n- 生成style\n\n```\n<style name=\"contextMenuAnim\" parent=\"@android:style/Animation.Activity\">\n    <item name=\"android:windowEnterAnimation\">@anim/context_menu_enter</item>\n    <item name=\"android:windowExitAnimation\">@anim/context_menu_exit</item>\n</style>\n```","tags":["Android","View"],"categories":["Android"]}]